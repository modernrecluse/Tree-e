<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tree-e - Hierarchical Note Taking</title>

<!-- PWA Meta Tags -->

<meta name="description" content="Tree-e: Hierarchical note-taking app with beautiful themes">
<meta name="theme-color" content="#e9f5e9">
<link rel="manifest" href="data:application/json;base64,eyJuYW1lIjoiVHJlZS1lIiwic2hvcnRfbmFtZSI6IlRyZWUtZSIsImRpc3BsYXkiOiJzdGFuZGFsb25lIiwic3RhcnRfdXJsIjoiLyIsInRoZW1lX2NvbG9yIjoiI2U5ZjVlOSIsImJhY2tncm91bmRfY29sb3IiOiIjZTlmNWU5IiwiaWNvbnMiOlt7InNyYyI6ImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIWnBaWGRDYjNnOUlqQWdNQ0F4TWpnZ01USTRMQ0lqSURFeU9DQXhNamt6TGpGMWNpNGhMU0lnWm1sc2JEMGlJek5tWm1NeVlpSStQR04xY21ObElDOStQSEJoZEdnZ1pEMGlUVEkxSURjMElHTnNhWEJRWVhSb1BDOWpkWEpqYkdVK1BHTnBjbU5zWlNCamVEMGlObVFpSUdONVBTSTJaQ0lnY2owNU1pd2dOUGdnTWpOa01EWk1OUzhpSUdac2JIcGJKVGMwT1RVaU5qWWlQand2WTJseVkyeGxQanh6ZEhKdmEyVWdkMmxrZEdnOVlqTWlJR2hsYVdkb2REMGlOakkwSWlCamIyeDFjeWNpSWlCelpubHNaVDBpZDBsc1lXWGtPVFprWnpBaE1qQXNPREkyWklCMFpXMWpkVDRpSUhCdlpXbHVkR2s5VGpFa2NTSXZQanczSWo0OEwzTjJaejQ9IiwidHlwZSI6ImltYWdlL3N2Zyt4bWwiLCJzaXplcyI6IjEyOHgxMjgifV19">

<!-- React and Babel -->

<script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>

<script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>

<script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>

<!-- Fonts -->

<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">

<style>
    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
    }
    
    body {
        font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        touch-action: manipulation;
        user-select: none;
        -webkit-user-select: none;
        -webkit-tap-highlight-color: transparent;
        overflow-x: hidden;
        font-size: 16px;
    }
    
    .app {
        height: 100vh;
        height: 100dvh;
        display: flex;
        flex-direction: column;
        overflow: hidden;
        width: 100vw;
    }
    
    .header {
        display: flex;
        flex-direction: column;
        padding: 1rem;
        flex-shrink: 0;
        border-bottom: 1px solid rgba(0,0,0,0.08);
        gap: 0.5rem;
    }
    
    .header-main {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.75rem;
        flex-wrap: wrap;
    }
    
    .header-title {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        flex-wrap: wrap;
    }
    
    .header h1 {
        font-size: clamp(1rem, 4vw, 1.25rem);
        font-weight: 600;
        margin: 0;
    }
    
    .badge {
        font-size: clamp(0.625rem, 2.5vw, 0.75rem);
        padding: 0.125rem 0.375rem;
        border-radius: 4px;
        display: flex;
        align-items: center;
        gap: 0.25rem;
    }
    
    .header-controls {
        display: flex;
        gap: clamp(0.375rem, 2vw, 0.5rem);
        align-items: center;
    }
    
    .control-btn {
        width: clamp(32px, 8vw, 36px);
        height: clamp(32px, 8vw, 36px);
        border: 1px solid;
        border-radius: 6px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: clamp(0.875rem, 3vw, 1rem);
        cursor: pointer;
        background: transparent;
        flex-shrink: 0;
        transition: transform 0.1s ease;
    }
    
    .control-btn:active {
        transform: scale(0.95);
    }
    
    .control-btn:disabled {
        opacity: 0.4;
        cursor: not-allowed;
        transform: none;
    }
    
    .tree-nav {
        display: flex;
        gap: 0.25rem;
        align-items: center;
    }
    
    .nav-btn {
        width: 28px;
        height: 28px;
        border: 1px solid;
        border-radius: 4px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 0.75rem;
        cursor: pointer;
        background: transparent;
    }
    
    .nav-counter {
        font-size: 0.75rem;
        padding: 0 0.25rem;
        font-family: 'JetBrains Mono', monospace;
    }
    
    .breadcrumbs {
        display: flex;
        align-items: center;
        gap: 0.25rem;
        flex-wrap: wrap;
        font-family: 'JetBrains Mono', monospace;
        font-size: clamp(0.6875rem, 2vw, 0.75rem);
    }
    
    .breadcrumb-btn {
        background: none;
        border: none;
        cursor: pointer;
        text-decoration: underline;
        font: inherit;
    }
    
    .breadcrumb-sep {
        opacity: 0.6;
    }
    
    .breadcrumb-current {
        font-weight: 600;
        opacity: 1;
    }
    
    .close-btn {
        background: #22c55e;
        color: white;
        border: none;
        padding: 0.25rem 0.5rem;
        border-radius: 4px;
        font-size: 0.75rem;
        cursor: pointer;
        margin-left: 0.5rem;
    }
    
    .main-content {
        flex: 1;
        overflow: hidden;
        display: flex;
        flex-direction: column;
    }
    
    .tree-container {
        flex: 1;
        overflow-y: auto;
        overflow-x: hidden;
        padding: clamp(0.75rem, 3vw, 1rem);
    }
    
    .nodes-list {
        display: flex;
        flex-direction: column;
        gap: 0.125rem;
        padding-bottom: 2rem;
    }
    
    .node {
        display: flex;
        align-items: flex-start;
        gap: 0;
    }
    
    .node-indent {
        display: flex;
        flex-shrink: 0;
    }
    
    .indent-space {
        width: clamp(24px, 5vw, 32px);
    }
    
    .node-content-wrapper {
        display: flex;
        flex-direction: column;
        align-items: flex-start;
    }
    
    .node-content {
        padding: 8px 12px;
        border-radius: 6px;
        border: 1px solid;
        cursor: pointer;
        display: inline-flex;
        align-items: center;
        gap: 8px;
        word-wrap: break-word;
        overflow-wrap: break-word;
        transition: transform 0.1s ease;
        max-width: calc(100vw - 60px);
        width: auto;
    }
    
    .node-content:active {
        transform: scale(0.98);
    }
    
    .node-content.selected {
        border-width: 2px;
    }
    
    .node-content.completed {
        opacity: 0.6;
    }
    
    .task-toggle {
        font-size: 16px;
        cursor: pointer;
        flex-shrink: 0;
    }
    
    .node-text {
        flex: 1;
        font-size: clamp(0.875rem, 3vw, 1rem);
        line-height: 1.4;
        min-width: 0;
    }
    
    .node-text.completed {
        text-decoration: line-through;
    }
    
    .node-icons {
        display: flex;
        gap: 4px;
        font-size: 12px;
        opacity: 0.7;
        flex-shrink: 0;
    }
    
    .branch-link {
        color: #3b82f6;
        cursor: pointer;
        opacity: 1;
    }
    
    .node-actions {
        display: flex;
        gap: 6px;
        margin-top: 8px;
        flex-wrap: wrap;
    }
    
    .action-btn {
        display: flex;
        align-items: center;
        gap: 4px;
        padding: 5px 10px;
        border: none;
        border-radius: 4px;
        font-size: 11px;
        color: white;
        cursor: pointer;
        transition: transform 0.1s ease;
    }
    
    .action-btn:active {
        transform: scale(0.95);
    }
    
    .action-btn.edit { background: #6366f1; }
    .action-btn.task { background: #22c55e; }
    .action-btn.focus { background: #3b82f6; }
    .action-btn.branch { background: #10b981; }
    .action-btn.delete { background: #ef4444; }
    .action-btn.save { background: #22c55e; }
    .action-btn.cancel { background: #6b7280; }
    
    .node-edit-input {
        background: transparent;
        border: none;
        outline: none;
        font: inherit;
        width: 100%;
        min-width: 100px;
    }
    
    .input-area {
        flex-shrink: 0;
        padding: 16px;
        border-top: 1px solid rgba(0,0,0,0.08);
    }
    
    .input-container {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 12px 16px;
        border: 1px solid;
        border-radius: 8px;
        cursor: text;
    }
    
    .input-prompt {
        font-family: 'JetBrains Mono', monospace;
        font-size: 20px;
        font-weight: 500;
    }
    
    .indent-indicator {
        font-family: 'JetBrains Mono', monospace;
        font-size: 12px;
        opacity: 0.6;
    }
    
    .main-input {
        flex: 1;
        border: none;
        outline: none;
        background: transparent;
        font-family: 'JetBrains Mono', monospace;
        font-size: 16px;
    }
    
    .main-input::placeholder {
        opacity: 0.6;
    }
    
    .instructions {
        margin-top: 10px;
        font-family: 'JetBrains Mono', monospace;
        font-size: 11px;
        opacity: 0.6;
        text-align: center;
        line-height: 1.4;
    }
    
    .empty-state {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 1rem;
        padding: 3rem 1rem;
        text-align: center;
    }
    
    .empty-icon {
        font-size: 2.5rem;
        opacity: 0.6;
    }
    
    .empty-title {
        font-size: 1rem;
        font-weight: 500;
    }
    
    .empty-desc {
        font-size: 0.875rem;
        opacity: 0.7;
        line-height: 1.4;
    }
    
    .modal {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0,0,0,0.5);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000;
        padding: 20px;
    }
    
    .modal-content {
        width: 100%;
        max-width: 500px;
        max-height: 80vh;
        border-radius: 8px;
        overflow: hidden;
        display: flex;
        flex-direction: column;
    }
    
    .modal-header {
        padding: 16px;
        border-bottom: 1px solid rgba(0,0,0,0.08);
        display: flex;
        align-items: center;
        justify-content: space-between;
    }
    
    .modal-title {
        font-size: 16px;
        font-weight: 600;
        margin: 0;
    }
    
    .modal-close {
        background: none;
        border: none;
        font-size: 16px;
        cursor: pointer;
        padding: 4px;
    }
    
    .modal-body {
        flex: 1;
        overflow-y: auto;
        padding: 16px;
    }
    
    .note-editor {
        width: 100%;
        min-height: 200px;
        padding: 12px;
        border: 1px solid rgba(0,0,0,0.15);
        border-radius: 6px;
        font-size: 14px;
        font-family: inherit;
        resize: vertical;
    }
    
    .dropdown {
        position: relative;
        display: inline-block;
    }
    
    .dropdown-content {
        position: absolute;
        top: 100%;
        right: 0;
        background: white;
        border: 1px solid #ccc;
        border-radius: 6px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        z-index: 100;
        min-width: 140px;
        max-height: 300px;
        overflow-y: auto;
    }
    
    .dropdown-item {
        padding: 8px 12px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: space-between;
        border: none;
        background: none;
        width: 100%;
        text-align: left;
        font-size: 0.875rem;
    }
    
    .dropdown-item:hover {
        background: rgba(0,0,0,0.05);
    }
    
    .markdown-view {
        display: flex;
        flex-direction: column;
        flex: 1;
        overflow: hidden;
    }
    
    .markdown-header {
        padding: 1rem;
        border-bottom: 1px solid rgba(0,0,0,0.08);
        display: flex;
        justify-content: flex-end;
    }
    
    .download-btn {
        border: none;
        padding: 8px 16px;
        border-radius: 6px;
        font-size: 0.875rem;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }
    
    .markdown-content {
        flex: 1;
        overflow: auto;
        padding: 1rem;
        font-family: 'JetBrains Mono', monospace;
        white-space: pre-wrap;
        line-height: 1.6;
        font-size: 0.875rem;
    }
    
    /* Mobile specific styles */
    @media (max-width: 768px) {
        .header {
            padding: 0.75rem;
        }
        
        .header h1 {
            font-size: 0.875rem;
        }
        
        .control-btn {
            width: 32px;
            height: 32px;
            font-size: 0.875rem;
        }
        
        .action-btn span {
            display: none;
        }
        
        .node-text {
            font-size: 0.875rem;
        }
        
        .main-input {
            font-size: 0.875rem;
        }
        
        .input-prompt {
            font-size: 1.125rem;
        }
    }
</style>

</head>
<body>
    <div id="root"></div>

<script type="text/babel">
    const { useState, useEffect, useRef } = React;

    // Theme definitions
    const themes = {
        matcha: {
            name: 'Matcha',
            background: '#e9f5e9',
            text: '#2e4a2e',
            prompt: '#59784a',
            border: '#c4d6c4',
            levelColors: ['#f0f8f0', '#ddf2dd', '#ccedcc', '#bae8ba', '#a9e3a9']
        },
        latte: {
            name: 'Latte',
            background: '#f5f0e9',
            text: '#4a3e2e',
            prompt: '#7a6b59',
            border: '#d6ccc4',
            levelColors: ['#f8f5f0', '#edebdd', '#e3dccc', '#d9cfba', '#cfc2a9']
        },
        ocean: {
            name: 'Ocean',
            background: '#e9f0f5',
            text: '#2e3e4a',
            prompt: '#596b7a',
            border: '#c4ccd6',
            levelColors: ['#f0f5f8', '#ddebf2', '#ccddec', '#bacfe8', '#a9c2e3']
        },
        midnight: {
            name: 'Midnight',
            background: '#0f0f24',
            text: '#e1e1e1',
            prompt: '#8c8c8c',
            border: '#2e2e45',
            levelColors: ['#1a1a2e', '#24243a', '#2e2e42', '#38384e', '#424256']
        },
        chess: {
            name: 'Chess',
            background: '#f7f7f7',
            text: '#1a1a1a',
            prompt: '#666666',
            border: '#e1e1e1',
            levelColors: ['#ffffff', '#f5f5f5', '#ebebeb', '#e1e1e1', '#d7d7d7']
        },
        espresso: {
            name: 'Espresso',
            background: '#2b1710',
            text: '#e8d7c4',
            prompt: '#b89470',
            border: '#5c3d29',
            levelColors: ['#3d241a', '#4d2e21', '#5c3829', '#6b4230', '#7a4c37']
        },
        alienGuts: {
            name: 'Alien Guts',
            background: '#141f14',
            text: '#d9f2bf',
            prompt: '#99cc80',
            border: '#66994d',
            levelColors: ['#33cc4d', '#9933cc', '#cc9933', '#3399cc', '#cc3366']
        },
        neon: {
            name: 'Neon',
            background: '#0d0d26',
            text: '#1a1a1a',
            prompt: '#cccccc',
            border: '#666699',
            levelColors: ['#ff3399', '#33ff99', '#ff9933', '#9933ff', '#33b3ff']
        }
    };

    // Utility functions
    const generateId = () => Date.now().toString(36) + Math.random().toString(36).substr(2);

    const getColorForLevel = (theme, level) => {
        if (level < theme.levelColors.length) {
            return theme.levelColors[level];
        } else {
            const baseColorIndex = level % theme.levelColors.length;
            return theme.levelColors[baseColorIndex] + '80';
        }
    };

    // Storage utilities
    const saveToStorage = (trees) => {
        try {
            localStorage.setItem('tree-e-trees', JSON.stringify(trees));
        } catch (error) {
            console.error('Failed to save trees:', error);
        }
    };

    const loadFromStorage = () => {
        try {
            const saved = localStorage.getItem('tree-e-trees');
            if (saved) {
                return JSON.parse(saved);
            }
            
            // Migration from old format
            const oldNodes = localStorage.getItem('tree-e-nodes');
            if (oldNodes) {
                return [{
                    id: 'main',
                    title: 'Main Tree',
                    nodes: JSON.parse(oldNodes),
                    parentTreeId: null,
                    parentNodeId: null,
                    breadcrumb: []
                }];
            }
            
            return [{
                id: 'main',
                title: 'Main Tree',
                nodes: [],
                parentTreeId: null,
                parentNodeId: null,
                breadcrumb: []
            }];
        } catch (error) {
            console.error('Failed to load trees:', error);
            return [{
                id: 'main',
                title: 'Main Tree',
                nodes: [],
                parentTreeId: null,
                parentNodeId: null,
                breadcrumb: []
            }];
        }
    };

    const saveThemeToStorage = (themeName) => {
        try {
            localStorage.setItem('tree-e-theme', themeName);
        } catch (error) {
            console.error('Failed to save theme:', error);
        }
    };

    const loadThemeFromStorage = () => {
        try {
            return localStorage.getItem('tree-e-theme') || 'matcha';
        } catch (error) {
            console.error('Failed to load theme:', error);
            return 'matcha';
        }
    };

    // Touch handling
    const useTouchHandler = (onSwipeLeft, onSwipeRight, threshold = 50) => {
        const touchStart = useRef(null);
        const touchEnd = useRef(null);

        return {
            onTouchStart: (e) => {
                touchEnd.current = null;
                touchStart.current = e.targetTouches[0].clientX;
            },
            onTouchMove: (e) => {
                touchEnd.current = e.targetTouches[0].clientX;
            },
            onTouchEnd: () => {
                if (!touchStart.current || !touchEnd.current) return;
                
                const distance = touchStart.current - touchEnd.current;
                if (distance > threshold && onSwipeLeft) onSwipeLeft();
                if (distance < -threshold && onSwipeRight) onSwipeRight();
            }
        };
    };

    // Components
    const Modal = ({ isOpen, onClose, title, children, theme }) => {
        if (!isOpen) return null;

        return (
            <div className="modal" onClick={onClose}>
                <div 
                    className="modal-content" 
                    style={{ backgroundColor: theme.background, color: theme.text }}
                    onClick={(e) => e.stopPropagation()}
                >
                    <div className="modal-header" style={{ borderColor: theme.border }}>
                        <h3 className="modal-title">{title}</h3>
                        <button className="modal-close" onClick={onClose} style={{ color: theme.text }}>
                            ╳
                        </button>
                    </div>
                    <div className="modal-body">
                        {children}
                    </div>
                </div>
            </div>
        );
    };

    const ThemeDropdown = ({ currentTheme, onThemeChange, isOpen, onToggle, theme }) => (
        <div className="dropdown">
            <button 
                className="control-btn"
                onClick={onToggle}
                style={{
                    backgroundColor: getColorForLevel(theme, 0),
                    borderColor: theme.border,
                    color: theme.text
                }}
            >
                ◐
            </button>
            {isOpen && (
                <div className="dropdown-content">
                    {Object.entries(themes).map(([key, themeOption]) => (
                        <button
                            key={key}
                            className="dropdown-item"
                            onClick={() => {
                                onThemeChange(key);
                                onToggle();
                            }}
                        >
                            <span>{themeOption.name}</span>
                            {currentTheme === key && <span>●</span>}
                        </button>
                    ))}
                </div>
            )}
        </div>
    );

    const FilterDropdown = ({ currentFilter, onFilterChange, isOpen, onToggle, theme, filterOptions }) => (
        <div className="dropdown">
            <button 
                className="control-btn"
                onClick={onToggle}
                style={{
                    backgroundColor: currentFilter !== 'all' ? theme.text : getColorForLevel(theme, 0),
                    borderColor: theme.border,
                    color: currentFilter !== 'all' ? theme.background : theme.text
                }}
            >
                ◈
            </button>
            {isOpen && (
                <div className="dropdown-content">
                    {filterOptions.map((option) => (
                        <button
                            key={option.key}
                            className="dropdown-item"
                            onClick={() => {
                                onFilterChange(option.key);
                                onToggle();
                            }}
                        >
                            <span style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                <span>{option.icon}</span>
                                <span>{option.label}</span>
                            </span>
                            {currentFilter === option.key && <span>●</span>}
                        </button>
                    ))}
                </div>
            )}
        </div>
    );

    const NodeComponent = ({ node, theme, isSelected, isEditing, editText, onEditTextChange, trees, currentTreeId, onTap, onIndent, onOutdent, onDelete, onFocus, onToggleTask, onToggleComplete, onBranchOut, onEdit, onSaveEdit, onCancelEdit, onJumpToBranch }) => {
        const editInputRef = useRef(null);
        const isBranchedOut = trees.some(tree => tree.parentNodeId === node.id);
        
        const swipeHandlers = useTouchHandler(onOutdent, onIndent);

        useEffect(() => {
            if (isEditing && editInputRef.current) {
                editInputRef.current.focus();
                editInputRef.current.select();
            }
        }, [isEditing]);

        const handleKeyPress = (e) => {
            if (e.key === 'Enter') {
                onSaveEdit();
            } else if (e.key === 'Escape') {
                onCancelEdit();
            }
        };

        return (
            <div className="node">
                <div className="node-indent">
                    {Array.from({ length: node.level }, (_, i) => (
                        <div key={i} className="indent-space" />
                    ))}
                </div>
                
                <div className="node-content-wrapper">
                    <div 
                        className={`node-content ${isSelected ? 'selected' : ''} ${node.isTask && node.isCompleted ? 'completed' : ''}`}
                        style={{
                            backgroundColor: isSelected ? theme.border : getColorForLevel(theme, node.level),
                            borderColor: isSelected ? theme.text : theme.border,
                            color: theme.text,
                            opacity: isBranchedOut && !isEditing ? 0.7 : 1
                        }}
                        onClick={(e) => !isEditing && onTap(e)}
                        {...(!isEditing ? swipeHandlers : {})}
                    >
                        {node.isTask && (
                            <div 
                                className="task-toggle" 
                                onClick={(e) => {
                                    e.stopPropagation();
                                    if (!isEditing) onToggleComplete();
                                }}
                                style={{ color: node.isCompleted ? '#22c55e' : theme.text + '99' }}
                            >
                                {node.isCompleted ? '☑' : '☐'}
                            </div>
                        )}
                        
                        {isEditing ? (
                            <input
                                ref={editInputRef}
                                className="node-edit-input"
                                type="text"
                                value={editText}
                                onChange={(e) => onEditTextChange(e.target.value)}
                                onKeyDown={handleKeyPress}
                                onBlur={onSaveEdit}
                                style={{ color: theme.text }}
                                onClick={(e) => e.stopPropagation()}
                            />
                        ) : (
                            <div className={`node-text ${node.isTask && node.isCompleted ? 'completed' : ''}`}>
                                {node.content}
                            </div>
                        )}
                        
                        {!isEditing && (
                            <div className="node-icons" style={{ color: theme.text }}>
                                {node.isTask && <span>□</span>}
                                {node.note && node.note.trim() && <span>◊</span>}
                                {isBranchedOut && (
                                    <span 
                                        className="branch-link"
                                        onClick={(e) => {
                                            e.stopPropagation();
                                            onJumpToBranch();
                                        }}
                                        title="Jump to branched tree"
                                    >
                                        ⫷
                                    </span>
                                )}
                            </div>
                        )}
                    </div>
                    
                    {isSelected && !isEditing && (
                        <div className="node-actions">
                            {!isBranchedOut && (
                                <button className="action-btn edit" onClick={onEdit}>
                                    ✎ <span>Edit</span>
                                </button>
                            )}
                            <button className="action-btn task" onClick={onToggleTask}>
                                □ <span>{node.isTask ? 'Note' : 'Task'}</span>
                            </button>
                            <button className="action-btn focus" onClick={onFocus}>
                                ◊ <span>Notes</span>
                            </button>
                            <button 
                                className="action-btn branch" 
                                onClick={onBranchOut} 
                                disabled={trees.length >= 5 || isBranchedOut}
                                style={{ 
                                    opacity: (trees.length >= 5 || isBranchedOut) ? 0.5 : 1,
                                    cursor: (trees.length >= 5 || isBranchedOut) ? 'not-allowed' : 'pointer'
                                }}
                                title={
                                    isBranchedOut ? 'Node already branched out' :
                                    trees.length >= 5 ? 'Maximum 5 trees allowed' : 
                                    'Branch out to explore this thought'
                                }
                            >
                                ⫷ <span>Branch</span>
                            </button>
                            <button className="action-btn delete" onClick={onDelete}>
                                ╳ <span>Delete</span>
                            </button>
                        </div>
                    )}
                    
                    {isEditing && (
                        <div className="node-actions">
                            <button className="action-btn save" onClick={onSaveEdit}>
                                ✓ <span>Save</span>
                            </button>
                            <button className="action-btn cancel" onClick={onCancelEdit}>
                                ✕ <span>Cancel</span>
                            </button>
                        </div>
                    )}
                </div>
            </div>
        );
    };

    // Main App Component
    const TreeApp = () => {
        // Core State
        const [trees, setTrees] = useState([]);
        const [activeTreeId, setActiveTreeId] = useState('main');
        const [selectedNodeId, setSelectedNodeId] = useState(null);
        
        // UI State
        const [ui, setUi] = useState({
            currentInput: '',
            indentLevel: 0,
            editingNodeId: null,
            editText: '',
            currentTheme: 'matcha',
            currentFilter: 'all',
            showAbout: false,
            showThemeDropdown: false,
            showFilterDropdown: false,
            showMarkdownView: false,
            showClearConfirm: false,
            focusedNode: null
        });

        const inputRef = useRef(null);
        const theme = themes[ui.currentTheme];

        // Helper functions
        const getActiveTree = () => trees.find(tree => tree.id === activeTreeId) || trees[0];
        const getActiveTreeIndex = () => trees.findIndex(tree => tree.id === activeTreeId);

        const updateUi = (updates) => setUi(prev => ({ ...prev, ...updates }));

        const updateActiveTree = (updater) => {
            setTrees(prev => prev.map(tree => 
                tree.id === activeTreeId 
                    ? { ...tree, nodes: typeof updater === 'function' ? updater(tree.nodes) : updater }
                    : tree
            ));
        };

        const setActiveTree = (treeId) => {
            setActiveTreeId(treeId);
            setSelectedNodeId(null);
            updateUi({ indentLevel: 0 });
        };

        const getFilteredNodes = (nodes = null) => {
            const targetNodes = nodes || getActiveTree()?.nodes || [];
            switch (ui.currentFilter) {
                case 'tasks': return targetNodes.filter(node => node.isTask);
                case 'notes': return targetNodes.filter(node => node.note && node.note.trim());
                case 'branched': return targetNodes.filter(node => trees.some(tree => tree.parentNodeId === node.id));
                default: return targetNodes;
            }
        };

        // Load/Save
        useEffect(() => {
            const loadedTrees = loadFromStorage();
            setTrees(loadedTrees);
            updateUi({ currentTheme: loadThemeFromStorage() });
            
            setTimeout(() => {
                if (inputRef.current) {
                    inputRef.current.focus();
                }
            }, 100);
        }, []);

        useEffect(() => {
            if (trees.length > 0) {
                saveToStorage(trees);
            }
        }, [trees]);

        useEffect(() => {
            saveThemeToStorage(ui.currentTheme);
        }, [ui.currentTheme]);

        // Touch handlers for input
        const inputSwipeHandlers = useTouchHandler(
            () => updateUi({ indentLevel: Math.max(0, ui.indentLevel - 1) }),
            () => updateUi({ indentLevel: ui.indentLevel + 1 })
        );

        // Node operations
        const addNode = () => {
            const content = ui.currentInput.trim();
            if (!content) return;

            const activeTree = getActiveTree();
            if (!activeTree) return;

            const nodes = activeTree.nodes;
            let insertIndex = nodes.length;
            let newLevel = ui.indentLevel;

            if (selectedNodeId) {
                const selectedNode = nodes.find(node => node.id === selectedNodeId);
                const selectedIndex = nodes.findIndex(node => node.id === selectedNodeId);
                
                if (selectedNode && selectedIndex !== -1) {
                    newLevel = selectedNode.level + 1;
                    
                    let insertAfterIndex = selectedIndex;
                    for (let i = selectedIndex + 1; i < nodes.length; i++) {
                        if (nodes[i].level > selectedNode.level) {
                            insertAfterIndex = i;
                        } else {
                            break;
                        }
                    }
                    insertIndex = insertAfterIndex + 1;
                }
            }

            const newNode = {
                id: generateId(),
                content,
                level: newLevel,
                note: '',
                isTask: false,
                isCompleted: false
            };

            updateActiveTree(prevNodes => {
                const newNodes = [...prevNodes];
                newNodes.splice(insertIndex, 0, newNode);
                return newNodes;
            });
            
            updateUi({ currentInput: '', indentLevel: newLevel });
        };

        const selectNode = (nodeId) => {
            if (selectedNodeId === nodeId) {
                // Deselect
                setSelectedNodeId(null);
                const activeTree = getActiveTree();
                if (activeTree?.nodes.length > 0) {
                    updateUi({ indentLevel: activeTree.nodes[activeTree.nodes.length - 1].level });
                } else {
                    updateUi({ indentLevel: 0 });
                }
            } else {
                // Select
                setSelectedNodeId(nodeId);
                const activeTree = getActiveTree();
                const node = activeTree?.nodes.find(n => n.id === nodeId);
                if (node) {
                    updateUi({ indentLevel: node.level + 1 });
                }
            }
        };

        const deleteNode = (nodeId) => {
            updateActiveTree(prevNodes => prevNodes.filter(node => node.id !== nodeId));
            if (selectedNodeId === nodeId) {
                setSelectedNodeId(null);
            }
        };

        const indentNode = (nodeId) => {
            updateActiveTree(prevNodes => prevNodes.map(node =>
                node.id === nodeId ? { ...node, level: node.level + 1 } : node
            ));
            setSelectedNodeId(null);
        };

        const outdentNode = (nodeId) => {
            updateActiveTree(prevNodes => prevNodes.map(node =>
                node.id === nodeId ? { ...node, level: Math.max(0, node.level - 1) } : node
            ));
            setSelectedNodeId(null);
        };

        const toggleTask = (nodeId) => {
            updateActiveTree(prevNodes => prevNodes.map(node =>
                node.id === nodeId ? { ...node, isTask: !node.isTask, isCompleted: false } : node
            ));
            setSelectedNodeId(null);
        };

        const toggleComplete = (nodeId) => {
            updateActiveTree(prevNodes => prevNodes.map(node =>
                node.id === nodeId ? { ...node, isCompleted: !node.isCompleted } : node
            ));
        };

        const editNode = (nodeId) => {
            // Check if branched out
            const isBranchedOut = trees.some(tree => tree.parentNodeId === nodeId);
            if (isBranchedOut) return;
            
            const activeTree = getActiveTree();
            const node = activeTree?.nodes.find(n => n.id === nodeId);
            if (node) {
                updateUi({ editingNodeId: nodeId, editText: node.content });
                setSelectedNodeId(null);
            }
        };

        const saveEdit = () => {
            const trimmedText = ui.editText.trim();
            if (trimmedText && ui.editingNodeId) {
                updateActiveTree(prevNodes => prevNodes.map(node =>
                    node.id === ui.editingNodeId ? { ...node, content: trimmedText } : node
                ));
            }
            updateUi({ editingNodeId: null, editText: '' });
        };

        const cancelEdit = () => {
            updateUi({ editingNodeId: null, editText: '' });
        };

        const focusNode = (nodeId) => {
            const activeTree = getActiveTree();
            const node = activeTree?.nodes.find(n => n.id === nodeId);
            if (node) {
                updateUi({ focusedNode: node });
            }
            setSelectedNodeId(null);
        };

        const saveFocusNote = (note) => {
            if (ui.focusedNode) {
                updateActiveTree(prevNodes => prevNodes.map(node =>
                    node.id === ui.focusedNode.id ? { ...node, note } : node
                ));
            }
            updateUi({ focusedNode: null });
        };

        // Branch operations
        const branchOut = (nodeId) => {
            const activeTree = getActiveTree();
            if (!activeTree || trees.length >= 5) return;

            const selectedNode = activeTree.nodes.find(node => node.id === nodeId);
            if (!selectedNode) return;

            const nodeAndChildren = [];
            let foundParent = false;
            
            for (const node of activeTree.nodes) {
                if (node.id === selectedNode.id) {
                    foundParent = true;
                    nodeAndChildren.push({ ...node, level: 0 });
                } else if (foundParent && node.level > selectedNode.level) {
                    nodeAndChildren.push({ ...node, level: node.level - selectedNode.level });
                } else if (foundParent && node.level <= selectedNode.level) {
                    break;
                }
            }

            const truncatedTitle = selectedNode.content.length > 20 
                ? selectedNode.content.substring(0, 17) + '...'
                : selectedNode.content;

            const newBreadcrumb = [];
            if (activeTree.id !== 'main') {
                newBreadcrumb.push(...activeTree.breadcrumb, activeTree.title);
            }
            
            if (newBreadcrumb.length > 3) {
                newBreadcrumb.splice(1, newBreadcrumb.length - 3);
                newBreadcrumb[1] = '...';
            }

            const newTree = {
                id: generateId(),
                title: truncatedTitle,
                nodes: nodeAndChildren,
                parentTreeId: activeTree.id,
                parentNodeId: selectedNode.id,
                breadcrumb: newBreadcrumb
            };

            setTrees(prev => [...prev, newTree]);
            setActiveTree(newTree.id);
            setSelectedNodeId(null);
            updateUi({ indentLevel: 0 });
        };

        const closeTree = () => {
            const activeTree = getActiveTree();
            if (!activeTree || !activeTree.parentTreeId) return;

            const parentTree = trees.find(tree => tree.id === activeTree.parentTreeId);
            if (!parentTree) return;

            // Merge changes back
            setTrees(prev => {
                const newTrees = [...prev];
                const parentIndex = newTrees.findIndex(tree => tree.id === activeTree.parentTreeId);
                const parentNodes = [...newTrees[parentIndex].nodes];
                
                const originalNodeIndex = parentNodes.findIndex(node => node.id === activeTree.parentNodeId);
                if (originalNodeIndex === -1) return newTrees;

                const originalNode = parentNodes[originalNodeIndex];
                
                // Remove old children
                let removeUntilIndex = parentNodes.length;
                for (let i = originalNodeIndex + 1; i < parentNodes.length; i++) {
                    if (parentNodes[i].level <= originalNode.level) {
                        removeUntilIndex = i;
                        break;
                    }
                }
                
                // Replace with updated nodes
                const updatedNodes = activeTree.nodes.map(node => ({
                    ...node,
                    level: node.level + originalNode.level
                }));

                parentNodes.splice(originalNodeIndex, removeUntilIndex - originalNodeIndex, ...updatedNodes);
                newTrees[parentIndex] = { ...newTrees[parentIndex], nodes: parentNodes };

                // Remove the closed tree
                const activeTreeIndex = newTrees.findIndex(tree => tree.id === activeTreeId);
                newTrees.splice(activeTreeIndex, 1);

                return newTrees;
            });

            setActiveTree(activeTree.parentTreeId);
        };

        const jumpToBranch = (nodeId) => {
            const branchedTree = trees.find(tree => tree.parentNodeId === nodeId);
            if (branchedTree) {
                setActiveTree(branchedTree.id);
            }
        };

        // Export/Import
        const generateMarkdown = () => {
            return trees.map((tree) => {
                const nodesToUse = ui.currentFilter !== 'all' ? getFilteredNodes(tree.nodes) : tree.nodes;
                
                let treeMarkdown = tree.id === 'main' ? `# ${tree.title}` : `## ${tree.title}`;
                if (tree.breadcrumb.length > 0) {
                    treeMarkdown += ` (Branch from: ${tree.breadcrumb.join(' > ')})`;
                }
                treeMarkdown += '\n\n';
                
                const nodeMarkdown = nodesToUse.map(node => {
                    const indent = '  '.repeat(node.level);
                    let content;
                    
                    if (node.isTask) {
                        const taskSymbol = node.isCompleted ? '- [x]' : '- [ ]';
                        content = `${indent}${taskSymbol} ${node.content}`;
                    } else {
                        content = `${indent}- ${node.content}`;
                    }
                    
                    const isBranchedOut = trees.some(otherTree => otherTree.parentNodeId === node.id);
                    if (isBranchedOut) {
                        const branchedTree = trees.find(otherTree => otherTree.parentNodeId === node.id);
                        if (branchedTree) {
                            content += ` → branched to: ${branchedTree.title}`;
                        }
                    }
                    
                    if (node.note && node.note.trim()) {
                        const noteLines = node.note.split('\n');
                        const indentedNote = noteLines.map(line => `${indent}  > ${line}`).join('\n');
                        content += '\n' + indentedNote;
                    }
                    
                    return content;
                }).join('\n');
                
                return treeMarkdown + (nodeMarkdown || '*Empty tree*');
            }).join('\n\n---\n\n');
        };

        const exportMarkdown = () => {
            const markdown = generateMarkdown();
            const blob = new Blob([markdown], { type: 'text/markdown' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            const filterSuffix = ui.currentFilter !== 'all' ? `-${ui.currentFilter}` : '';
            a.download = `tree-e-export${filterSuffix}.md`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        };

        const clearAll = () => {
            setTrees([{
                id: 'main',
                title: 'Main Tree',
                nodes: [],
                parentTreeId: null,
                parentNodeId: null,
                breadcrumb: []
            }]);
            setActiveTreeId('main');
            setSelectedNodeId(null);
            updateUi({ 
                indentLevel: 0,
                showClearConfirm: false
            });
        };

        // Event handlers
        const handleBackgroundClick = (e) => {
            if (e.target.classList.contains('app') || 
                e.target.classList.contains('main-content') || 
                e.target.classList.contains('tree-container') ||
                e.target.classList.contains('nodes-list')) {
                
                setSelectedNodeId(null);
                updateUi({ 
                    showThemeDropdown: false,
                    showFilterDropdown: false,
                    editingNodeId: null,
                    editText: ''
                });
                
                const activeTree = getActiveTree();
                if (activeTree?.nodes.length > 0) {
                    updateUi({ indentLevel: activeTree.nodes[activeTree.nodes.length - 1].level });
                } else {
                    updateUi({ indentLevel: 0 });
                }
            }
        };

        // Derived state
        const activeTree = getActiveTree();
        const currentNodes = activeTree?.nodes || [];
        const filteredNodes = getFilteredNodes();
        const selectedNode = selectedNodeId ? currentNodes.find(node => node.id === selectedNodeId) : null;
        
        const filterOptions = [
            { key: 'all', label: 'All Nodes', icon: '◎' },
            { key: 'tasks', label: 'Tasks', icon: '□' },
            { key: 'notes', label: 'With Notes', icon: '◊' },
            { key: 'branched', label: 'Branched', icon: '⫷' }
        ];

        return (
            <div 
                className="app" 
                style={{ 
                    backgroundColor: theme.background,
                    color: theme.text 
                }}
                onClick={handleBackgroundClick}
            >
                {/* Header */}
                <div className="header" style={{ backgroundColor: theme.background, borderColor: theme.border }}>
                    <div className="header-main">
                        <div className="header-title">
                            <h1 style={{ color: theme.text }}>Tree-e</h1>
                            
                            {ui.currentFilter !== 'all' && (
                                <span className="badge" style={{ 
                                    color: theme.text + '99',
                                    background: theme.border
                                }}>
                                    {filterOptions.find(f => f.key === ui.currentFilter)?.icon}
                                    {filterOptions.find(f => f.key === ui.currentFilter)?.label}
                                </span>
                            )}
                            
                            {trees.length > 1 && (
                                <span className="badge" style={{ 
                                    color: trees.length >= 5 ? 'white' : theme.text + '99',
                                    background: trees.length >= 5 ? '#ef4444' : theme.border
                                }}>
                                    {trees.length}/5 trees
                                </span>
                            )}
                        </div>
                        
                        <div className="header-controls">
                            {trees.length > 1 && (
                                <div className="tree-nav">
                                    <button
                                        className="nav-btn"
                                        onClick={() => {
                                            const currentIndex = getActiveTreeIndex();
                                            const prevIndex = currentIndex > 0 ? currentIndex - 1 : trees.length - 1;
                                            setActiveTree(trees[prevIndex].id);
                                        }}
                                        style={{
                                            borderColor: theme.border,
                                            color: theme.text
                                        }}
                                    >
                                        ‹
                                    </button>
                                    <span className="nav-counter" style={{ color: theme.text }}>
                                        {getActiveTreeIndex() + 1}/{trees.length}
                                    </span>
                                    <button
                                        className="nav-btn"
                                        onClick={() => {
                                            const currentIndex = getActiveTreeIndex();
                                            const nextIndex = currentIndex < trees.length - 1 ? currentIndex + 1 : 0;
                                            setActiveTree(trees[nextIndex].id);
                                        }}
                                        style={{
                                            borderColor: theme.border,
                                            color: theme.text
                                        }}
                                    >
                                        ›
                                    </button>
                                </div>
                            )}
                            
                            <FilterDropdown
                                currentFilter={ui.currentFilter}
                                onFilterChange={(filter) => updateUi({ currentFilter: filter })}
                                isOpen={ui.showFilterDropdown}
                                onToggle={(e) => {
                                    if (e) e.stopPropagation();
                                    updateUi({ showFilterDropdown: !ui.showFilterDropdown, showThemeDropdown: false });
                                }}
                                theme={theme}
                                filterOptions={filterOptions}
                            />
                            
                            <button
                                className="control-btn"
                                onClick={(e) => {
                                    e.stopPropagation();
                                    updateUi({ showAbout: true });
                                }}
                                style={{
                                    backgroundColor: getColorForLevel(theme, 0),
                                    borderColor: theme.border,
                                    color: theme.text
                                }}
                            >
                                ◯
                            </button>
                            
                            <button
                                className="control-btn"
                                onClick={(e) => {
                                    e.stopPropagation();
                                    updateUi({ showMarkdownView: !ui.showMarkdownView });
                                }}
                                disabled={trees.length === 0 || trees.every(tree => tree.nodes.length === 0)}
                                style={{
                                    backgroundColor: ui.showMarkdownView ? theme.text : getColorForLevel(theme, 0),
                                    borderColor: theme.border,
                                    color: ui.showMarkdownView ? theme.background : theme.text
                                }}
                            >
                                {ui.showMarkdownView ? '◀' : '▶'}
                            </button>
                            
                            <button
                                className="control-btn"
                                onClick={(e) => {
                                    e.stopPropagation();
                                    if (trees.length > 0 && trees.some(tree => tree.nodes.length > 0)) {
                                        updateUi({ showClearConfirm: true });
                                    }
                                }}
                                disabled={trees.length === 0 || trees.every(tree => tree.nodes.length === 0)}
                                style={{
                                    backgroundColor: getColorForLevel(theme, 0),
                                    borderColor: theme.border,
                                    color: theme.text
                                }}
                            >
                                ╳
                            </button>
                            
                            <ThemeDropdown
                                currentTheme={ui.currentTheme}
                                onThemeChange={(themeName) => updateUi({ currentTheme: themeName })}
                                isOpen={ui.showThemeDropdown}
                                onToggle={(e) => {
                                    if (e) e.stopPropagation();
                                    updateUi({ showThemeDropdown: !ui.showThemeDropdown, showFilterDropdown: false });
                                }}
                                theme={theme}
                            />
                        </div>
                    </div>
                    
                    {/* Breadcrumbs - Pure Hierarchy */}
                    {activeTree?.id !== 'main' && (
                        <div className="breadcrumbs" style={{ color: theme.text }}>
                            <button
                                className="breadcrumb-btn"
                                onClick={() => setActiveTree('main')}
                                style={{ color: theme.text + '99' }}
                            >
                                Main Tree
                            </button>
                            
                            {activeTree?.breadcrumb?.map((crumb, index) => (
                                <React.Fragment key={index}>
                                    <span className="breadcrumb-sep"> > </span>
                                    <span style={{ color: theme.text + '99' }}>{crumb}</span>
                                </React.Fragment>
                            ))}
                            
                            <span className="breadcrumb-sep"> > </span>
                            <span className="breadcrumb-current" style={{ color: theme.text }}>
                                {activeTree?.title}
                            </span>
                            
                            <button
                                className="close-btn"
                                onClick={closeTree}
                                title="Close tree and merge changes back"
                            >
                                ✓ Close
                            </button>
                        </div>
                    )}
                </div>

                {/* Main Content */}
                {ui.showMarkdownView ? (
                    <div className="markdown-view">
                        <div className="markdown-header" style={{ borderColor: theme.border }}>
                            <button
                                className="download-btn"
                                onClick={exportMarkdown}
                                style={{
                                    background: theme.text,
                                    color: theme.background
                                }}
                            >
                                ↓ Download MD
                            </button>
                        </div>
                        <div className="markdown-content" style={{ color: theme.text }}>
                            {generateMarkdown() || 'No content to display'}
                        </div>
                    </div>
                ) : (
                    <div className="main-content">
                        <div className="tree-container">
                            <div className="nodes-list">
                                {filteredNodes.length === 0 && currentNodes.length > 0 && ui.currentFilter !== 'all' ? (
                                    <div className="empty-state">
                                        <div className="empty-icon">{filterOptions.find(f => f.key === ui.currentFilter)?.icon}</div>
                                        <div className="empty-title">No {filterOptions.find(f => f.key === ui.currentFilter)?.label.toLowerCase()} found</div>
                                        <div className="empty-desc">
                                            Try a different filter or add some {ui.currentFilter === 'tasks' ? 'task nodes' : ui.currentFilter === 'notes' ? 'notes to your nodes' : 'branched nodes'}.
                                        </div>
                                    </div>
                                ) : filteredNodes.length === 0 ? (
                                    <div className="empty-state">
                                        <div className="empty-icon">🌱</div>
                                        <div className="empty-title">Empty tree</div>
                                        <div className="empty-desc">
                                            {activeTree?.id === 'main' ? 'Start your Tree-e by adding your first thought below.' : 'This branch is ready for new ideas.'}
                                        </div>
                                    </div>
                                ) : (
                                    filteredNodes.map(node => (
                                        <NodeComponent
                                            key={node.id}
                                            node={node}
                                            theme={theme}
                                            isSelected={selectedNodeId === node.id}
                                            isEditing={ui.editingNodeId === node.id}
                                            editText={ui.editText}
                                            onEditTextChange={(text) => updateUi({ editText: text })}
                                            trees={trees}
                                            currentTreeId={activeTreeId}
                                            onTap={(e) => {
                                                e.stopPropagation();
                                                selectNode(node.id);
                                            }}
                                            onIndent={() => indentNode(node.id)}
                                            onOutdent={() => outdentNode(node.id)}
                                            onDelete={() => deleteNode(node.id)}
                                            onFocus={() => focusNode(node.id)}
                                            onToggleTask={() => toggleTask(node.id)}
                                            onToggleComplete={() => toggleComplete(node.id)}
                                            onBranchOut={() => branchOut(node.id)}
                                            onEdit={() => editNode(node.id)}
                                            onSaveEdit={saveEdit}
                                            onCancelEdit={cancelEdit}
                                            onJumpToBranch={() => jumpToBranch(node.id)}
                                        />
                                    ))
                                )}
                            </div>
                        </div>
                    </div>
                )}

                {/* Input Area */}
                {!ui.showMarkdownView && (
                    <div className="input-area" style={{ backgroundColor: theme.background, borderColor: theme.border }}>
                        <div 
                            className="input-container"
                            style={{
                                borderColor: theme.border,
                                backgroundColor: theme.background
                            }}
                            onClick={(e) => {
                                e.stopPropagation();
                                inputRef.current?.focus();
                            }}
                            {...inputSwipeHandlers}
                        >
                            <div className="input-prompt" style={{ color: theme.prompt }}>
                                >
                            </div>
                            
                            {ui.indentLevel > 0 && (
                                <div className="indent-indicator" style={{ color: theme.prompt }}>
                                    {'  │'.repeat(ui.indentLevel)}
                                </div>
                            )}
                            
                            <input
                                ref={inputRef}
                                className="main-input"
                                type="text"
                                value={ui.currentInput}
                                onChange={(e) => updateUi({ currentInput: e.target.value })}
                                onKeyDown={(e) => {
                                    if (e.key === 'Enter') {
                                        addNode();
                                    } else if (e.key === 'Tab') {
                                        e.preventDefault();
                                        if (e.shiftKey) {
                                            updateUi({ indentLevel: Math.max(0, ui.indentLevel - 1) });
                                        } else {
                                            updateUi({ indentLevel: ui.indentLevel + 1 });
                                        }
                                    }
                                }}
                                placeholder={
                                    activeTree 
                                        ? `> ${activeTree.id === 'main' ? 'Main Tree' : activeTree.title}${selectedNode ? `: ${selectedNode.content} (lvl ${selectedNode.level + 1})` : ''} / Swipe left or right here`
                                        : "> Start your Tree-e / Swipe left or right here"
                                }
                                style={{ color: theme.text }}
                            />
                        </div>
                        
                        {trees.length === 0 || (trees.length === 1 && currentNodes.length === 0) ? (
                            <div className="instructions" style={{ color: theme.text }}>
                                Tab to indent • Shift+Tab to outdent • Swipe on input box to adjust level • Return to add node • Branch to explore thoughts • Click breadcrumbs to navigate
                            </div>
                        ) : ui.currentFilter !== 'all' && (
                            <div className="instructions" style={{ color: theme.text }}>
                                Showing {filteredNodes.length} of {currentNodes.length} nodes • Filter: {filterOptions.find(f => f.key === ui.currentFilter)?.label}
                            </div>
                        )}
                    </div>
                )}

                {/* Modals */}
                <Modal
                    isOpen={ui.showAbout}
                    onClose={() => updateUi({ showAbout: false })}
                    title="About Tree-e"
                    theme={theme}
                >
                    <div style={{ display: 'flex', flexDirection: 'column', gap: '1rem' }}>
                        <div>
                            <h4 style={{ marginBottom: '0.5rem', fontSize: '1rem', fontWeight: '600' }}>The Philosophy</h4>
                            <p style={{ lineHeight: 1.6, opacity: 0.9, fontSize: '0.875rem' }}>
                                Tree-e embraces the power of simplicity and exploration. Like branches forming trees, individual thoughts combine to create complex ideas. Branch out to explore different paths and perspectives, creating a forest of interconnected knowledge.
                            </p>
                        </div>
                        
                        <div>
                            <h4 style={{ marginBottom: '0.5rem', fontSize: '1rem', fontWeight: '600' }}>Getting Started</h4>
                            <div style={{ fontFamily: 'JetBrains Mono, monospace', fontSize: '0.75rem', opacity: 0.9, lineHeight: 1.4 }}>
                                <div>• Start typing at the > prompt</div>
                                <div>• Tab to indent, Shift+Tab to outdent</div>
                                <div>• Swipe on input to adjust indent level</div>
                                <div>• Tap nodes to select and access actions</div>
                                <div>• Use Branch to explore thoughts in new trees</div>
                                <div>• Click breadcrumbs to navigate between trees</div>
                                <div>• Click "✓ Close" to merge changes back</div>
                                <div>• Export button shares all trees as Markdown</div>
                            </div>
                        </div>
                    </div>
                </Modal>
                
                <Modal
                    isOpen={!!ui.focusedNode}
                    onClose={() => updateUi({ focusedNode: null })}
                    title={`Notes: ${ui.focusedNode?.content || ''}`}
                    theme={theme}
                >
                    <textarea
                        className="note-editor"
                        value={ui.focusedNode?.note || ''}
                        onChange={(e) => updateUi({ 
                            focusedNode: { ...ui.focusedNode, note: e.target.value }
                        })}
                        placeholder="Add detailed notes for this node..."
                        style={{
                            backgroundColor: getColorForLevel(theme, 1),
                            borderColor: theme.border,
                            color: theme.text
                        }}
                    />
                    <div style={{ marginTop: '16px', display: 'flex', justifyContent: 'flex-end' }}>
                        <button
                            onClick={() => {
                                saveFocusNote(ui.focusedNode?.note || '');
                            }}
                            style={{
                                background: '#3b82f6',
                                color: 'white',
                                border: 'none',
                                padding: '8px 16px',
                                borderRadius: '6px',
                                cursor: 'pointer'
                            }}
                        >
                            Save & Close
                        </button>
                    </div>
                </Modal>

                <Modal 
                    isOpen={ui.showClearConfirm} 
                    onClose={() => updateUi({ showClearConfirm: false })} 
                    title={trees.length > 1 ? "Clear your entire forest?" : "Clear your garden?"} 
                    theme={theme}
                >
                    <div style={{ marginBottom: '16px' }}>
                        {trees.length > 1 ? 
                            "This will remove all your trees and every carefully cultivated thought. Your entire forest cannot be replanted once cleared." :
                            "This will remove all your carefully cultivated thoughts. They cannot be replanted once cleared."
                        }
                    </div>
                    <div style={{ display: 'flex', gap: '12px', justifyContent: 'flex-end' }}>
                        <button
                            onClick={() => updateUi({ showClearConfirm: false })}
                            style={{
                                background: theme.border,
                                color: theme.text,
                                border: 'none',
                                padding: '8px 16px',
                                borderRadius: '6px',
                                cursor: 'pointer'
                            }}
                        >
                            Cancel
                        </button>
                        <button
                            onClick={clearAll}
                            style={{
                                background: '#ef4444',
                                color: 'white',
                                border: 'none',
                                padding: '8px 16px',
                                borderRadius: '6px',
                                cursor: 'pointer'
                            }}
                        >
                            Clear All
                        </button>
                    </div>
                </Modal>
            </div>
        );
    };

    ReactDOM.render(<TreeApp />, document.getElementById('root'));

    // Service Worker
    if ('serviceWorker' in navigator) {
        const swCode = `
            const CACHE_NAME = 'tree-e-v2';
            const urlsToCache = ['/', '/index.html'];

            self.addEventListener('install', event => {
                event.waitUntil(
                    caches.open(CACHE_NAME)
                        .then(cache => cache.addAll(urlsToCache))
                );
            });

            self.addEventListener('fetch', event => {
                event.respondWith(
                    caches.match(event.request)
                        .then(response => {
                            if (response) {
                                return response;
                            }
                            return fetch(event.request);
                        })
                );
            });
        `;
        
        const blob = new Blob([swCode], { type: 'application/javascript' });
        const swUrl = URL.createObjectURL(blob);
        
        navigator.serviceWorker.register(swUrl)
            .then(registration => {
                console.log('SW registered: ', registration);
            })
            .catch(registrationError => {
                console.log('SW registration failed: ', registrationError);
            });
    }
</script>

</body>
</html>
