<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tree-e - Hierarchical Note Taking</title>

<!-- PWA Meta Tags -->

<meta name="description" content="Tree-e: Hierarchical note-taking app with beautiful themes">
<meta name="theme-color" content="#e9f5e9">
<link rel="icon" type="image/svg+xml" href="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgd2lkdGg9IjQwOTYiIGhlaWdodD0iNDA5NiIgdmlld0JveD0iMCAwIDQwOTYgNDA5NiI+PHJlY3Qgd2lkdGg9IjQwOTYiIGhlaWdodD0iNDA5NiIgZmlsbD0iI2U4ZTllNiIvPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDIwNDggMjA0OCkiPjxwYXRoIGQ9Ik00MDcuNTAxLDEzNTAuMDQgTDAsLTEzNTAuMDQgTC00MDcuNTAxLDEzNTAuMDQgTDQwNy41MDEsMTM1MC4wNCBaIiBmaWxsPSIjMzgyNDE4Ii8+PHBhdGggZD0iTS05LjA3NTIyZS0wNiwtOTQ1LjM2MiBDLTkuMDc1MjJlLTA2LC04MTUuNzA2IDEwNS44NjYsLTcwOS44NCAyMzUuNTIyLC03MDkuODQgTDk0MC45LC03MDkuODQgQzEwNzAuNTYsLTcwOS44NCAxMTc2LjQyLC04MTUuNzA2IDExNzYuNDIsLTk0NS4zNjIgQzExNzYuNDIsLTEwNzUuMDIgMTA3MC41NiwtMTE4MC44OCA5NDAuOSwtMTE4MC44OCBMMjM1LjUyMiwtMTE4MC44OCBDMTA1Ljg2NiwtMTE4MC44OCAtOS4wNzUyMmUtMDYsLTEwNzUuMDIgLTkuMDc1MjJlLTA2LC05NDUuMzYyIFoiIGZpbGw9IiM5YWJjNDUiLz48cGF0aCBkPSJNMTE3Ni40MiwtOTkuNTk1OSBDMTE3Ni40MiwzMC4wNjA0IDEwNzAuNTYsMTM1LjkyNiA5NDAuOSwxMzUuOTI2IEwyMzUuNTIyLDEzNS45MjYgQzEwNS44NjYsMTM1LjkyNiAtMy40MTA2MWUtMTMsMzAuMDYwNCAtMy40MTA2MWUtMTMsLTk5LjU5NTkgQy0zLjQxMDYxZS0xMywtMjI5LjI1MiAxMDUuODY2LC0zMzUuMTE4IDIzNS41MjIsLTMzNS4xMTggTDk0MC45LC0zMzUuMTE4IEMxMDcwLjU2LC0zMzUuMTE4IDExNzYuNDIsLTIyOS4yNTIgMTE3Ni40MiwtOTkuNTk1OSBaIiBmaWxsPSIjOWFiYzQ1Ii8+PHBhdGggZD0iTS0yLjI3Mzc0ZS0xMywtNTcwLjY0MSBDLTIuMjczNzRlLTEzLC00NDAuOTg0IC0xMDUuODY2LC0zMzUuMTE4IC0yMzUuNTIyLC0zMzUuMTE4IEwtOTQwLjksLTMzNS4xMTggQy0xMDcwLjU2LC0zMzUuMTE4IC0xMTc2LjQyLC00NDAuOTg0IC0xMTc2LjQyLC01NzAuNjQxIEMtMTE3Ni40MiwtNzAwLjI5NyAtMTA3MC41NiwtODA2LjE2MyAtOTQwLjksLTgwNi4xNjMgTC0yMzUuNTIyLC04MDYuMTYzIEMtMTA1Ljg2NiwtODA2LjE2MyAtMi4yNzM3NGUtMTMsLTcwMC4yOTcgLTIuMjczNzRlLTEzLC01NzAuNjQxIFoiIGZpbGw9IiNlMWY5YTQiLz48cGF0aCBkPSJNMCwzMjIuMjIxIEMwLDQ1MS44NzggLTEwNS44NjYsNTU3Ljc0NCAtMjM1LjUyMiw1NTcuNzQ0IEwtOTQwLjksNTU3Ljc0NCBDLTEwNzAuNTYsNTU3Ljc0NCAtMTE3Ni40Miw0NTEuODc4IC0xMTc2LjQyLDMyMi4yMjEgQy0xMTc2LjQyLDE5Mi41NjUgLTEwNzAuNTYsODYuNjk5IC05NDAuOSw4Ni42OTkgTC0yMzUuNTIyLDg2LjY5OSBDLTEwNS44NjYsODYuNjk5IDAsMTkyLjU2NSAwLDMyMi4yMjEgWiIgZmlsbD0iIzY0N2YyMSIvPjwvZz48L3N2Zz4=">
<link rel="manifest" href="data:application/json;base64,eyJuYW1lIjoiVHJlZS1lIiwic2hvcnRfbmFtZSI6IlRyZWUtZSIsImRpc3BsYXkiOiJzdGFuZGFsb25lIiwic3RhcnRfdXJsIjoiLyIsInRoZW1lX2NvbG9yIjoiI2U5ZjVlOSIsImJhY2tncm91bmRfY29sb3IiOiIjZTlmNWU5IiwiaWNvbnMiOlt7InNyYyI6ImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjJaWEp6YVc5dVBTSXhMakVpSUhodGJHNXpQU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh5TURBd0wzTjJaeUlnZDJsa2RHZzlJalF3T1RZaUlHaGxhV2RvZEQwaU5EQTVOaUlnZG1sbGQwSnZlRDBpTUNBd0lEUXdPVFlnTkRBNU5pSStQSEpsWTNRZ2QybGtkR2c5SWpRd09UWWlJR2hsYVdkb2REMGlOREE1TmlJZ1ptbHNiRDBpSTJVNFpUbGxOaUl2UGp4bklIUnlZVzV6Wm05eWJUMGlkSEpoYm5Oc1lYUmxLREkxTkRrZ01qVTBPQ2tpUGp4d1lYUm9JR1E5SWswME1EY3VOVEF4TERFek5UQXVNRFFnVERBc0xURXpOVEF1TURRZ1RDMDBNRGN1TlRBeExERXpOVEF1TkRRZ1REUXdOeTQxTURFc01UTTFNQzR3TkNCV2lGZGlhV3hzUFNJak16Z3lOREU0SWk4K1BIQmhkR2dnWkQwaVRTMDVMakEzTlRJeVpTMHdOaXd0T1RRMUXTTTJJRU10T1M0d056VXlNbVV0TURZC0xUZ3hOUzQzTURZZ01UQTFMamcyTml3dE56QTVMamcwSURJek5TNDFNaklzTFRjd09TNDRORXhPVUVKOU9RUXVPUkJRTWpRMUxqQXhNVHBqRkRZMUxqRTNOaklDTFRjeU1TNDBNak1nTXpjek5pNDVOVHh4VFRsR2VEQk1OUzB5TlNFUWp0ekxtbHNiRDBpSXprZ1ltTXpORlVpTHo0OGNHRjBhQ0JrUFNKTk1URTNOaTQwTWl3dE9UazFOVFE1SUVNeE1URTNOaTQwTWl3ek1DNDBNalJCUUUxd056VXVOall3TkRrZ01UUTFMREF5TmkxT1FEVTJMVEE0TVRjeU5qWWdNVE0xT1M0eU16WmhNVEkwTlM0MU1paXNMVGN3TWpRbU5IVXVPVkJEWWlKcE1UQXpNMEl0SWpGb2VEQWdMMDBpTFRjeU1TMDBNak1nTXpjNE5pNDVOUkJSVFRsR2VEQk1OUzB5TlNFUWp0ekxtbHNiRDBpSXprZ1ltTXpORlVpTHo0OGNHRjBhQ0JrUFNKTk1URTNOaTQwTWl3dE9UazFOVFE1SUVNeE1URTNOaTQwTWl3ek1DNDBNelFnTVRBMU5paTB4Y1E5dE1qVjJNakp5TlZaWWVCQlFNakU3Yyt1NGdNall6SXdFZ01UQXpNMEhnPSIsInR5cGUiOiJpbWFnZS9zdmcreG1sIiwic2l6ZXMiOiI0MDk2eDQwOTYifV19">

<!-- React and Babel -->

<script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>

<script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>

<script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>

<!-- Simple QR Code Library -->

<script src="https://cdn.jsdelivr.net/npm/qrcode@1.5.3/build/qrcode.min.js"></script>

<!-- Fonts -->

<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">

<style>
    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
    }
    
    body {
        font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        touch-action: manipulation;
        user-select: none;
        -webkit-user-select: none;
        -webkit-tap-highlight-color: transparent;
        overflow-x: hidden;
        font-size: 16px;
    }
    
    .app {
        height: 100vh;
        height: 100dvh;
        display: flex;
        flex-direction: column;
        overflow: hidden;
        width: 100vw;
    }
    
    .header {
        display: flex;
        flex-direction: column;
        padding: 1rem;
        flex-shrink: 0;
        border-bottom: 1px solid rgba(0,0,0,0.08);
        gap: 0.5rem;
    }
    
    .header-main {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.75rem;
    }
    
    .header-left {
        display: flex;
        align-items: center;
        gap: 0.75rem;
    }
    
    .header-title {
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }
    
    .header h1 {
        font-size: clamp(1rem, 4vw, 1.25rem);
        font-weight: 600;
        margin: 0;
    }
    
    .tree-dots {
        display: flex;
        gap: 4px;
        align-items: center;
    }
    
    .tree-dot {
        width: 6px;
        height: 6px;
        border-radius: 50%;
        transition: all 0.2s ease;
    }
    
    .tree-dot.active {
        width: 8px;
        height: 8px;
    }
    
    .badge {
        font-size: clamp(0.625rem, 2.5vw, 0.75rem);
        padding: 0.125rem 0.375rem;
        border-radius: 4px;
        display: flex;
        align-items: center;
        gap: 0.25rem;
    }
    
    .header-controls {
        display: flex;
        gap: clamp(0.375rem, 2vw, 0.5rem);
        align-items: center;
        position: relative;
    }
    
    .control-btn {
        width: clamp(32px, 8vw, 36px);
        height: clamp(32px, 8vw, 36px);
        border: 1px solid;
        border-radius: 6px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: clamp(0.875rem, 3vw, 1rem);
        cursor: pointer;
        background: transparent;
        flex-shrink: 0;
        transition: transform 0.1s ease;
    }
    
    .control-btn:active {
        transform: scale(0.95);
    }
    
    .control-btn:disabled {
        opacity: 0.4;
        cursor: not-allowed;
        transform: none;
    }
    
    .menu-btn {
        width: clamp(36px, 8vw, 40px);
        height: clamp(36px, 8vw, 40px);
        border: 1px solid;
        border-radius: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: clamp(0.875rem, 3vw, 1rem);
        cursor: pointer;
        background: transparent;
        transition: transform 0.1s ease;
    }
    
    .menu-btn:active {
        transform: scale(0.95);
    }
    
    .tree-nav {
        display: flex;
        gap: 0.25rem;
        align-items: center;
    }
    
    .nav-btn {
        width: 28px;
        height: 28px;
        border: 1px solid;
        border-radius: 4px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 0.75rem;
        cursor: pointer;
        background: transparent;
    }
    
    .nav-counter {
        font-size: 0.75rem;
        padding: 0 0.25rem;
        font-family: 'JetBrains Mono', monospace;
    }
    
    .breadcrumbs {
        display: flex;
        align-items: center;
        gap: 0.25rem;
        flex-wrap: wrap;
        font-family: 'JetBrains Mono', monospace;
        font-size: clamp(0.6875rem, 2vw, 0.75rem);
    }
    
    .breadcrumb-btn {
        background: none;
        border: none;
        cursor: pointer;
        text-decoration: underline;
        font: inherit;
    }
    
    .breadcrumb-sep {
        opacity: 0.6;
    }
    
    .breadcrumb-current {
        font-weight: 600;
        opacity: 1;
    }
    
    .close-btn {
        background: #22c55e;
        color: white;
        border: none;
        padding: 0.25rem 0.5rem;
        border-radius: 4px;
        font-size: 0.75rem;
        cursor: pointer;
        margin-left: 0.5rem;
    }
    
    .main-content {
        flex: 1;
        overflow: hidden;
        display: flex;
        flex-direction: column;
        position: relative;
    }
    
    .tree-container {
        flex: 1;
        overflow-y: auto;
        overflow-x: hidden;
        padding: clamp(0.75rem, 3vw, 1rem);
        position: relative;
        /* Add extra side padding when multiple trees exist for easier swiping */
    }

    .tree-container.multi-tree {
        padding-left: clamp(1.5rem, 5vw, 2rem);
        padding-right: clamp(1.5rem, 5vw, 2rem);
    }
    
    .swipe-hints {
        position: absolute;
        top: 0;
        bottom: 0;
        width: clamp(20px, 4vw, 30px);
        pointer-events: none;
        z-index: 10;
        opacity: 0;
        transition: opacity 0.3s ease;
    }
    
    .swipe-hint-left {
        left: 0;
        background: linear-gradient(to right, rgba(0,0,0,0.03), transparent);
    }
    
    .swipe-hint-right {
        right: 0;
        background: linear-gradient(to left, rgba(0,0,0,0.03), transparent);
    }
    
    .swipe-hints.visible {
        opacity: 1;
    }

    /* Subtle hint for tree swiping when multiple trees exist */
    .tree-container.multi-tree::before,
    .tree-container.multi-tree::after {
        content: '';
        position: absolute;
        top: 50%;
        transform: translateY(-50%);
        width: 4px;
        height: 20px;
        background: currentColor;
        opacity: 0.1;
        border-radius: 2px;
        pointer-events: none;
        z-index: 5;
        transition: opacity 0.3s ease;
    }

    .tree-container.multi-tree::before {
        left: 8px;
    }

    .tree-container.multi-tree::after {
        right: 8px;
    }

    .tree-container.multi-tree:hover::before,
    .tree-container.multi-tree:hover::after {
        opacity: 0.2;
    }
    
    .nodes-list {
        display: flex;
        flex-direction: column;
        gap: 0.125rem;
        padding-bottom: 2rem;
    }
    
    .node {
        display: flex;
        align-items: flex-start;
        gap: 0;
    }
    
    .node-indent {
        display: flex;
        flex-shrink: 0;
    }
    
    .indent-space {
        width: clamp(24px, 5vw, 32px);
    }
    
    .node-content-wrapper {
        display: flex;
        flex-direction: column;
        align-items: flex-start;
    }
    
    .node-content {
        padding: 8px 12px;
        border-radius: 6px;
        border: 1px solid;
        cursor: pointer;
        display: inline-flex;
        align-items: center;
        gap: 8px;
        word-wrap: break-word;
        overflow-wrap: break-word;
        transition: transform 0.1s ease;
        max-width: calc(100vw - 60px);
        width: auto;
        position: relative;
    }
    
    .node-content:active {
        transform: scale(0.98);
    }
    
    .node-content.selected {
        border-width: 2px;
    }
    
    .node-content.completed {
        opacity: 0.6;
    }

    .node-content.draggable {
        cursor: grab;
    }

    .node-content.dragging {
        opacity: 0.5;
        transform: scale(0.95);
        cursor: grabbing;
    }

    .node-content.drag-over {
        border-style: dashed;
        border-width: 2px;
    }

    .node-content.drag-over-above {
        border-top: 3px solid #3b82f6;
    }

    .node-content.drag-over-below {
        border-bottom: 3px solid #3b82f6;
    }

    .drag-indicator {
        position: absolute;
        left: -8px;
        width: 4px;
        height: 100%;
        background: #3b82f6;
        border-radius: 2px;
        opacity: 0;
        transition: opacity 0.2s ease;
    }

    .node-content.drag-over .drag-indicator {
        opacity: 1;
    }
    
    .task-toggle {
        font-size: 16px;
        cursor: pointer;
        flex-shrink: 0;
    }
    
    .node-text {
        flex: 1;
        font-size: clamp(0.875rem, 3vw, 1rem);
        line-height: 1.4;
        min-width: 0;
    }
    
    .node-text.completed {
        text-decoration: line-through;
    }
    
    .node-icons {
        display: flex;
        gap: 4px;
        font-size: 12px;
        opacity: 0.7;
        flex-shrink: 0;
    }
    
    .branch-link {
        color: #3b82f6;
        cursor: pointer;
        opacity: 1;
    }
    
    .node-actions {
        display: flex;
        gap: 6px;
        margin-top: 8px;
        flex-wrap: wrap;
    }
    
    .action-btn {
        display: flex;
        align-items: center;
        gap: 4px;
        padding: 5px 10px;
        border: none;
        border-radius: 4px;
        font-size: 11px;
        color: white;
        cursor: pointer;
        transition: transform 0.1s ease;
    }
    
    .action-btn:active {
        transform: scale(0.95);
    }
    
    .action-btn.edit { background: #6366f1; }
    .action-btn.task { background: #22c55e; }
    .action-btn.focus { background: #3b82f6; }
    .action-btn.branch { background: #10b981; }
    .action-btn.delete { background: #ef4444; }
    .action-btn.save { background: #22c55e; }
    .action-btn.cancel { background: #6b7280; }
    
    .node-edit-input {
        background: transparent;
        border: none;
        outline: none;
        font: inherit;
        width: 100%;
        min-width: 100px;
    }
    
    .input-area {
        flex-shrink: 0;
        padding: 16px;
        border-top: 1px solid rgba(0,0,0,0.08);
    }
    
    .input-container {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 12px 16px;
        border: 1px solid;
        border-radius: 8px;
        cursor: text;
    }
    
    .input-prompt {
        font-family: 'JetBrains Mono', monospace;
        font-size: 20px;
        font-weight: 500;
    }
    
    .indent-indicator {
        font-family: 'JetBrains Mono', monospace;
        font-size: 12px;
        opacity: 0.6;
    }
    
    .main-input {
        flex: 1;
        border: none;
        outline: none;
        background: transparent;
        font-family: 'JetBrains Mono', monospace;
        font-size: 16px;
    }
    
    .main-input::placeholder {
        opacity: 0.6;
    }
    
    .instructions {
        margin-top: 10px;
        font-family: 'JetBrains Mono', monospace;
        font-size: 11px;
        opacity: 0.6;
        text-align: center;
        line-height: 1.4;
    }
    
    .empty-state {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 1rem;
        padding: 3rem 1rem;
        text-align: center;
    }
    
    .empty-icon {
        font-size: 2.5rem;
        opacity: 0.6;
    }
    
    .empty-title {
        font-size: 1rem;
        font-weight: 500;
    }
    
    .empty-desc {
        font-size: 0.875rem;
        opacity: 0.7;
        line-height: 1.4;
    }
    
    .modal {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0,0,0,0.5);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000;
        padding: 20px;
    }
    
    .modal-content {
        width: 100%;
        max-width: 500px;
        max-height: 80vh;
        border-radius: 8px;
        overflow: hidden;
        display: flex;
        flex-direction: column;
    }
    
    .modal-header {
        padding: 16px;
        border-bottom: 1px solid rgba(0,0,0,0.08);
        display: flex;
        align-items: center;
        justify-content: space-between;
    }
    
    .modal-title {
        font-size: 16px;
        font-weight: 600;
        margin: 0;
    }
    
    .modal-close {
        background: none;
        border: none;
        font-size: 16px;
        cursor: pointer;
        padding: 4px;
    }
    
    .modal-body {
        flex: 1;
        overflow-y: auto;
        padding: 16px;
    }
    
    .note-editor {
        width: 100%;
        min-height: 200px;
        padding: 12px;
        border: 1px solid rgba(0,0,0,0.15);
        border-radius: 6px;
        font-size: 14px;
        font-family: inherit;
        resize: vertical;
    }
    
    .dropdown {
        position: relative;
        display: inline-block;
        z-index: 100;
    }
    
    .dropdown-content {
        position: absolute;
        top: 100%;
        right: 0;
        border-radius: 6px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        z-index: 1000;
        min-width: 140px;
        max-height: 300px;
        overflow-y: auto;
        border: 1px solid;
    }
    
    .dropdown-item {
        padding: 8px 12px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: space-between;
        border: none;
        background: none;
        width: 100%;
        text-align: left;
        font-size: 0.875rem;
        transition: background-color 0.15s ease;
    }
    
    .dropdown-item:hover {
        background: rgba(0,0,0,0.08);
    }
    
    .dropdown-item:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }
    
    .markdown-view {
        display: flex;
        flex-direction: column;
        flex: 1;
        overflow: hidden;
    }
    
    .markdown-header {
        padding: 1rem;
        border-bottom: 1px solid rgba(0,0,0,0.08);
        display: flex;
        justify-content: flex-end;
    }
    
    .download-btn {
        border: none;
        padding: 8px 16px;
        border-radius: 6px;
        font-size: 0.875rem;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }
    
    .markdown-content {
        flex: 1;
        overflow: auto;
        padding: 1rem;
        font-family: 'JetBrains Mono', monospace;
        white-space: pre-wrap;
        line-height: 1.6;
        font-size: 0.875rem;
    }

    /* QR Code specific styles */
    .qr-display {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 1rem;
        text-align: center;
    }

    .qr-code {
        padding: 1rem;
        background: white;
        border-radius: 8px;
        display: inline-block;
    }

    .qr-instructions {
        font-size: 0.875rem;
        opacity: 0.8;
        line-height: 1.4;
    }

    .qr-scanner {
        position: relative;
        width: 100%;
        max-width: 300px;
        aspect-ratio: 1;
        margin: 0 auto;
        border-radius: 8px;
        overflow: hidden;
        background: #000;
    }

    .qr-video {
        width: 100%;
        height: 100%;
        object-fit: cover;
    }

    .qr-overlay {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 200px;
        height: 200px;
        border: 2px solid #22c55e;
        border-radius: 8px;
        box-shadow: 0 0 0 99999px rgba(0,0,0,0.5);
    }

    .qr-overlay::before {
        content: '';
        position: absolute;
        top: -1px;
        left: -1px;
        right: -1px;
        bottom: -1px;
        border: 2px solid #22c55e;
        border-radius: 8px;
        animation: qr-scan 2s ease-in-out infinite;
    }

    @keyframes qr-scan {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.5; }
    }

    .sync-options {
        display: flex;
        flex-direction: column;
        gap: 1rem;
    }

    .sync-option {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 1rem;
        border: 1px solid;
        border-radius: 8px;
        cursor: pointer;
        transition: background-color 0.15s ease;
    }

    .sync-option:hover {
        background: rgba(0,0,0,0.05);
    }

    .sync-option-info {
        display: flex;
        flex-direction: column;
        gap: 0.25rem;
    }

    .sync-option-title {
        font-weight: 500;
        font-size: 0.875rem;
    }

    .sync-option-desc {
        font-size: 0.75rem;
        opacity: 0.7;
    }

    .sync-option-icon {
        font-size: 1.5rem;
    }

    .file-input {
        display: none;
    }

    .file-drop-zone {
        border: 2px dashed;
        border-radius: 8px;
        padding: 2rem;
        text-align: center;
        cursor: pointer;
        transition: background-color 0.15s ease;
    }

    .file-drop-zone:hover {
        background: rgba(0,0,0,0.05);
    }

    .file-drop-zone.drag-over {
        background: rgba(34, 197, 94, 0.1);
        border-color: #22c55e;
    }

    /* QR Code specific styles */
    .qr-display {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 1rem;
        text-align: center;
        margin-top: 1rem;
        padding: 1rem;
        border: 1px dashed;
        border-radius: 8px;
    }

    .qr-code {
        padding: 1rem;
        background: white;
        border-radius: 8px;
        display: inline-block;
    }

    .qr-instructions {
        font-size: 0.875rem;
        opacity: 0.8;
        line-height: 1.4;
    }
    
    /* Mobile specific styles */
    @media (max-width: 768px) {
        .header {
            padding: 0.75rem;
        }
        
        .header h1 {
            font-size: 0.875rem;
        }
        
        .control-btn {
            width: 32px;
            height: 32px;
            font-size: 0.875rem;
        }
        
        .action-btn span {
            display: none;
        }
        
        .node-text {
            font-size: 0.875rem;
        }
        
        .main-input {
            font-size: 0.875rem;
        }
        
        .input-prompt {
            font-size: 1.125rem;
        }

        .qr-scanner {
            max-width: 250px;
        }
    }
</style>

</head>
<body>
    <div id="root"></div>

<script type="text/babel">
    const { useState, useEffect, useRef } = React;

    // Theme definitions - Simplified to essentials
    const builtInThemes = {
        light: {
            name: 'Light',
            background: '#fafafa',
            text: '#0a0a0a',
            prompt: '#525252',
            border: '#e5e5e5',
            levelColors: ['#ffffff', '#f8f8f8', '#f0f0f0', '#e8e8e8', '#d6d6d6']
        },
        dark: {
            name: 'Dark',
            background: '#0a0b14',
            text: '#e2e4e9',
            prompt: '#9ca3af',
            border: '#2d3748',
            levelColors: ['#1a1b26', '#24283b', '#414868', '#565f89', '#7c7f93']
        }
    };

    // Utility functions
    const generateId = () => Date.now().toString(36) + Math.random().toString(36).substr(2);

    const getColorForLevel = (theme, level) => {
        if (level < theme.levelColors.length) {
            return theme.levelColors[level];
        } else {
            const baseColorIndex = level % theme.levelColors.length;
            return theme.levelColors[baseColorIndex] + '80';
        }
    };

    // Dynamic text color based on background brightness
    const getTextColorForBackground = (backgroundColor) => {
        // Convert hex to RGB
        const hex = backgroundColor.replace('#', '');
        const r = parseInt(hex.substr(0, 2), 16);
        const g = parseInt(hex.substr(2, 2), 16);
        const b = parseInt(hex.substr(4, 2), 16);
        
        // Calculate brightness (0-255)
        const brightness = (r * 299 + g * 587 + b * 114) / 1000;
        
        // Return light text for dark backgrounds, dark text for light backgrounds
        return brightness < 128 ? '#ffffff' : '#000000';
    };

    // Storage utilities
    const saveToStorage = (trees) => {
        try {
            localStorage.setItem('tree-e-trees', JSON.stringify(trees));
        } catch (error) {
            console.error('Failed to save trees:', error);
        }
    };

    const loadFromStorage = () => {
        try {
            const saved = localStorage.getItem('tree-e-trees');
            if (saved) {
                return JSON.parse(saved);
            }
            
            // Migration from old format
            const oldNodes = localStorage.getItem('tree-e-nodes');
            if (oldNodes) {
                return [{
                    id: 'main',
                    title: 'Main Tree',
                    nodes: JSON.parse(oldNodes),
                    parentTreeId: null,
                    parentNodeId: null,
                    breadcrumb: []
                }];
            }
            
            return [{
                id: 'main',
                title: 'Main Tree',
                nodes: [],
                parentTreeId: null,
                parentNodeId: null,
                breadcrumb: []
            }];
        } catch (error) {
            console.error('Failed to load trees:', error);
            return [{
                id: 'main',
                title: 'Main Tree',
                nodes: [],
                parentTreeId: null,
                parentNodeId: null,
                breadcrumb: []
            }];
        }
    };

    const saveThemeToStorage = (themeName) => {
        try {
            localStorage.setItem('tree-e-theme', themeName);
        } catch (error) {
            console.error('Failed to save theme:', error);
        }
    };

    const loadThemeFromStorage = () => {
        try {
            return localStorage.getItem('tree-e-theme') || 'light';
        } catch (error) {
            console.error('Failed to load theme:', error);
            return 'light';
        }
    };

    // Custom theme management
    const saveCustomThemes = (customThemes) => {
        try {
            localStorage.setItem('tree-e-custom-themes', JSON.stringify(customThemes));
        } catch (error) {
            console.error('Failed to save custom themes:', error);
        }
    };

    const loadCustomThemes = () => {
        try {
            const saved = localStorage.getItem('tree-e-custom-themes');
            return saved ? JSON.parse(saved) : {};
        } catch (error) {
            console.error('Failed to load custom themes:', error);
            return {};
        }
    };

    const deleteCustomTheme = (themeKey) => {
        const customThemes = loadCustomThemes();
        delete customThemes[themeKey];
        saveCustomThemes(customThemes);
        return customThemes;
    };

    // Simple sync utilities - no external dependencies
    const generateSyncCode = () => {
        return Math.random().toString(36).substring(2, 8).toUpperCase();
    };

    const exportForSync = (trees, currentTheme, customThemes) => {
        try {
            const exportData = {
                version: '1.0',
                timestamp: Date.now(),
                syncCode: generateSyncCode(),
                trees: trees.map(tree => ({
                    id: tree.id,
                    title: tree.title,
                    nodes: tree.nodes.map(node => ({
                        id: node.id,
                        content: node.content,
                        level: node.level,
                        note: node.note || '',
                        isTask: node.isTask || false,
                        isCompleted: node.isCompleted || false
                    })),
                    parentTreeId: tree.parentTreeId,
                    parentNodeId: tree.parentNodeId,
                    breadcrumb: tree.breadcrumb || []
                })),
                theme: {
                    currentTheme,
                    customTheme: customThemes[currentTheme] || null,
                    isCustomTheme: !builtInThemes[currentTheme]
                }
            };

            return JSON.stringify(exportData, null, 2);
        } catch (error) {
            console.error('Export failed:', error);
            throw new Error('Failed to export trees');
        }
    };

    const importFromSync = (jsonData) => {
        try {
            const importedData = JSON.parse(jsonData);
            
            if (!importedData.trees || !Array.isArray(importedData.trees)) {
                throw new Error('Invalid export format');
            }

            // Generate new IDs to avoid conflicts
            const processedTrees = importedData.trees.map(tree => ({
                ...tree,
                id: tree.id === 'main' ? 'main' : generateId(),
                nodes: (tree.nodes || []).map(node => ({
                    id: generateId(),
                    content: node.content || '',
                    level: node.level || 0,
                    note: node.note || '',
                    isTask: node.isTask || false,
                    isCompleted: node.isCompleted || false
                })),
                parentTreeId: tree.parentTreeId || null,
                parentNodeId: tree.parentNodeId || null,
                breadcrumb: tree.breadcrumb || []
            }));

            return {
                trees: processedTrees,
                version: importedData.version || '1.0',
                timestamp: importedData.timestamp || Date.now(),
                syncCode: importedData.syncCode || 'SYNC',
                theme: importedData.theme || null
            };
        } catch (error) {
            console.error('Import failed:', error);
            throw new Error('Invalid export format');
        }
    };

    // Touch handling with smart detection
    const useTouchHandler = (onSwipeLeft, onSwipeRight, threshold = 50) => {
        const touchStart = useRef(null);
        const touchEnd = useRef(null);
        const touchStartTarget = useRef(null);

        return {
            onTouchStart: (e) => {
                touchEnd.current = null;
                touchStart.current = e.targetTouches[0].clientX;
                touchStartTarget.current = e.target;
            },
            onTouchMove: (e) => {
                touchEnd.current = e.targetTouches[0].clientX;
            },
            onTouchEnd: () => {
                if (!touchStart.current || !touchEnd.current) return;
                
                const distance = touchStart.current - touchEnd.current;
                if (distance > threshold && onSwipeLeft) onSwipeLeft();
                if (distance < -threshold && onSwipeRight) onSwipeRight();
            }
        };
    };

    // Smart tree navigation that only works on empty space
    const useSmartTreeSwipe = (onSwipeLeft, onSwipeRight, threshold = 80) => {
        const touchStart = useRef(null);
        const touchEnd = useRef(null);
        const touchStartTarget = useRef(null);

        return {
            onTouchStart: (e) => {
                touchEnd.current = null;
                touchStart.current = e.targetTouches[0].clientX;
                touchStartTarget.current = e.target;
            },
            onTouchMove: (e) => {
                touchEnd.current = e.targetTouches[0].clientX;
            },
            onTouchEnd: (e) => {
                if (!touchStart.current || !touchEnd.current) return;
                
                // Only trigger if touch started on empty space, not on nodes or buttons
                const target = touchStartTarget.current;
                const isEmptySpace = target.classList.contains('tree-container') || 
                                   target.classList.contains('nodes-list') ||
                                   target.classList.contains('empty-state') ||
                                   (target.tagName === 'DIV' && !target.closest('.node-content'));
                
                if (!isEmptySpace) return;
                
                const distance = touchStart.current - touchEnd.current;
                const absDistance = Math.abs(distance);
                
                // Require longer swipe for tree navigation to avoid accidental triggers
                if (absDistance > threshold) {
                    if (distance > 0 && onSwipeLeft) {
                        e.preventDefault();
                        onSwipeLeft();
                    } else if (distance < 0 && onSwipeRight) {
                        e.preventDefault();
                        onSwipeRight();
                    }
                }
            }
        };
    };

    // Components
    const Modal = ({ isOpen, onClose, title, children, theme }) => {
        if (!isOpen) return null;

        return (
            <div className="modal" onClick={onClose}>
                <div 
                    className="modal-content" 
                    style={{ backgroundColor: theme.background, color: theme.text }}
                    onClick={(e) => e.stopPropagation()}
                >
                    <div className="modal-header" style={{ borderColor: theme.border }}>
                        <h3 className="modal-title">{title}</h3>
                        <button className="modal-close" onClick={onClose} style={{ color: theme.text }}>
                            ╳
                        </button>
                    </div>
                    <div className="modal-body">
                        {children}
                    </div>
                </div>
            </div>
        );
    };

    const NodeComponent = ({ node, theme, isSelected, isEditing, editText, onEditTextChange, trees, currentTreeId, onTap, onIndent, onOutdent, onDelete, onFocus, onToggleTask, onToggleComplete, onBranchOut, onEdit, onSaveEdit, onCancelEdit, onJumpToBranch, getTextColorForBackground, getColorForLevel, isDragging, isDragOver, dragPosition, onDragStart, onDragOver, onDragLeave, onDrop, onDragEnd, isFrozen }) => {
        const editInputRef = useRef(null);
        const isBranchedOut = trees.some(tree => tree.parentNodeId === node.id);
        
        const swipeHandlers = useTouchHandler(
            () => {
                if (!isFrozen) onOutdent();
            }, 
            () => {
                if (!isFrozen) onIndent();
            }
        );

        // Prevent tree navigation when swiping on nodes, but disable if frozen
        const nodeSwipeHandlers = isFrozen ? {} : {
            ...swipeHandlers,
            onTouchStart: (e) => {
                e.stopPropagation(); // Prevent tree swipe
                swipeHandlers.onTouchStart(e);
            },
            onTouchMove: (e) => {
                e.stopPropagation(); // Prevent tree swipe
                swipeHandlers.onTouchMove(e);
            },
            onTouchEnd: (e) => {
                e.stopPropagation(); // Prevent tree swipe
                swipeHandlers.onTouchEnd(e);
            }
        };

        useEffect(() => {
            if (isEditing && editInputRef.current) {
                editInputRef.current.focus();
                editInputRef.current.select();
            }
        }, [isEditing]);

        const handleKeyPress = (e) => {
            if (e.key === 'Enter') {
                onSaveEdit();
            } else if (e.key === 'Escape') {
                onCancelEdit();
            }
        };

        const getDragClasses = () => {
            let classes = 'node-content';
            if (isSelected) classes += ' selected';
            if (node.isTask && node.isCompleted) classes += ' completed';
            if (isFrozen) classes += ' frozen';
            else if (!isEditing && !isBranchedOut) classes += ' draggable';
            if (isDragging) classes += ' dragging';
            if (isDragOver && dragPosition === 'above') classes += ' drag-over-above';
            if (isDragOver && dragPosition === 'below') classes += ' drag-over-below';
            return classes;
        };

        const handleNodeClick = (e) => {
            if (!isFrozen && !isEditing) {
                onTap(e);
            }
        };

        const handleTaskToggle = (e) => {
            e.stopPropagation();
            if (!isFrozen && !isEditing) {
                onToggleComplete();
            }
        };

        return (
            <div className="node">
                <div className="node-indent">
                    {Array.from({ length: node.level }, (_, i) => (
                        <div key={i} className="indent-space" />
                    ))}
                </div>
                
                <div className="node-content-wrapper">
                    <div 
                        className={getDragClasses()}
                        style={{
                            backgroundColor: isSelected ? theme.border : getColorForLevel(theme, node.level),
                            borderColor: isSelected ? theme.text : theme.border,
                            color: isSelected ? getTextColorForBackground(theme.border) : getTextColorForBackground(getColorForLevel(theme, node.level))
                        }}
                        onClick={handleNodeClick}
                        {...nodeSwipeHandlers}
                        draggable={!isEditing && !isBranchedOut && !isFrozen}
                        onDragStart={!isFrozen ? (e) => onDragStart(e, node.id) : undefined}
                        onDragOver={!isFrozen ? (e) => onDragOver(e, node.id) : undefined}
                        onDragLeave={!isFrozen ? onDragLeave : undefined}
                        onDrop={!isFrozen ? (e) => onDrop(e, node.id) : undefined}
                        onDragEnd={!isFrozen ? onDragEnd : undefined}
                        title={isFrozen ? "This node is part of a branched tree and cannot be edited here" : undefined}
                    >
                        {isDragOver && !isFrozen && <div className="drag-indicator" />}
                        
                        {node.isTask && (
                            <div 
                                className="task-toggle" 
                                onClick={handleTaskToggle}
                                style={{ 
                                    color: node.isCompleted ? '#22c55e' : isSelected ? getTextColorForBackground(theme.border) + '99' : getTextColorForBackground(getColorForLevel(theme, node.level)) + '99',
                                    cursor: isFrozen ? 'not-allowed' : 'pointer'
                                }}
                            >
                                {node.isCompleted ? '☑' : '☐'}
                            </div>
                        )}
                        
                        {isEditing && !isFrozen ? (
                            <input
                                ref={editInputRef}
                                className="node-edit-input"
                                type="text"
                                value={editText}
                                onChange={(e) => onEditTextChange(e.target.value)}
                                onKeyDown={handleKeyPress}
                                onBlur={onSaveEdit}
                                style={{ color: isSelected ? getTextColorForBackground(theme.border) : getTextColorForBackground(getColorForLevel(theme, node.level)) }}
                                onClick={(e) => e.stopPropagation()}
                            />
                        ) : (
                            <div className={`node-text ${node.isTask && node.isCompleted ? 'completed' : ''}`}>
                                {node.content}
                                {isFrozen && (
                                    <span style={{ 
                                        fontSize: '0.75rem', 
                                        opacity: 0.6, 
                                        marginLeft: '0.5rem',
                                        fontStyle: 'italic'
                                    }}>
                                        (in branch)
                                    </span>
                                )}
                            </div>
                        )}
                        
                        {!isEditing && (
                            <div className="node-icons" style={{ color: isSelected ? getTextColorForBackground(theme.border) : getTextColorForBackground(getColorForLevel(theme, node.level)) }}>
                                {node.isTask && <span>☐</span>}
                                {node.note && node.note.trim() && <span>📝</span>}
                                {isBranchedOut && (
                                    <span 
                                        className="branch-link"
                                        onClick={(e) => {
                                            e.stopPropagation();
                                            onJumpToBranch();
                                        }}
                                        title="Jump to branched tree"
                                        style={{ 
                                            color: isSelected ? getTextColorForBackground(theme.border) : getTextColorForBackground(getColorForLevel(theme, node.level))
                                        }}
                                    >
                                        🌿
                                    </span>
                                )}
                            </div>
                        )}
                    </div>
                    
                    {isSelected && !isEditing && !isFrozen && (
                        <div className="node-actions">
                            {!isBranchedOut && (
                                <button className="action-btn edit" onClick={onEdit}>
                                    ✏️ <span>Edit</span>
                                </button>
                            )}
                            <button className="action-btn task" onClick={onToggleTask}>
                                ✅ <span>{node.isTask ? 'Note' : 'Task'}</span>
                            </button>
                            <button className="action-btn focus" onClick={onFocus}>
                                📝 <span>Notes</span>
                            </button>
                            <button 
                                className="action-btn branch" 
                                onClick={onBranchOut} 
                                disabled={trees.length >= 5 || isBranchedOut}
                                style={{ 
                                    opacity: (trees.length >= 5 || isBranchedOut) ? 0.5 : 1,
                                    cursor: (trees.length >= 5 || isBranchedOut) ? 'not-allowed' : 'pointer'
                                }}
                                title={
                                    isBranchedOut ? 'Node already branched out' :
                                    trees.length >= 5 ? 'Maximum 5 trees allowed' : 
                                    'Branch out to explore this thought'
                                }
                            >
                                🌿 <span>Branch</span>
                            </button>
                            <button className="action-btn delete" onClick={onDelete}>
                                🗑️ <span>Delete</span>
                            </button>
                        </div>
                    )}
                    
                    {isEditing && !isFrozen && (
                        <div className="node-actions">
                            <button className="action-btn save" onClick={onSaveEdit}>
                                ✅ <span>Save</span>
                            </button>
                            <button className="action-btn cancel" onClick={onCancelEdit}>
                                ❌ <span>Cancel</span>
                            </button>
                        </div>
                    )}

                    {isFrozen && isSelected && (
                        <div style={{ 
                            marginTop: '8px',
                            padding: '6px 12px',
                            background: 'rgba(156, 163, 175, 0.1)',
                            borderRadius: '4px',
                            fontSize: '0.75rem',
                            color: 'rgba(156, 163, 175, 0.8)',
                            textAlign: 'center'
                        }}>
                            🔒 This node is part of a branched tree. Edit it in the branched tree instead.
                        </div>
                    )}
                </div>
            </div>
        );
    };

    // Main App Component
    const TreeApp = () => {
        // Core State
        const [trees, setTrees] = useState([]);
        const [activeTreeId, setActiveTreeId] = useState('main');
        const [selectedNodeId, setSelectedNodeId] = useState(null);
        
        // UI State
        const [ui, setUi] = useState({
            currentInput: '',
            indentLevel: 0,
            editingNodeId: null,
            editText: '',
            currentTheme: 'light',
            currentFilter: 'all',
            showAbout: false,
            showThemeDropdown: false,
            showFilterDropdown: false,
            showMarkdownView: false,
            showClearConfirm: false,
            showMainMenu: false,
            showLospecImport: false,
            lospecSlug: '',
            lospecLoading: false,
            lospecPreview: null,
            focusedNode: null,
            showSwipeHints: false,
            // Simple sync states
            showSyncExport: false,
            showSyncImport: false,
            showSyncMenu: false,
            syncExportData: null,
            syncImportData: '',
            syncImportError: null,
            // QR states
            syncQRCode: null,
            qrGenerating: false,
            // Drag and drop states
            draggedNodeId: null,
            dragOverNodeId: null,
            dragPosition: null // 'above', 'below', or null
        });

        const [customThemes, setCustomThemes] = useState({});

        const inputRef = useRef(null);
        
        // Combine built-in and custom themes
        const allThemes = { ...builtInThemes, ...customThemes };
        const theme = allThemes[ui.currentTheme] || builtInThemes.light;

        // Helper functions
        const getActiveTree = () => trees.find(tree => tree.id === activeTreeId) || trees[0];
        const getActiveTreeIndex = () => trees.findIndex(tree => tree.id === activeTreeId);

        const updateUi = (updates) => setUi(prev => ({ ...prev, ...updates }));

        const updateActiveTree = (updater) => {
            setTrees(prev => prev.map(tree => 
                tree.id === activeTreeId 
                    ? { ...tree, nodes: typeof updater === 'function' ? updater(tree.nodes) : updater }
                    : tree
            ));
        };

        const setActiveTree = (treeId) => {
            setActiveTreeId(treeId);
            setSelectedNodeId(null);
            updateUi({ indentLevel: 0 });
        };

        const getFilteredNodes = (nodes = null) => {
            const targetNodes = nodes || getActiveTree()?.nodes || [];
            switch (ui.currentFilter) {
                case 'tasks': return targetNodes.filter(node => node.isTask);
                case 'notes': return targetNodes.filter(node => node.note && node.note.trim());
                case 'branched': return targetNodes.filter(node => trees.some(tree => tree.parentNodeId === node.id));
                default: return targetNodes;
            }
        };

        // Helper function to check if a node is part of a branched subtree ON THE CURRENT TREE
        const isNodeInBranchedSubtree = (nodeId, nodeIndex = null) => {
            const activeTree = getActiveTree();
            if (!activeTree) return false;
            
            // If we're on a branched tree itself, don't freeze anything - allow full editing
            if (activeTree.parentTreeId) return false;
            
            const nodes = activeTree.nodes;
            const targetIndex = nodeIndex !== null ? nodeIndex : nodes.findIndex(n => n.id === nodeId);
            
            if (targetIndex === -1) return false;
            
            // Check if this node itself is branched
            if (trees.some(tree => tree.parentNodeId === nodeId)) {
                return true;
            }
            
            // Check if this node is a child of a branched node
            const targetNode = nodes[targetIndex];
            
            // Look backwards to find any parent that is branched
            for (let i = targetIndex - 1; i >= 0; i--) {
                const potentialParent = nodes[i];
                
                // If we find a node at the same or lower level, we've gone too far up
                if (potentialParent.level <= targetNode.level) {
                    // If this is a direct parent (one level less) and it's branched, target is in subtree
                    if (potentialParent.level < targetNode.level && 
                        trees.some(tree => tree.parentNodeId === potentialParent.id)) {
                        return true;
                    }
                    // If same level or we've gone past any possible parents, stop
                    if (potentialParent.level <= targetNode.level) {
                        break;
                    }
                }
                
                // If we find a branched ancestor, check if target is in its subtree
                if (potentialParent.level < targetNode.level && 
                    trees.some(tree => tree.parentNodeId === potentialParent.id)) {
                    return true;
                }
            }
            
            return false;
        };

        const generateQRCode = async (data) => {
            try {
                updateUi({ qrGenerating: true });
                
                // Check if data is too large for QR
                if (data.length > 2950) {
                    throw new Error('Data too large for QR code. Try reducing content or use copy/paste instead.');
                }
                
                if (typeof QRCode !== 'undefined') {
                    const qrDataUrl = await QRCode.toDataURL(data, {
                        width: 300,
                        margin: 2,
                        color: {
                            dark: '#000000',
                            light: '#ffffff'
                        },
                        errorCorrectionLevel: 'M'
                    });
                    
                    updateUi({ 
                        syncQRCode: qrDataUrl,
                        qrGenerating: false 
                    });
                } else {
                    throw new Error('QR code library not available');
                }
            } catch (error) {
                console.error('QR generation failed:', error);
                updateUi({ qrGenerating: false });
                alert(error.message || 'Failed to generate QR code. Use copy/paste instead.');
            }
        };

        // Simple sync functions
        const handleSyncExport = () => {
            try {
                if (trees.length === 0 || trees.every(tree => tree.nodes.length === 0)) {
                    alert('No trees to export! Add some content first.');
                    return;
                }

                const exportData = exportForSync(trees, ui.currentTheme, customThemes);
                updateUi({ 
                    syncExportData: exportData,
                    showSyncExport: true,
                    showSyncMenu: false,
                    syncQRCode: null // Reset QR code
                });
            } catch (error) {
                console.error('Sync export error:', error);
                alert('Failed to export trees: ' + error.message);
            }
        };

        const handleSyncImport = () => {
            updateUi({ 
                showSyncImport: true,
                showSyncMenu: false,
                syncImportData: '',
                syncImportError: null
            });
        };

        const processSyncImport = () => {
            try {
                if (!ui.syncImportData.trim()) {
                    updateUi({ syncImportError: 'Please paste the export data' });
                    return;
                }

                const importedData = importFromSync(ui.syncImportData);
                
                // Merge imported trees
                const mergedTrees = [...trees];
                
                for (const importedTree of importedData.trees) {
                    if (importedTree.id === 'main') {
                        // Merge main tree nodes
                        const mainTreeIndex = mergedTrees.findIndex(t => t.id === 'main');
                        if (mainTreeIndex !== -1) {
                            mergedTrees[mainTreeIndex] = {
                                ...mergedTrees[mainTreeIndex],
                                nodes: [...mergedTrees[mainTreeIndex].nodes, ...importedTree.nodes]
                            };
                        }
                    } else {
                        // Add as new tree
                        mergedTrees.push(importedTree);
                    }
                }
                
                setTrees(mergedTrees);
                
                // Handle theme import
                let successMessage = `Successfully imported ${importedData.trees.length} trees!`;
                
                if (importedData.theme) {
                    const { currentTheme, customTheme, isCustomTheme } = importedData.theme;
                    
                    if (isCustomTheme && customTheme) {
                        // Import custom theme
                        const baseKey = currentTheme;
                        let themeKey = baseKey;
                        let counter = 1;
                        
                        // Ensure unique key for custom theme
                        while (allThemes[themeKey]) {
                            themeKey = `${baseKey}_imported_${counter}`;
                            counter++;
                        }
                        
                        // Add custom theme
                        const newCustomThemes = {
                            ...customThemes,
                            [themeKey]: customTheme
                        };
                        setCustomThemes(newCustomThemes);
                        
                        // Apply the imported theme
                        updateUi({ currentTheme: themeKey });
                        successMessage += ` Theme "${customTheme.name}" imported and applied!`;
                        
                    } else if (builtInThemes[currentTheme]) {
                        // Apply built-in theme
                        updateUi({ currentTheme });
                        successMessage += ` Theme "${builtInThemes[currentTheme].name}" applied!`;
                    }
                }
                
                updateUi({ 
                    showSyncImport: false,
                    syncImportError: null,
                    syncImportData: ''
                });
                
                alert(successMessage);
            } catch (error) {
                updateUi({ syncImportError: error.message });
            }
        };

        const copyToClipboard = async (text) => {
            try {
                await navigator.clipboard.writeText(text);
                alert('Copied to clipboard! Now paste this on your other device.');
            } catch (error) {
                console.error('Failed to copy to clipboard:', error);
                // Fallback for older browsers
                const textArea = document.createElement('textarea');
                textArea.value = text;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                alert('Copied to clipboard! Now paste this on your other device.');
            }
        };

        const shareData = async (text) => {
            if (navigator.share) {
                try {
                    await navigator.share({
                        title: 'Tree-e Export',
                        text: text
                    });
                } catch (error) {
                    if (error.name !== 'AbortError') {
                        console.error('Share failed:', error);
                        copyToClipboard(text);
                    }
                }
            } else {
                copyToClipboard(text);
            }
        };

        // Load/Save
        useEffect(() => {
            const loadedTrees = loadFromStorage();
            const loadedCustomThemes = loadCustomThemes();
            const savedTheme = loadThemeFromStorage();
            
            setTrees(loadedTrees);
            setCustomThemes(loadedCustomThemes);
            
            // Check if saved theme exists, otherwise default to light
            const allAvailableThemes = { ...builtInThemes, ...loadedCustomThemes };
            const themeToUse = allAvailableThemes[savedTheme] ? savedTheme : 'light';
            updateUi({ currentTheme: themeToUse });
            
            setTimeout(() => {
                if (inputRef.current) {
                    inputRef.current.focus();
                }
            }, 100);
        }, []);

        useEffect(() => {
            if (trees.length > 0) {
                saveToStorage(trees);
            }
        }, [trees]);

        useEffect(() => {
            saveThemeToStorage(ui.currentTheme);
        }, [ui.currentTheme]);

        useEffect(() => {
            saveCustomThemes(customThemes);
        }, [customThemes]);

        // Touch handlers for input - prevent tree swipe conflicts
        const inputSwipeHandlers = useTouchHandler(
            () => updateUi({ indentLevel: Math.max(0, ui.indentLevel - 1) }),
            () => updateUi({ indentLevel: ui.indentLevel + 1 })
        );

        // Prevent tree navigation when swiping on input
        const safeInputSwipeHandlers = {
            ...inputSwipeHandlers,
            onTouchStart: (e) => {
                e.stopPropagation(); // Prevent tree swipe
                inputSwipeHandlers.onTouchStart(e);
            },
            onTouchMove: (e) => {
                e.stopPropagation(); // Prevent tree swipe
                inputSwipeHandlers.onTouchMove(e);
            },
            onTouchEnd: (e) => {
                e.stopPropagation(); // Prevent tree swipe
                inputSwipeHandlers.onTouchEnd(e);
            }
        };

        // Touch handlers for tree navigation - smart detection
        const smartTreeSwipeHandlers = useSmartTreeSwipe(
            () => {
                // Swipe left = next tree
                if (trees.length > 1) {
                    const currentIndex = getActiveTreeIndex();
                    const nextIndex = currentIndex < trees.length - 1 ? currentIndex + 1 : 0;
                    setActiveTree(trees[nextIndex].id);
                    updateUi({ showSwipeHints: false });
                }
            },
            () => {
                // Swipe right = previous tree
                if (trees.length > 1) {
                    const currentIndex = getActiveTreeIndex();
                    const prevIndex = currentIndex > 0 ? currentIndex - 1 : trees.length - 1;
                    setActiveTree(trees[prevIndex].id);
                    updateUi({ showSwipeHints: false });
                }
            }
        );

        // Enhanced smart tree swipe handlers with hints
        const enhancedSmartTreeSwipeHandlers = {
            ...smartTreeSwipeHandlers,
            onTouchStart: (e) => {
                // Only show hints if touching empty space and have multiple trees
                const target = e.target;
                const isEmptySpace = target.classList.contains('tree-container') || 
                                   target.classList.contains('nodes-list') ||
                                   target.classList.contains('empty-state') ||
                                   (target.tagName === 'DIV' && !target.closest('.node-content'));
                
                if (trees.length > 1 && isEmptySpace) {
                    updateUi({ showSwipeHints: true });
                }
                smartTreeSwipeHandlers.onTouchStart(e);
            },
            onTouchEnd: (e) => {
                updateUi({ showSwipeHints: false });
                smartTreeSwipeHandlers.onTouchEnd(e);
            }
        };

        // Node operations
        const addNode = () => {
            const content = ui.currentInput.trim();
            if (!content) return;

            const activeTree = getActiveTree();
            if (!activeTree) return;

            const nodes = activeTree.nodes;
            let insertIndex = nodes.length;
            let newLevel = ui.indentLevel;

            if (selectedNodeId) {
                const selectedNode = nodes.find(node => node.id === selectedNodeId);
                const selectedIndex = nodes.findIndex(node => node.id === selectedNodeId);
                
                if (selectedNode && selectedIndex !== -1) {
                    newLevel = selectedNode.level + 1;
                    
                    let insertAfterIndex = selectedIndex;
                    for (let i = selectedIndex + 1; i < nodes.length; i++) {
                        if (nodes[i].level > selectedNode.level) {
                            insertAfterIndex = i;
                        } else {
                            break;
                        }
                    }
                    insertIndex = insertAfterIndex + 1;
                }
            }

            const newNode = {
                id: generateId(),
                content,
                level: newLevel,
                note: '',
                isTask: false,
                isCompleted: false
            };

            updateActiveTree(prevNodes => {
                const newNodes = [...prevNodes];
                newNodes.splice(insertIndex, 0, newNode);
                return newNodes;
            });
            
            updateUi({ currentInput: '', indentLevel: newLevel });
        };

        const selectNode = (nodeId) => {
            // Allow selection of frozen nodes to show the explanation
            if (selectedNodeId === nodeId) {
                // Deselect
                setSelectedNodeId(null);
                const activeTree = getActiveTree();
                if (activeTree?.nodes.length > 0) {
                    updateUi({ indentLevel: activeTree.nodes[activeTree.nodes.length - 1].level });
                } else {
                    updateUi({ indentLevel: 0 });
                }
            } else {
                // Select
                setSelectedNodeId(nodeId);
                const activeTree = getActiveTree();
                const node = activeTree?.nodes.find(n => n.id === nodeId);
                if (node) {
                    updateUi({ indentLevel: node.level + 1 });
                }
            }
        };

        const deleteNode = (nodeId) => {
            // Check if node is frozen
            if (isNodeInBranchedSubtree(nodeId)) return;
            
            updateActiveTree(prevNodes => prevNodes.filter(node => node.id !== nodeId));
            if (selectedNodeId === nodeId) {
                setSelectedNodeId(null);
            }
        };

        const indentNode = (nodeId) => {
            // Check if node is frozen
            if (isNodeInBranchedSubtree(nodeId)) return;
            
            updateActiveTree(prevNodes => prevNodes.map(node =>
                node.id === nodeId ? { ...node, level: node.level + 1 } : node
            ));
            setSelectedNodeId(null);
        };

        const outdentNode = (nodeId) => {
            // Check if node is frozen
            if (isNodeInBranchedSubtree(nodeId)) return;
            
            updateActiveTree(prevNodes => prevNodes.map(node =>
                node.id === nodeId ? { ...node, level: Math.max(0, node.level - 1) } : node
            ));
            setSelectedNodeId(null);
        };

        const toggleTask = (nodeId) => {
            // Check if node is frozen
            if (isNodeInBranchedSubtree(nodeId)) return;
            
            updateActiveTree(prevNodes => prevNodes.map(node =>
                node.id === nodeId ? { ...node, isTask: !node.isTask, isCompleted: false } : node
            ));
            setSelectedNodeId(null);
        };

        const toggleComplete = (nodeId) => {
            // Check if node is frozen
            if (isNodeInBranchedSubtree(nodeId)) return;
            
            updateActiveTree(prevNodes => prevNodes.map(node =>
                node.id === nodeId ? { ...node, isCompleted: !node.isCompleted } : node
            ));
        };

        const editNode = (nodeId) => {
            // Check if node is frozen or branched out
            if (isNodeInBranchedSubtree(nodeId)) return;
            
            const isBranchedOut = trees.some(tree => tree.parentNodeId === nodeId);
            if (isBranchedOut) return;
            
            const activeTree = getActiveTree();
            const node = activeTree?.nodes.find(n => n.id === nodeId);
            if (node) {
                updateUi({ editingNodeId: nodeId, editText: node.content });
                setSelectedNodeId(null);
            }
        };

        const saveEdit = () => {
            const trimmedText = ui.editText.trim();
            if (trimmedText && ui.editingNodeId) {
                updateActiveTree(prevNodes => prevNodes.map(node =>
                    node.id === ui.editingNodeId ? { ...node, content: trimmedText } : node
                ));
            }
            updateUi({ editingNodeId: null, editText: '' });
        };

        const cancelEdit = () => {
            updateUi({ editingNodeId: null, editText: '' });
        };

        const focusNode = (nodeId) => {
            // Check if node is frozen
            if (isNodeInBranchedSubtree(nodeId)) return;
            
            const activeTree = getActiveTree();
            const node = activeTree?.nodes.find(n => n.id === nodeId);
            if (node) {
                updateUi({ focusedNode: node });
            }
            setSelectedNodeId(null);
        };

        const saveFocusNote = (note) => {
            if (ui.focusedNode) {
                updateActiveTree(prevNodes => prevNodes.map(node =>
                    node.id === ui.focusedNode.id ? { ...node, note } : node
                ));
            }
            updateUi({ focusedNode: null });
        };

        // Drag and drop functions
        const handleDragStart = (e, nodeId) => {
            // Check if node is frozen
            if (isNodeInBranchedSubtree(nodeId)) {
                e.preventDefault();
                return;
            }
            
            updateUi({ draggedNodeId: nodeId });
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', nodeId);
        };

        const handleDragOver = (e, nodeId) => {
            // Check if target node is frozen
            if (isNodeInBranchedSubtree(nodeId)) {
                e.dataTransfer.dropEffect = 'none';
                return;
            }
            
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            
            // Determine if we're dropping above or below
            const rect = e.currentTarget.getBoundingClientRect();
            const y = e.clientY;
            const middle = rect.top + rect.height / 2;
            const position = y < middle ? 'above' : 'below';
            
            updateUi({ 
                dragOverNodeId: nodeId,
                dragPosition: position
            });
        };

        const handleDragLeave = (e) => {
            // Only clear if we're actually leaving the node
            if (!e.currentTarget.contains(e.relatedTarget)) {
                updateUi({ 
                    dragOverNodeId: null,
                    dragPosition: null
                });
            }
        };

        const handleDrop = (e, targetNodeId) => {
            e.preventDefault();
            
            const draggedNodeId = ui.draggedNodeId;
            const position = ui.dragPosition;
            
            // Check if either node is frozen
            if (isNodeInBranchedSubtree(draggedNodeId) || isNodeInBranchedSubtree(targetNodeId)) {
                updateUi({ 
                    draggedNodeId: null, 
                    dragOverNodeId: null,
                    dragPosition: null
                });
                return;
            }
            
            if (!draggedNodeId || draggedNodeId === targetNodeId) {
                updateUi({ 
                    draggedNodeId: null, 
                    dragOverNodeId: null,
                    dragPosition: null
                });
                return;
            }

            updateActiveTree(prevNodes => {
                const nodes = [...prevNodes];
                const draggedIndex = nodes.findIndex(node => node.id === draggedNodeId);
                const targetIndex = nodes.findIndex(node => node.id === targetNodeId);
                
                if (draggedIndex === -1 || targetIndex === -1) return nodes;
                
                // Remove the dragged node
                const [draggedNode] = nodes.splice(draggedIndex, 1);
                
                // Calculate new insertion index
                let newIndex = targetIndex;
                if (draggedIndex < targetIndex) {
                    newIndex = targetIndex - 1; // Adjust for removed node
                }
                
                // Insert based on position
                if (position === 'above') {
                    nodes.splice(newIndex, 0, draggedNode);
                } else {
                    nodes.splice(newIndex + 1, 0, draggedNode);
                }
                
                return nodes;
            });

            updateUi({ 
                draggedNodeId: null, 
                dragOverNodeId: null,
                dragPosition: null
            });
        };

        const handleDragEnd = () => {
            updateUi({ 
                draggedNodeId: null, 
                dragOverNodeId: null,
                dragPosition: null
            });
        };

        // Branch operations
        const branchOut = (nodeId) => {
            // Check if node is frozen
            if (isNodeInBranchedSubtree(nodeId)) return;
            
            const activeTree = getActiveTree();
            if (!activeTree || trees.length >= 5) return;

            const selectedNode = activeTree.nodes.find(node => node.id === nodeId);
            if (!selectedNode) return;

            const nodeAndChildren = [];
            let foundParent = false;
            
            for (const node of activeTree.nodes) {
                if (node.id === selectedNode.id) {
                    foundParent = true;
                    nodeAndChildren.push({ ...node, level: 0 });
                } else if (foundParent && node.level > selectedNode.level) {
                    nodeAndChildren.push({ ...node, level: node.level - selectedNode.level });
                } else if (foundParent && node.level <= selectedNode.level) {
                    break;
                }
            }

            const truncatedTitle = selectedNode.content.length > 20 
                ? selectedNode.content.substring(0, 17) + '...'
                : selectedNode.content;

            const newBreadcrumb = [];
            if (activeTree.id !== 'main') {
                newBreadcrumb.push(...activeTree.breadcrumb, activeTree.title);
            }
            
            if (newBreadcrumb.length > 3) {
                newBreadcrumb.splice(1, newBreadcrumb.length - 3);
                newBreadcrumb[1] = '...';
            }

            const newTree = {
                id: generateId(),
                title: truncatedTitle,
                nodes: nodeAndChildren,
                parentTreeId: activeTree.id,
                parentNodeId: selectedNode.id,
                breadcrumb: newBreadcrumb
            };

            setTrees(prev => [...prev, newTree]);
            setActiveTree(newTree.id);
            setSelectedNodeId(null);
            updateUi({ indentLevel: 0 });
        };

        const closeTree = () => {
            const activeTree = getActiveTree();
            if (!activeTree || !activeTree.parentTreeId) return;

            const parentTree = trees.find(tree => tree.id === activeTree.parentTreeId);
            if (!parentTree) return;

            // Merge changes back
            setTrees(prev => {
                const newTrees = [...prev];
                const parentIndex = newTrees.findIndex(tree => tree.id === activeTree.parentTreeId);
                const parentNodes = [...newTrees[parentIndex].nodes];
                
                const originalNodeIndex = parentNodes.findIndex(node => node.id === activeTree.parentNodeId);
                if (originalNodeIndex === -1) return newTrees;

                const originalNode = parentNodes[originalNodeIndex];
                
                // Remove old children
                let removeUntilIndex = parentNodes.length;
                for (let i = originalNodeIndex + 1; i < parentNodes.length; i++) {
                    if (parentNodes[i].level <= originalNode.level) {
                        removeUntilIndex = i;
                        break;
                    }
                }
                
                // Replace with updated nodes
                const updatedNodes = activeTree.nodes.map(node => ({
                    ...node,
                    level: node.level + originalNode.level
                }));

                parentNodes.splice(originalNodeIndex, removeUntilIndex - originalNodeIndex, ...updatedNodes);
                newTrees[parentIndex] = { ...newTrees[parentIndex], nodes: parentNodes };

                // Remove the closed tree
                const activeTreeIndex = newTrees.findIndex(tree => tree.id === activeTreeId);
                newTrees.splice(activeTreeIndex, 1);

                return newTrees;
            });

            setActiveTree(activeTree.parentTreeId);
        };

        const jumpToBranch = (nodeId) => {
            const branchedTree = trees.find(tree => tree.parentNodeId === nodeId);
            if (branchedTree) {
                setActiveTree(branchedTree.id);
            }
        };

        // Lospec Integration
        const fetchLospecPalette = async (slug) => {
            if (!slug.trim()) return null;
            
            updateUi({ lospecLoading: true });
            
            try {
                const response = await fetch(`https://lospec.com/palette-list/${slug.trim()}.json`);
                
                if (!response.ok) {
                    throw new Error('Palette not found');
                }
                
                const data = await response.json();
                updateUi({ lospecLoading: false });
                
                return data;
            } catch (error) {
                updateUi({ lospecLoading: false });
                alert(`Error fetching palette: ${error.message}`);
                return null;
            }
        };

        const convertLospecToTheme = (lospecData) => {
            const colors = lospecData.colors.map(c => `#${c}`);
            const name = lospecData.name;
            
            // Calculate color brightness to determine theme type
            const getBrightness = (hex) => {
                const r = parseInt(hex.slice(1, 3), 16);
                const g = parseInt(hex.slice(3, 5), 16);
                const b = parseInt(hex.slice(5, 7), 16);
                return (r * 299 + g * 587 + b * 114) / 1000;
            };
            
            // Sort colors by brightness
            const sortedColors = [...colors].sort((a, b) => getBrightness(a) - getBrightness(b));
            const darkest = sortedColors[0];
            const lightest = sortedColors[sortedColors.length - 1];
            const darkestBrightness = getBrightness(darkest);
            const lightestBrightness = getBrightness(lightest);
            
            // Determine if this should be a dark or light theme
            const isDarkTheme = lightestBrightness - darkestBrightness > 100 && darkestBrightness < 80;
            
            let background, text, border;
            
            if (isDarkTheme) {
                background = darkest;
                text = lightest;
                border = sortedColors[Math.floor(sortedColors.length * 0.3)];
            } else {
                background = lightest;
                text = darkest;
                border = sortedColors[Math.floor(sortedColors.length * 0.7)];
            }
            
            // Choose prompt color (accent color)
            const midIndex = Math.floor(sortedColors.length / 2);
            const prompt = sortedColors[midIndex];
            
            // Distribute colors for levels - try to get good variety
            const levelColors = [];
            const step = Math.max(1, Math.floor(colors.length / 5));
            
            for (let i = 0; i < 5; i++) {
                const index = (i * step) % colors.length;
                levelColors.push(colors[index]);
            }
            
            // Ensure we have 5 unique colors for levels
            while (levelColors.length < 5) {
                levelColors.push(colors[levelColors.length % colors.length]);
            }
            
            return {
                name: `${name} (Lospec)`,
                background,
                text,
                prompt,
                border,
                levelColors: levelColors.slice(0, 5)
            };
        };

        const previewLospecPalette = async () => {
            const data = await fetchLospecPalette(ui.lospecSlug);
            if (data) {
                const theme = convertLospecToTheme(data);
                updateUi({ lospecPreview: theme });
            }
        };

        const importLospecTheme = () => {
            if (ui.lospecPreview) {
                // Generate a unique key for the theme
                const baseKey = ui.lospecSlug.toLowerCase().replace(/[^a-z0-9]/g, '');
                let themeKey = baseKey;
                let counter = 1;
                
                // Ensure unique key
                while (allThemes[themeKey]) {
                    themeKey = `${baseKey}${counter}`;
                    counter++;
                }
                
                // Add to custom themes
                const newCustomThemes = {
                    ...customThemes,
                    [themeKey]: ui.lospecPreview
                };
                
                setCustomThemes(newCustomThemes);
                updateUi({ 
                    currentTheme: themeKey,
                    showLospecImport: false, 
                    lospecSlug: '', 
                    lospecPreview: null 
                });
            }
        };

        const removeCustomTheme = (themeKey) => {
            if (builtInThemes[themeKey]) return; // Can't delete built-in themes
            
            const newCustomThemes = { ...customThemes };
            delete newCustomThemes[themeKey];
            setCustomThemes(newCustomThemes);
            
            // Switch to light theme if current theme was deleted
            if (ui.currentTheme === themeKey) {
                updateUi({ currentTheme: 'light' });
            }
        };

        // Export/Import
        const generateMarkdown = () => {
            return trees.map((tree) => {
                const nodesToUse = ui.currentFilter !== 'all' ? getFilteredNodes(tree.nodes) : tree.nodes;
                
                let treeMarkdown = tree.id === 'main' ? `# ${tree.title}` : `## ${tree.title}`;
                if (tree.breadcrumb.length > 0) {
                    treeMarkdown += ` (Branch from: ${tree.breadcrumb.join(' > ')})`;
                }
                treeMarkdown += '\n\n';
                
                const nodeMarkdown = nodesToUse.map(node => {
                    const indent = '  '.repeat(node.level);
                    let content;
                    
                    if (node.isTask) {
                        const taskSymbol = node.isCompleted ? '- [x]' : '- [ ]';
                        content = `${indent}${taskSymbol} ${node.content}`;
                    } else {
                        content = `${indent}- ${node.content}`;
                    }
                    
                    const isBranchedOut = trees.some(otherTree => otherTree.parentNodeId === node.id);
                    if (isBranchedOut) {
                        const branchedTree = trees.find(otherTree => otherTree.parentNodeId === node.id);
                        if (branchedTree) {
                            content += ` → branched to: ${branchedTree.title}`;
                        }
                    }
                    
                    if (node.note && node.note.trim()) {
                        const noteLines = node.note.split('\n');
                        const indentedNote = noteLines.map(line => `${indent}  > ${line}`).join('\n');
                        content += '\n' + indentedNote;
                    }
                    
                    return content;
                }).join('\n');
                
                return treeMarkdown + (nodeMarkdown || '*Empty tree*');
            }).join('\n\n---\n\n');
        };

        const exportMarkdown = () => {
            const markdown = generateMarkdown();
            const blob = new Blob([markdown], { type: 'text/markdown' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            const filterSuffix = ui.currentFilter !== 'all' ? `-${ui.currentFilter}` : '';
            a.download = `tree-e-export${filterSuffix}.md`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        };

        const clearAll = () => {
            setTrees([{
                id: 'main',
                title: 'Main Tree',
                nodes: [],
                parentTreeId: null,
                parentNodeId: null,
                breadcrumb: []
            }]);
            setActiveTreeId('main');
            setSelectedNodeId(null);
            updateUi({ 
                indentLevel: 0,
                showClearConfirm: false
            });
        };

        // Event handlers
        const handleBackgroundClick = (e) => {
            if (e.target.classList.contains('app') || 
                e.target.classList.contains('main-content') || 
                e.target.classList.contains('tree-container') ||
                e.target.classList.contains('nodes-list')) {
                
                setSelectedNodeId(null);
                updateUi({ 
                    showThemeDropdown: false,
                    showFilterDropdown: false,
                    showMainMenu: false,
                    showLospecImport: false,
                    showSyncMenu: false,
                    editingNodeId: null,
                    editText: '',
                    showSwipeHints: false,
                    draggedNodeId: null,
                    dragOverNodeId: null,
                    dragPosition: null
                });
                
                const activeTree = getActiveTree();
                if (activeTree?.nodes.length > 0) {
                    updateUi({ indentLevel: activeTree.nodes[activeTree.nodes.length - 1].level });
                } else {
                    updateUi({ indentLevel: 0 });
                }
            }
        };

        // Derived state
        const activeTree = getActiveTree();
        const currentNodes = activeTree?.nodes || [];
        const filteredNodes = getFilteredNodes();
        const selectedNode = selectedNodeId ? currentNodes.find(node => node.id === selectedNodeId) : null;
        
        const filterOptions = [
            { key: 'all', label: 'All Nodes', icon: '◎' },
            { key: 'tasks', label: 'Tasks', icon: '□' },
            { key: 'notes', label: 'With Notes', icon: '◊' },
            { key: 'branched', label: 'Branched', icon: '⫷' }
        ];

        return (
            <div 
                className="app" 
                style={{ 
                    backgroundColor: theme.background,
                    color: theme.text 
                }}
                onClick={handleBackgroundClick}
            >
                {/* Header */}
                <div className="header" style={{ backgroundColor: theme.background, borderColor: theme.border }} {...(trees.length > 1 ? enhancedSmartTreeSwipeHandlers : {})}>
                    <div className="header-main">
                        <div className="header-left">
                            <div className="header-title">
                                {trees.length > 1 && (
                                    <div className="tree-dots" title="Swipe to navigate between trees">
                                        {trees.map((_, index) => (
                                            <div
                                                key={index}
                                                className={`tree-dot ${index === getActiveTreeIndex() ? 'active' : ''}`}
                                                style={{
                                                    backgroundColor: index === getActiveTreeIndex() ? theme.text : theme.text + '40'
                                                }}
                                            />
                                        ))}
                                    </div>
                                )}
                            </div>
                            
                            {ui.currentFilter !== 'all' && (
                                <span className="badge" style={{ 
                                    color: theme.text + '99',
                                    background: theme.border
                                }}>
                                    {filterOptions.find(f => f.key === ui.currentFilter)?.icon}
                                    {filterOptions.find(f => f.key === ui.currentFilter)?.label}
                                </span>
                            )}
                        </div>
                        
                        <div className="header-controls">
                            {/* Sync Button */}
                            <div className="dropdown">
                                <button 
                                    className="control-btn"
                                    onClick={(e) => {
                                        e.stopPropagation();
                                        updateUi({ 
                                            showSyncMenu: !ui.showSyncMenu, 
                                            showMainMenu: false, 
                                            showThemeDropdown: false 
                                        });
                                    }}
                                    style={{
                                        backgroundColor: getColorForLevel(theme, 0),
                                        borderColor: theme.border,
                                        color: theme.text
                                    }}
                                    title="Sync between devices"
                                >
                                    ⟲
                                </button>
                                {ui.showSyncMenu && (
                                    <div 
                                        className="dropdown-content"
                                        style={{
                                            backgroundColor: theme.background,
                                            borderColor: theme.border,
                                            color: theme.text
                                        }}
                                    >
                                        <button
                                            className="dropdown-item"
                                            onClick={handleSyncExport}
                                            disabled={trees.length === 0 || trees.every(tree => tree.nodes.length === 0)}
                                            style={{ color: (trees.length === 0 || trees.every(tree => tree.nodes.length === 0)) ? theme.text + '50' : theme.text }}
                                        >
                                            <span>📤 Export & QR</span>
                                        </button>
                                        <button
                                            className="dropdown-item"
                                            onClick={handleSyncImport}
                                            style={{ color: theme.text }}
                                        >
                                            <span>📥 Import & Scan</span>
                                        </button>
                                    </div>
                                )}
                            </div>

                            {/* Main Menu */}
                            <div className="dropdown">
                                <button 
                                    className="menu-btn"
                                    onClick={(e) => {
                                        e.stopPropagation();
                                        updateUi({ 
                                            showMainMenu: !ui.showMainMenu, 
                                            showThemeDropdown: false, 
                                            showFilterDropdown: false,
                                            showSyncMenu: false
                                        });
                                    }}
                                    style={{
                                        backgroundColor: getColorForLevel(theme, 0),
                                        borderColor: theme.border,
                                        color: theme.text
                                    }}
                                >
                                    ≡
                                </button>
                                {ui.showMainMenu && (
                                    <div 
                                        className="dropdown-content"
                                        style={{
                                            backgroundColor: theme.background,
                                            borderColor: theme.border,
                                            color: theme.text
                                        }}
                                    >
                                        <button
                                            className="dropdown-item"
                                            onClick={() => {
                                                updateUi({ currentFilter: ui.currentFilter === 'all' ? 'tasks' : 'all', showMainMenu: false });
                                            }}
                                            style={{ color: theme.text }}
                                        >
                                            <span>Filter</span>
                                            <span>{ui.currentFilter !== 'all' ? '●' : ''}</span>
                                        </button>
                                        <button
                                            className="dropdown-item"
                                            onClick={() => {
                                                updateUi({ showMainMenu: false, showMarkdownView: !ui.showMarkdownView });
                                            }}
                                            disabled={trees.length === 0 || trees.every(tree => tree.nodes.length === 0)}
                                            style={{ color: (trees.length === 0 || trees.every(tree => tree.nodes.length === 0)) ? theme.text + '50' : theme.text }}
                                        >
                                            <span>{ui.showMarkdownView ? 'Back' : 'Export'}</span>
                                        </button>
                                        <button
                                            className="dropdown-item"
                                            onClick={() => {
                                                updateUi({ showThemeDropdown: !ui.showThemeDropdown, showMainMenu: false });
                                            }}
                                            style={{ color: theme.text }}
                                        >
                                            <span>Themes</span>
                                        </button>
                                        <button
                                            className="dropdown-item"
                                            onClick={() => {
                                                updateUi({ showAbout: true, showMainMenu: false });
                                            }}
                                            style={{ color: theme.text }}
                                        >
                                            <span>About</span>
                                        </button>
                                        <button
                                            className="dropdown-item"
                                            onClick={() => {
                                                if (trees.length > 0 && trees.some(tree => tree.nodes.length > 0)) {
                                                    updateUi({ showClearConfirm: true, showMainMenu: false });
                                                }
                                            }}
                                            disabled={trees.length === 0 || trees.every(tree => tree.nodes.length === 0)}
                                            style={{ color: trees.length === 0 || trees.every(tree => tree.nodes.length === 0) ? theme.text + '50' : '#ef4444' }}
                                        >
                                            <span>Clear All</span>
                                        </button>
                                    </div>
                                )}
                            </div>
                            
                            {/* Theme Dropdown - Fixed positioning */}
                            {ui.showThemeDropdown && (
                                <div style={{ position: 'absolute', top: '100%', right: 0, zIndex: 200 }}>
                                    <div 
                                        className="dropdown-content"
                                        style={{
                                            backgroundColor: theme.background,
                                            borderColor: theme.border,
                                            color: theme.text
                                        }}
                                    >
                                        {/* Built-in themes */}
                                        {Object.entries(builtInThemes).map(([key, themeOption]) => (
                                            <button
                                                key={key}
                                                className="dropdown-item"
                                                onClick={() => {
                                                    updateUi({ currentTheme: key, showThemeDropdown: false });
                                                }}
                                                style={{ color: theme.text }}
                                            >
                                                <span>{themeOption.name}</span>
                                                {ui.currentTheme === key && <span>●</span>}
                                            </button>
                                        ))}
                                        
                                        {/* Custom themes */}
                                        {Object.keys(customThemes).length > 0 && (
                                            <>
                                                <div style={{ borderTop: `1px solid ${theme.border}`, margin: '4px 0' }} />
                                                {Object.entries(customThemes).map(([key, themeOption]) => (
                                                    <div key={key} style={{ display: 'flex', alignItems: 'center' }}>
                                                        <button
                                                            className="dropdown-item"
                                                            onClick={() => {
                                                                updateUi({ currentTheme: key, showThemeDropdown: false });
                                                            }}
                                                            style={{ 
                                                                color: theme.text, 
                                                                flex: 1,
                                                                borderRadius: '0'
                                                            }}
                                                        >
                                                            <span>{themeOption.name}</span>
                                                            {ui.currentTheme === key && <span>●</span>}
                                                        </button>
                                                        <button
                                                            onClick={(e) => {
                                                                e.stopPropagation();
                                                                removeCustomTheme(key);
                                                            }}
                                                            style={{
                                                                background: 'none',
                                                                border: 'none',
                                                                color: '#ef4444',
                                                                cursor: 'pointer',
                                                                padding: '8px',
                                                                fontSize: '0.75rem'
                                                            }}
                                                            title="Delete custom theme"
                                                        >
                                                            ╳
                                                        </button>
                                                    </div>
                                                ))}
                                            </>
                                        )}
                                        
                                        <div style={{ borderTop: `1px solid ${theme.border}`, margin: '4px 0' }} />
                                        <button
                                            className="dropdown-item"
                                            onClick={() => {
                                                updateUi({ showLospecImport: true, showThemeDropdown: false });
                                            }}
                                            style={{ color: theme.prompt, fontStyle: 'italic' }}
                                        >
                                            <span>Import from Lospec...</span>
                                        </button>
                                    </div>
                                </div>
                            )}
                        </div>
                    </div>
                    
                    {/* Breadcrumbs - Pure Hierarchy */}
                    {activeTree?.id !== 'main' && (
                        <div className="breadcrumbs" style={{ color: theme.text }}>
                            <button
                                className="breadcrumb-btn"
                                onClick={() => setActiveTree('main')}
                                style={{ color: theme.text + '99' }}
                            >
                                Main Tree
                            </button>
                            
                            {activeTree?.breadcrumb?.map((crumb, index) => (
                                <React.Fragment key={index}>
                                    <span className="breadcrumb-sep"> > </span>
                                    <span style={{ color: theme.text + '99' }}>{crumb}</span>
                                </React.Fragment>
                            ))}
                            
                            <span className="breadcrumb-sep"> > </span>
                            <span className="breadcrumb-current" style={{ color: theme.text }}>
                                {activeTree?.title}
                            </span>
                            
                            <button
                                className="close-btn"
                                onClick={closeTree}
                                title="Close tree and merge changes back"
                            >
                                ✓ Close
                            </button>
                        </div>
                    )}
                </div>

                {/* Main Content */}
                {ui.showMarkdownView ? (
                    <div className="markdown-view">
                        <div className="markdown-header" style={{ borderColor: theme.border }}>
                            <button
                                className="download-btn"
                                onClick={exportMarkdown}
                                style={{
                                    background: theme.text,
                                    color: theme.background
                                }}
                            >
                                ↓ Download MD
                            </button>
                        </div>
                        <div className="markdown-content" style={{ color: theme.text }}>
                            {generateMarkdown() || 'No content to display'}
                        </div>
                    </div>
                ) : (
                    <div className="main-content">
                        <div className={`tree-container ${trees.length > 1 ? 'multi-tree' : ''}`} {...(trees.length > 1 ? enhancedSmartTreeSwipeHandlers : {})}>
                            {/* Swipe hints */}
                            {trees.length > 1 && (
                                <>
                                    <div className={`swipe-hints swipe-hint-left ${ui.showSwipeHints ? 'visible' : ''}`} style={{ background: `linear-gradient(to right, ${theme.border}, transparent)` }} />
                                    <div className={`swipe-hints swipe-hint-right ${ui.showSwipeHints ? 'visible' : ''}`} style={{ background: `linear-gradient(to left, ${theme.border}, transparent)` }} />
                                </>
                            )}
                            
                            <div className="nodes-list">
                                {filteredNodes.length === 0 && currentNodes.length > 0 && ui.currentFilter !== 'all' ? (
                                    <div className="empty-state" {...enhancedSmartTreeSwipeHandlers}>
                                        <div className="empty-icon">{filterOptions.find(f => f.key === ui.currentFilter)?.icon}</div>
                                        <div className="empty-title">No {filterOptions.find(f => f.key === ui.currentFilter)?.label.toLowerCase()} found</div>
                                        <div className="empty-desc">
                                            Try a different filter or add some {ui.currentFilter === 'tasks' ? 'task nodes' : ui.currentFilter === 'notes' ? 'notes to your nodes' : 'branched nodes'}.
                                            {trees.length > 1 && <><br /><br />💡 Swipe here to navigate between trees</>}
                                        </div>
                                    </div>
                                ) : filteredNodes.length === 0 ? (
                                    <div className="empty-state" {...enhancedSmartTreeSwipeHandlers}>
                                        <div className="empty-icon">🌱</div>
                                        <div className="empty-title">Empty tree</div>
                                        <div className="empty-desc">
                                            {activeTree?.id === 'main' ? 'Start your Tree-e by adding your first thought below.' : 'This branch is ready for new ideas.'}
                                            {trees.length > 1 && <><br /><br />💡 Swipe here to navigate between trees</>}
                                        </div>
                                    </div>
                                ) : (
                                    <>
                                        {filteredNodes.map((node, index) => (
                                            <NodeComponent
                                                key={node.id}
                                                node={node}
                                                theme={theme}
                                                isSelected={selectedNodeId === node.id}
                                                isEditing={ui.editingNodeId === node.id}
                                                editText={ui.editText}
                                                onEditTextChange={(text) => updateUi({ editText: text })}
                                                trees={trees}
                                                currentTreeId={activeTreeId}
                                                getTextColorForBackground={getTextColorForBackground}
                                                getColorForLevel={getColorForLevel}
                                                isDragging={ui.draggedNodeId === node.id}
                                                isDragOver={ui.dragOverNodeId === node.id}
                                                dragPosition={ui.dragPosition}
                                                onDragStart={handleDragStart}
                                                onDragOver={handleDragOver}
                                                onDragLeave={handleDragLeave}
                                                onDrop={handleDrop}
                                                onDragEnd={handleDragEnd}
                                                isFrozen={isNodeInBranchedSubtree(node.id, index)}
                                                onTap={(e) => {
                                                    e.stopPropagation();
                                                    selectNode(node.id);
                                                }}
                                                onIndent={() => indentNode(node.id)}
                                                onOutdent={() => outdentNode(node.id)}
                                                onDelete={() => deleteNode(node.id)}
                                                onFocus={() => focusNode(node.id)}
                                                onToggleTask={() => toggleTask(node.id)}
                                                onToggleComplete={() => toggleComplete(node.id)}
                                                onBranchOut={() => branchOut(node.id)}
                                                onEdit={() => editNode(node.id)}
                                                onSaveEdit={saveEdit}
                                                onCancelEdit={cancelEdit}
                                                onJumpToBranch={() => jumpToBranch(node.id)}
                                            />
                                        ))}
                                        
                                        {/* Empty space at bottom for tree navigation when nodes exist */}
                                        {trees.length > 1 && (
                                            <div 
                                                style={{ 
                                                    height: '100px', 
                                                    display: 'flex', 
                                                    alignItems: 'center', 
                                                    justifyContent: 'center',
                                                    opacity: 0.5,
                                                    fontSize: '0.875rem',
                                                    textAlign: 'center',
                                                    padding: '0 2rem'
                                                }}
                                                {...enhancedSmartTreeSwipeHandlers}
                                            >
                                                💡 Swipe here to navigate between trees
                                            </div>
                                        )}
                                    </>
                                )}
                            </div>
                        </div>
                    </div>
                )}

                {/* Input Area */}
                {!ui.showMarkdownView && (
                    <div className="input-area" style={{ backgroundColor: theme.background, borderColor: theme.border }}>
                        <div 
                            className="input-container"
                            style={{
                                borderColor: theme.border,
                                backgroundColor: theme.background
                            }}
                            onClick={(e) => {
                                e.stopPropagation();
                                inputRef.current?.focus();
                            }}
                            {...safeInputSwipeHandlers}
                        >
                            <div className="input-prompt" style={{ color: theme.prompt }}>
                                >
                            </div>
                            
                            {ui.indentLevel > 0 && (
                                <div className="indent-indicator" style={{ color: theme.prompt }}>
                                    {'  │'.repeat(ui.indentLevel)}
                                </div>
                            )}
                            
                            <input
                                ref={inputRef}
                                className="main-input"
                                type="text"
                                value={ui.currentInput}
                                onChange={(e) => updateUi({ currentInput: e.target.value })}
                                onKeyDown={(e) => {
                                    if (e.key === 'Enter') {
                                        addNode();
                                    } else if (e.key === 'Tab') {
                                        e.preventDefault();
                                        if (e.shiftKey) {
                                            updateUi({ indentLevel: Math.max(0, ui.indentLevel - 1) });
                                        } else {
                                            updateUi({ indentLevel: ui.indentLevel + 1 });
                                        }
                                    }
                                }}
                                placeholder={
                                    activeTree 
                                        ? `${activeTree.id === 'main' ? 'Main Tree' : activeTree.title}${selectedNode ? `: ${selectedNode.content} (lvl ${selectedNode.level + 1})` : ''} / Swipe left or right here`
                                        : "Start your Tree-e / Swipe left or right here"
                                }
                                style={{ color: theme.text }}
                            />
                        </div>
                    </div>
                )}

                {/* Modals */}
                <Modal
                    isOpen={ui.showAbout}
                    onClose={() => updateUi({ showAbout: false })}
                    title="About Tree-e"
                    theme={theme}
                >
                    <div style={{ display: 'flex', flexDirection: 'column', gap: '1rem' }}>
                        <div>
                            <h4 style={{ marginBottom: '0.5rem', fontSize: '1rem', fontWeight: '600' }}>The Philosophy</h4>
                            <p style={{ lineHeight: 1.6, opacity: 0.9, fontSize: '0.875rem' }}>
                                Tree-e embraces the power of simplicity and exploration. Like branches forming trees, individual thoughts combine to create complex ideas. Branch out to explore different paths and perspectives, creating a forest of interconnected knowledge.
                            </p>
                        </div>
                        
                        <div>
                            <h4 style={{ marginBottom: '0.5rem', fontSize: '1rem', fontWeight: '600' }}>Getting Started</h4>
                            <div style={{ fontFamily: 'JetBrains Mono, monospace', fontSize: '0.75rem', opacity: 0.9, lineHeight: 1.4 }}>
                                <div>• Start typing at the > prompt</div>
                                <div>• Tab to indent, Shift+Tab to outdent</div>
                                <div>• Swipe on input to adjust indent level</div>
                                <div>• Tap nodes to select and access actions</div>
                                <div>• Use Branch to explore thoughts in new trees</div>
                                <div>• Click breadcrumbs to navigate between trees</div>
                                <div>• Click "✓ Close" to merge changes back</div>
                                <div>• Use ⟲ button to sync trees and themes between devices</div>
                                <div>• Export button shares all trees as Markdown</div>
                                <div>• Export button shares all trees as Markdown</div>
                            </div>
                        </div>
                    </div>
                </Modal>

                {/* Sync Export Modal */}
                <Modal
                    isOpen={ui.showSyncExport}
                    onClose={() => updateUi({ showSyncExport: false, syncExportData: null, syncQRCode: null })}
                    title="📤 Export to Another Device"
                    theme={theme}
                >
                    {ui.syncExportData && (
                        <div style={{ display: 'flex', flexDirection: 'column', gap: '1rem' }}>
                            <div style={{ 
                                padding: '1rem', 
                                backgroundColor: getColorForLevel(theme, 1),
                                borderRadius: '6px',
                                border: `1px solid ${theme.border}`
                            }}>
                                <p style={{ marginBottom: '1rem', fontWeight: '500' }}>
                                    📱 Copy this data to your other device:
                                </p>
                                <textarea
                                    readOnly
                                    value={ui.syncExportData}
                                    style={{
                                        width: '100%',
                                        height: '150px',
                                        padding: '0.5rem',
                                        fontFamily: 'monospace',
                                        fontSize: '0.75rem',
                                        backgroundColor: theme.background,
                                        color: theme.text,
                                        border: `1px solid ${theme.border}`,
                                        borderRadius: '4px',
                                        resize: 'vertical'
                                    }}
                                />
                            </div>
                            
                            <div style={{ display: 'flex', gap: '0.5rem', justifyContent: 'space-between', flexWrap: 'wrap' }}>
                                <div style={{ display: 'flex', gap: '0.5rem' }}>
                                    <button
                                        onClick={() => copyToClipboard(ui.syncExportData)}
                                        style={{
                                            background: '#3b82f6',
                                            color: 'white',
                                            border: 'none',
                                            padding: '8px 16px',
                                            borderRadius: '6px',
                                            cursor: 'pointer',
                                            fontSize: '0.875rem'
                                        }}
                                    >
                                        📋 Copy
                                    </button>
                                    {navigator.share && (
                                        <button
                                            onClick={() => shareData(ui.syncExportData)}
                                            style={{
                                                background: '#22c55e',
                                                color: 'white',
                                                border: 'none',
                                                padding: '8px 16px',
                                                borderRadius: '6px',
                                                cursor: 'pointer',
                                                fontSize: '0.875rem'
                                            }}
                                        >
                                            📤 Share
                                        </button>
                                    )}
                                </div>
                                
                                <button
                                    onClick={() => generateQRCode(ui.syncExportData)}
                                    disabled={ui.qrGenerating}
                                    style={{
                                        background: ui.qrGenerating ? '#94a3b8' : '#8b5cf6',
                                        color: 'white',
                                        border: 'none',
                                        padding: '8px 16px',
                                        borderRadius: '6px',
                                        cursor: ui.qrGenerating ? 'not-allowed' : 'pointer',
                                        fontSize: '0.875rem'
                                    }}
                                >
                                    {ui.qrGenerating ? '⏳ Generating...' : '📱 QR Code'}
                                </button>
                            </div>

                            {/* QR Code Display */}
                            {ui.syncQRCode && (
                                <div 
                                    className="qr-display"
                                    style={{ 
                                        borderColor: theme.border,
                                        backgroundColor: getColorForLevel(theme, 0)
                                    }}
                                >
                                    <div className="qr-code">
                                        <img 
                                            src={ui.syncQRCode} 
                                            alt="QR Code for Tree-e sync"
                                            style={{ display: 'block' }}
                                        />
                                    </div>
                                    
                                    <div className="qr-instructions">
                                        <p style={{ marginBottom: '0.5rem', fontWeight: '500' }}>
                                            📱 Scan with your other device
                                        </p>
                                        <p style={{ fontSize: '0.75rem', opacity: 0.8 }}>
                                            Open Tree-e → ⟲ → Import Data → Use QR scanner or paste manually
                                        </p>
                                    </div>
                                </div>
                            )}
                            
                            <div style={{ fontSize: '0.75rem', opacity: 0.7, textAlign: 'center' }}>
                                Open Tree-e on your other device → ⟲ → Import Data → Paste or scan
                            </div>
                        </div>
                    )}
                </Modal>

                {/* Sync Import Modal */}
                <Modal
                    isOpen={ui.showSyncImport}
                    onClose={() => updateUi({ showSyncImport: false, syncImportData: '', syncImportError: null })}
                    title="📥 Import from Another Device"
                    theme={theme}
                >
                    <div style={{ display: 'flex', flexDirection: 'column', gap: '1rem' }}>
                        {ui.syncImportError && (
                            <div style={{ 
                                padding: '0.75rem', 
                                background: '#fef2f2', 
                                color: '#dc2626', 
                                borderRadius: '6px',
                                fontSize: '0.875rem'
                            }}>
                                ❌ {ui.syncImportError}
                            </div>
                        )}

                        <div>
                            <label style={{ display: 'block', marginBottom: '0.5rem', fontWeight: '500' }}>
                                Paste the export data from your other device:
                            </label>
                            <textarea
                                value={ui.syncImportData}
                                onChange={(e) => updateUi({ syncImportData: e.target.value, syncImportError: null })}
                                placeholder="Paste the JSON export data here, or scan QR code below..."
                                style={{
                                    width: '100%',
                                    height: '150px',
                                    padding: '0.5rem',
                                    fontFamily: 'monospace',
                                    fontSize: '0.75rem',
                                    backgroundColor: getColorForLevel(theme, 1),
                                    color: getTextColorForBackground(getColorForLevel(theme, 1)),
                                    border: `1px solid ${theme.border}`,
                                    borderRadius: '4px',
                                    resize: 'vertical'
                                }}
                            />
                        </div>

                        {/* QR Scanner option */}
                        <details style={{ marginTop: '0.5rem' }}>
                            <summary style={{ cursor: 'pointer', fontSize: '0.875rem', fontWeight: '500', marginBottom: '0.5rem' }}>
                                📱 Or scan QR code from camera
                            </summary>
                            <div style={{ 
                                padding: '1rem', 
                                border: `1px dashed ${theme.border}`, 
                                borderRadius: '6px',
                                textAlign: 'center'
                            }}>
                                <p style={{ fontSize: '0.875rem', marginBottom: '1rem', opacity: 0.8 }}>
                                    Click to start camera and scan QR code
                                </p>
                                <button
                                    onClick={() => {
                                        if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                                            // Simple camera access for QR scanning
                                            navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } })
                                                .then(() => {
                                                    alert('Camera access granted! Unfortunately, QR scanning requires additional setup. For now, please use the copy/paste method above.');
                                                })
                                                .catch(() => {
                                                    alert('Camera access denied. Please use the copy/paste method above.');
                                                });
                                        } else {
                                            alert('Camera not available. Please use the copy/paste method above.');
                                        }
                                    }}
                                    style={{
                                        background: '#8b5cf6',
                                        color: 'white',
                                        border: 'none',
                                        padding: '8px 16px',
                                        borderRadius: '6px',
                                        cursor: 'pointer',
                                        fontSize: '0.875rem'
                                    }}
                                >
                                    📷 Open Camera
                                </button>
                                <p style={{ fontSize: '0.75rem', marginTop: '0.5rem', opacity: 0.6 }}>
                                    Note: Full QR scanning coming soon. Copy/paste works perfectly for now!
                                </p>
                            </div>
                        </details>
                        
                        <div style={{ display: 'flex', gap: '0.5rem', justifyContent: 'flex-end' }}>
                            <button
                                onClick={() => updateUi({ showSyncImport: false, syncImportData: '', syncImportError: null })}
                                style={{
                                    background: theme.border,
                                    color: theme.text,
                                    border: 'none',
                                    padding: '8px 16px',
                                    borderRadius: '6px',
                                    cursor: 'pointer'
                                }}
                            >
                                Cancel
                            </button>
                            <button
                                onClick={processSyncImport}
                                disabled={!ui.syncImportData.trim()}
                                style={{
                                    background: ui.syncImportData.trim() ? '#22c55e' : '#94a3b8',
                                    color: 'white',
                                    border: 'none',
                                    padding: '8px 16px',
                                    borderRadius: '6px',
                                    cursor: ui.syncImportData.trim() ? 'pointer' : 'not-allowed'
                                }}
                            >
                                Import
                            </button>
                        </div>
                    </div>
                </Modal>

                <Modal
                    isOpen={!!ui.focusedNode}
                    onClose={() => updateUi({ focusedNode: null })}
                    title={`Notes: ${ui.focusedNode?.content || ''}`}
                    theme={theme}
                >
                    <textarea
                        className="note-editor"
                        value={ui.focusedNode?.note || ''}
                        onChange={(e) => updateUi({ 
                            focusedNode: { ...ui.focusedNode, note: e.target.value }
                        })}
                        placeholder="Add detailed notes for this node..."
                        style={{
                            backgroundColor: getColorForLevel(theme, 1),
                            borderColor: theme.border,
                            color: getTextColorForBackground(getColorForLevel(theme, 1))
                        }}
                    />
                    <div style={{ marginTop: '16px', display: 'flex', justifyContent: 'flex-end' }}>
                        <button
                            onClick={() => {
                                saveFocusNote(ui.focusedNode?.note || '');
                            }}
                            style={{
                                background: '#3b82f6',
                                color: 'white',
                                border: 'none',
                                padding: '8px 16px',
                                borderRadius: '6px',
                                cursor: 'pointer'
                            }}
                        >
                            Save & Close
                        </button>
                    </div>
                </Modal>

                <Modal 
                    isOpen={ui.showClearConfirm} 
                    onClose={() => updateUi({ showClearConfirm: false })} 
                    title={trees.length > 1 ? "Clear your entire forest?" : "Clear your garden?"} 
                    theme={theme}
                >
                    <div style={{ marginBottom: '16px' }}>
                        {trees.length > 1 ? 
                            "This will remove all your trees and every carefully cultivated thought. Your entire forest cannot be replanted once cleared." :
                            "This will remove all your carefully cultivated thoughts. They cannot be replanted once cleared."
                        }
                    </div>
                    <div style={{ display: 'flex', gap: '12px', justifyContent: 'flex-end' }}>
                        <button
                            onClick={() => updateUi({ showClearConfirm: false })}
                            style={{
                                background: theme.border,
                                color: theme.text,
                                border: 'none',
                                padding: '8px 16px',
                                borderRadius: '6px',
                                cursor: 'pointer'
                            }}
                        >
                            Cancel
                        </button>
                        <button
                            onClick={clearAll}
                            style={{
                                background: '#ef4444',
                                color: 'white',
                                border: 'none',
                                padding: '8px 16px',
                                borderRadius: '6px',
                                cursor: 'pointer'
                            }}
                        >
                            Clear All
                        </button>
                    </div>
                </Modal>

                <Modal
                    isOpen={ui.showLospecImport}
                    onClose={() => updateUi({ showLospecImport: false, lospecSlug: '', lospecPreview: null })}
                    title="Import Theme from Lospec"
                    theme={theme}
                >
                    <div style={{ display: 'flex', flexDirection: 'column', gap: '1rem' }}>
                        <div>
                            <label style={{ display: 'block', marginBottom: '0.5rem', fontSize: '0.875rem', fontWeight: '500' }}>
                                Palette Slug (from Lospec URL)
                            </label>
                            <div style={{ display: 'flex', gap: '0.5rem' }}>
                                <input
                                    type="text"
                                    value={ui.lospecSlug}
                                    onChange={(e) => updateUi({ lospecSlug: e.target.value })}
                                    placeholder="e.g., nintendo-gameboy-bgb"
                                    style={{
                                        flex: 1,
                                        padding: '8px 12px',
                                        border: `1px solid ${theme.border}`,
                                        borderRadius: '6px',
                                        backgroundColor: theme.background,
                                        color: theme.text,
                                        fontSize: '0.875rem'
                                    }}
                                    onKeyDown={(e) => {
                                        if (e.key === 'Enter') {
                                            previewLospecPalette();
                                        }
                                    }}
                                />
                                <button
                                    onClick={previewLospecPalette}
                                    disabled={ui.lospecLoading || !ui.lospecSlug.trim()}
                                    style={{
                                        background: '#3b82f6',
                                        color: 'white',
                                        border: 'none',
                                        padding: '8px 16px',
                                        borderRadius: '6px',
                                        cursor: ui.lospecLoading || !ui.lospecSlug.trim() ? 'not-allowed' : 'pointer',
                                        opacity: ui.lospecLoading || !ui.lospecSlug.trim() ? 0.5 : 1
                                    }}
                                >
                                    {ui.lospecLoading ? 'Loading...' : 'Preview'}
                                </button>
                            </div>
                            <div style={{ fontSize: '0.75rem', opacity: 0.7, marginTop: '0.5rem' }}>
                                Find palettes at <a href="https://lospec.com/palette-list" target="_blank" rel="noopener noreferrer" style={{ color: theme.prompt }}>lospec.com/palette-list</a>
                            </div>
                        </div>

                        {ui.lospecPreview && (
                            <div>
                                <h4 style={{ marginBottom: '0.5rem', fontSize: '1rem', fontWeight: '600' }}>
                                    Preview: {ui.lospecPreview.name}
                                </h4>
                                <div 
                                    style={{ 
                                        padding: '1rem', 
                                        borderRadius: '6px', 
                                        backgroundColor: ui.lospecPreview.background,
                                        color: ui.lospecPreview.text,
                                        border: `1px solid ${ui.lospecPreview.border}`
                                    }}
                                >
                                    <div style={{ marginBottom: '0.5rem', color: ui.lospecPreview.prompt, fontSize: '0.875rem', fontWeight: '500' }}>
                                        Sample Tree-e Theme
                                    </div>
                                    <div style={{ display: 'flex', gap: '4px', marginBottom: '0.5rem' }}>
                                        {ui.lospecPreview.levelColors.map((color, index) => (
                                            <div
                                                key={index}
                                                style={{
                                                    width: '24px',
                                                    height: '24px',
                                                    backgroundColor: color,
                                                    borderRadius: '4px',
                                                    border: `1px solid ${ui.lospecPreview.border}`
                                                }}
                                            />
                                        ))}
                                    </div>
                                    <div style={{ fontSize: '0.75rem', opacity: 0.8 }}>
                                        Level colors for hierarchy
                                    </div>
                                </div>

                                <div style={{ marginTop: '1rem', display: 'flex', gap: '12px', justifyContent: 'flex-end' }}>
                                    <button
                                        onClick={() => updateUi({ lospecPreview: null })}
                                        style={{
                                            background: theme.border,
                                            color: theme.text,
                                            border: 'none',
                                            padding: '8px 16px',
                                            borderRadius: '6px',
                                            cursor: 'pointer'
                                        }}
                                    >
                                        Back
                                    </button>
                                    <button
                                        onClick={importLospecTheme}
                                        style={{
                                            background: '#22c55e',
                                            color: 'white',
                                            border: 'none',
                                            padding: '8px 16px',
                                            borderRadius: '6px',
                                            cursor: 'pointer'
                                        }}
                                    >
                                        Import Theme
                                    </button>
                                </div>
                            </div>
                        )}
                    </div>
                </Modal>
            </div>
        );
    };

    ReactDOM.render(<TreeApp />, document.getElementById('root'));

    // Service Worker
    if ('serviceWorker' in navigator) {
        const swCode = `
            const CACHE_NAME = 'tree-e-v2';
            const urlsToCache = ['/', '/index.html'];

            self.addEventListener('install', event => {
                event.waitUntil(
                    caches.open(CACHE_NAME)
                        .then(cache => cache.addAll(urlsToCache))
                );
            });

            self.addEventListener('fetch', event => {
                event.respondWith(
                    caches.match(event.request)
                        .then(response => {
                            if (response) {
                                return response;
                            }
                            return fetch(event.request);
                        })
                );
            });
        `;
        
        const blob = new Blob([swCode], { type: 'application/javascript' });
        const swUrl = URL.createObjectURL(blob);
        
        navigator.serviceWorker.register(swUrl)
            .then(registration => {
                console.log('SW registered: ', registration);
            })
            .catch(registrationError => {
                console.log('SW registration failed: ', registrationError);
            });
    }
</script>

</body>
</html>
