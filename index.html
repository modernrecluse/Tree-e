<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tree-e - Hierarchical Note Taking</title>


<!-- PWA Meta Tags -->
<meta name="description" content="Tree-e: Hierarchical note-taking app with beautiful themes">
<meta name="theme-color" content="#e9f5e9">
<link rel="manifest" href="data:application/json;base64,eyJuYW1lIjoiVHJlZS1lIiwic2hvcnRfbmFtZSI6IlRyZWUtZSIsImRpc3BsYXkiOiJzdGFuZGFsb25lIiwic3RhcnRfdXJsIjoiLyIsInRoZW1lX2NvbG9yIjoiI2U5ZjVlOSIsImJhY2tncm91bmRfY29sb3IiOiIjZTlmNWU5IiwiaWNvbnMiOlt7InNyYyI6ImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIWnBaWGRDYjNnOUlqQWdNQ0F4TWpnZ01USTRMQ0lqSURFeU9DQXhNamt6TGpFMWNpNGhMU0lnWm1sc2JEMGlJek5tWm1NeVlpSStQR04xY21ObElDOStQSEJoZEdnZ1pEMGlUVEkxSURjMElHTnNhWEJRWVhSb1BDOWpkWEpqYkdVK1BHTnBjbU5zWlNCamVEMGlObVFpSUdONVBTSTJaQ0lnY2owNU1pd2dOUGdnTWpOa01EWk1OUzhpSUdac2JIcGJKVGMwT1RVaU5qWWlQand2WTJseVkyeGxQanh6ZEhKdmEyVWdkMmxrZEdnOVlqTWlJR2hsYVdkb2REMGlOakkwSWlCamIyeDFjeWNpSWlCelpubHNaVDBpZDBsa1lXWGtPVFprWnpBaE1qQXNPREkyWklCMFpXMWpkVDRpSUhCdlpXbHVkR2s5VGpFa2NTSXZQanczSWo0OEwzTjJaejQ9IiwidHlwZSI6ImltYWdlL3N2Zyt4bWwiLCJzaXplcyI6IjEyOHgxMjgifV19">

<!-- React and Babel -->
<script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
<script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
<script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>

<!-- Fonts -->
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">

<style>
    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
    }
    
    body {
        font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        touch-action: manipulation;
        user-select: none;
        -webkit-user-select: none;
        -webkit-tap-highlight-color: transparent;
        overflow-x: hidden;
        font-size: 16px;
    }
    
    .app {
        height: 100vh;
        height: calc(var(--vh, 1vh) * 100);
        display: flex;
        flex-direction: column;
        overflow: hidden;
        min-width: 320px;
    }
    
    .header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 1rem;
        gap: 0.75rem;
        flex-shrink: 0;
        border-bottom: 1px solid rgba(0,0,0,0.1);
        min-height: 60px;
    }
    
    .header h1 {
        font-size: clamp(1.125rem, 4vw, 1.25rem);
        font-weight: 600;
        margin: 0;
        flex-shrink: 0;
    }
    
    .header-controls {
        display: flex;
        gap: clamp(0.5rem, 2vw, 0.75rem);
        flex-wrap: wrap;
        justify-content: flex-end;
    }
    
    .control-btn {
        width: clamp(32px, 8vw, 40px);
        height: clamp(32px, 8vw, 40px);
        border: none;
        border-radius: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: clamp(0.875rem, 3vw, 1rem);
        cursor: pointer;
        transition: all 0.2s ease;
        border: 1px solid;
        background: white;
        flex-shrink: 0;
    }
    
    .control-btn:hover {
        transform: scale(1.05);
    }
    
    .control-btn:disabled {
        opacity: 0.4;
        cursor: not-allowed;
        transform: none;
    }
    
    .main-content {
        flex: 1;
        overflow-y: auto;
        overflow-x: hidden;
        padding: clamp(0.75rem, 3vw, 1rem);
        scroll-behavior: smooth;
        min-height: 0; /* Critical for flex child scrolling */
    }
    
    .nodes-container {
        display: flex;
        flex-direction: column;
        gap: clamp(0.75rem, 3vw, 0.75rem);
        min-height: min-content;
        width: 100%;
        max-width: none;
        padding-bottom: clamp(1rem, 4vw, 2rem); /* Add bottom padding for better scrolling */
    }
    
    .node {
        display: flex;
        align-items: flex-start;
        gap: 0;
        position: relative;
    }
    
    .node-indentation {
        display: flex;
        flex-shrink: 0;
    }
    
    .indent-spacer {
        width: clamp(20px, 5vw, 24px);
    }
    
    .node-content-wrapper {
        display: flex;
        flex-direction: column;
        align-items: flex-start;
    }
    
    .node-content {
        padding: 12px 16px;
        border-radius: 8px;
        border: 1px solid;
        cursor: pointer;
        transition: all 0.3s ease;
        display: inline-flex;
        align-items: center;
        gap: 12px;
        min-width: 80px;
        max-width: calc(100vw - 32px);
        width: auto;
        transform-origin: center;
        word-wrap: break-word;
        overflow-wrap: break-word;
    }
    
    .node-content:hover {
        transform: scale(1.02);
    }
    
    .node-content.selected {
        border-width: 2px;
    }
    
    .node-content.completed {
        opacity: 0.6;
    }
    
    .node-content.new {
        animation: nodeAppear 0.3s ease-out;
    }
    
    @keyframes nodeAppear {
        from {
            opacity: 0;
            transform: scale(0.95);
        }
        to {
            opacity: 1;
            transform: scale(1);
        }
    }
    
    .task-toggle {
        font-size: 18px;
        cursor: pointer;
        transition: color 0.2s ease;
    }
    
    .node-text {
        font-size: 16px;
        line-height: 1.4;
        max-width: 280px;
        word-wrap: break-word;
        overflow-wrap: break-word;
        hyphens: auto;
    }
    
    .node-text.completed {
        text-decoration: line-through;
    }
    
    .node-icons {
        display: flex;
        gap: 4px;
        font-size: 14px;
    }
    
    .node-actions {
        display: flex;
        gap: 8px;
        margin-top: 8px;
        flex-wrap: wrap;
        width: auto;
        min-width: fit-content;
    }
    
    .action-btn {
        display: flex;
        align-items: center;
        gap: 4px;
        padding: 6px 12px;
        border: none;
        border-radius: 6px;
        font-size: 12px;
        color: white;
        cursor: pointer;
        transition: all 0.2s ease;
    }
    
    .action-btn:hover {
        transform: scale(1.05);
    }
    
    .action-btn.task { background: #22c55e; }
    .action-btn.focus { background: #3b82f6; }
    .action-btn.link { background: #a855f7; }
    .action-btn.unlink { background: #f97316; }
    .action-btn.delete { background: #ef4444; }
    
    .input-area {
        flex-shrink: 0;
        padding: 16px;
        border-top: 1px solid rgba(0,0,0,0.1);
        background: inherit;
    }
    
    .indent-controls {
        display: flex;
        gap: 16px;
        justify-content: center;
        margin-bottom: 12px;
    }
    
    .indent-btn {
        display: flex;
        align-items: center;
        gap: 4px;
        padding: 8px 16px;
        border: 1px solid;
        border-radius: 8px;
        font-size: 14px;
        cursor: pointer;
        transition: all 0.2s ease;
    }
    
    .indent-btn:hover {
        transform: scale(1.05);
    }
    
    .indent-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none;
    }
    
    .input-container {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 12px 16px;
        border: 1px solid;
        border-radius: 12px;
        background: inherit;
    }
    
    .input-prompt {
        font-family: 'JetBrains Mono', monospace;
        font-size: 24px;
        font-weight: 500;
    }
    
    .indent-indicator {
        font-family: 'JetBrains Mono', monospace;
        font-size: 14px;
        opacity: 0.6;
    }
    
    .main-input {
        flex: 1;
        border: none;
        outline: none;
        background: transparent;
        font-family: 'JetBrains Mono', monospace;
        font-size: 18px;
        color: inherit;
    }
    
    .main-input::placeholder {
        color: inherit;
        opacity: 0.6;
    }
    
    .context-indicator {
        margin-top: 12px;
        padding: 8px 16px;
        border: 1px solid;
        border-radius: 8px;
        font-family: 'JetBrains Mono', monospace;
        font-size: 12px;
        opacity: 0.9;
        text-align: center;
    }
    
    .instructions {
        margin-top: 12px;
        font-family: 'JetBrains Mono', monospace;
        font-size: 12px;
        opacity: 0.6;
        text-align: center;
        line-height: 1.4;
    }
    
    .modal {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0,0,0,0.5);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000;
        padding: 20px;
    }
    
    .modal-content {
        width: 100%;
        max-width: 500px;
        max-height: 80vh;
        border-radius: 12px;
        overflow: hidden;
        display: flex;
        flex-direction: column;
    }
    
    .modal-header {
        padding: 16px;
        border-bottom: 1px solid rgba(0,0,0,0.1);
        display: flex;
        align-items: center;
        justify-content: space-between;
    }
    
    .modal-title {
        font-size: 18px;
        font-weight: 600;
        margin: 0;
    }
    
    .modal-close {
        background: none;
        border: none;
        font-size: 16px;
        cursor: pointer;
        padding: 4px;
    }
    
    .modal-body {
        flex: 1;
        overflow-y: auto;
        padding: 16px;
    }
    
    .note-editor {
        width: 100%;
        min-height: 200px;
        padding: 12px;
        border: 1px solid rgba(0,0,0,0.2);
        border-radius: 8px;
        font-size: 16px;
        font-family: inherit;
        background: inherit;
        color: inherit;
        resize: vertical;
    }
    
    .link-list {
        display: flex;
        flex-direction: column;
        gap: 12px;
    }
    
    .link-item {
        display: flex;
        align-items: center;
        padding: 12px 16px;
        border: 1px solid;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.2s ease;
        background: inherit;
        color: inherit;
        text-align: left;
        width: 100%;
    }
    
    .link-item:hover {
        transform: scale(1.02);
    }
    
    .link-item-content {
        flex: 1;
        display: flex;
        align-items: center;
        gap: 8px;
    }
    
    .link-chevron {
        opacity: 0.6;
        font-size: 14px;
    }
    
    .about-content {
        display: flex;
        flex-direction: column;
        gap: clamp(1.25rem, 5vw, 1.25rem);
    }
    
    .about-section {
        display: flex;
        flex-direction: column;
        gap: clamp(0.75rem, 3vw, 0.75rem);
    }
    
    .about-title {
        font-size: clamp(1.125rem, 5vw, 1.25rem);
        font-weight: 600;
        margin: 0;
    }
    
    .about-text {
        line-height: 1.6;
        opacity: 0.9;
        font-size: clamp(0.875rem, 4vw, 1rem);
    }
    
    .feature-list {
        display: flex;
        flex-direction: column;
        gap: clamp(0.5rem, 2vw, 0.5rem);
    }
    
    .feature-item {
        display: flex;
        flex-direction: column;
        gap: 2px;
    }
    
    .feature-title {
        font-weight: 500;
        font-size: clamp(0.875rem, 4vw, 1rem);
    }
    
    .feature-desc {
        opacity: 0.9;
        font-size: clamp(0.75rem, 3vw, 0.875rem);
    }
    
    .getting-started-list {
        font-family: 'JetBrains Mono', monospace;
        font-size: clamp(0.75rem, 3vw, 0.875rem);
        opacity: 0.9;
        line-height: 1.4;
    }
    
    .getting-started-list div {
        margin-bottom: 2px;
    }
    
    .empty-state {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: clamp(1rem, 4vw, 1rem);
        padding: clamp(2.5rem, 8vw, 2.5rem) clamp(1.25rem, 5vw, 1.25rem);
        text-align: center;
    }
    
    .empty-icon {
        font-size: clamp(2.5rem, 10vw, 3rem);
        opacity: 0.6;
    }
    
    .empty-title {
        font-size: clamp(1rem, 4vw, 1.125rem);
        font-weight: 500;
    }
    
    .empty-desc {
        font-size: clamp(0.75rem, 3vw, 0.875rem);
        opacity: 0.7;
        line-height: 1.4;
    }
    
    .dropdown {
        position: relative;
        display: inline-block;
    }
    
    .dropdown-content {
        position: absolute;
        top: 100%;
        right: 0;
        background: white;
        border: 1px solid #ccc;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        z-index: 100;
        min-width: clamp(120px, 30vw, 160px);
        max-height: 300px;
        overflow-y: auto;
    }
    
    .dropdown-item {
        padding: clamp(0.75rem, 3vw, 0.75rem) clamp(0.875rem, 4vw, 1rem);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: space-between;
        transition: background 0.2s ease;
        border: none;
        background: none;
        width: 100%;
        text-align: left;
        font-size: clamp(0.75rem, 3vw, 0.875rem);
    }
    
    .dropdown-item:hover {
        background: rgba(0,0,0,0.05);
    }
    
    /* Simplified responsive adjustments */
    @media (max-width: 600px) {
        .action-btn span {
            display: none;
        }
        
        .header-controls {
            gap: 0.5rem;
        }
        
        .node-text {
            max-width: calc(100vw - 6rem);
        }
        
        /* Better mobile keyboard handling */
        .app {
            height: calc(var(--vh, 1vh) * 100);
        }
    }
    
    @media (max-width: 360px) {
        .indent-controls {
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
        }
        
        .node-text {
            max-width: calc(100vw - 4rem);
        }
    }
</style>


</head>
<body>
    <div id="root"></div>


<script type="text/babel">
    const { useState, useEffect, useRef, useCallback } = React;

    // Theme definitions
    const themes = {
        matcha: {
            name: 'Matcha',
            background: '#e9f5e9',
            text: '#2e4a2e',
            prompt: '#59784a',
            border: '#c4d6c4',
            levelColors: ['#f0f8f0', '#ddf2dd', '#ccedcc', '#bae8ba', '#a9e3a9']
        },
        latte: {
            name: 'Latte',
            background: '#f5f0e9',
            text: '#4a3e2e',
            prompt: '#7a6b59',
            border: '#d6ccc4',
            levelColors: ['#f8f5f0', '#edebdd', '#e3dccc', '#d9cfba', '#cfc2a9']
        },
        ocean: {
            name: 'Ocean',
            background: '#e9f0f5',
            text: '#2e3e4a',
            prompt: '#596b7a',
            border: '#c4ccd6',
            levelColors: ['#f0f5f8', '#ddebf2', '#ccddec', '#bacfe8', '#a9c2e3']
        },
        midnight: {
            name: 'Midnight',
            background: '#0f0f24',
            text: '#e1e1e1',
            prompt: '#8c8c8c',
            border: '#2e2e45',
            levelColors: ['#1a1a2e', '#24243a', '#2e2e42', '#38384e', '#424256']
        },
        chess: {
            name: 'Chess',
            background: '#f7f7f7',
            text: '#1a1a1a',
            prompt: '#666666',
            border: '#e1e1e1',
            levelColors: ['#ffffff', '#f5f5f5', '#ebebeb', '#e1e1e1', '#d7d7d7']
        },
        espresso: {
            name: 'Espresso',
            background: '#2b1710',
            text: '#e8d7c4',
            prompt: '#b89470',
            border: '#5c3d29',
            levelColors: ['#3d241a', '#4d2e21', '#5c3829', '#6b4230', '#7a4c37']
        },
        alienGuts: {
            name: 'Alien Guts',
            background: '#141f14',
            text: '#d9f2bf',
            prompt: '#99cc80',
            border: '#66994d',
            levelColors: ['#33cc4d', '#9933cc', '#cc9933', '#3399cc', '#cc3366']
        },
        neon: {
            name: 'Neon',
            background: '#0d0d26',
            text: '#1a1a1a',
            prompt: '#cccccc',
            border: '#666699',
            levelColors: ['#ff3399', '#33ff99', '#ff9933', '#9933ff', '#33b3ff']
        }
    };

    // Utility functions
    const generateId = () => {
        return Date.now().toString(36) + Math.random().toString(36).substr(2);
    };

    const getColorForLevel = (theme, level) => {
        if (level < theme.levelColors.length) {
            return theme.levelColors[level];
        } else {
            const baseColorIndex = level % theme.levelColors.length;
            return theme.levelColors[baseColorIndex] + '80'; // Add transparency for deeper levels
        }
    };

    // Storage utilities
    const saveToStorage = (nodes) => {
        try {
            localStorage.setItem('tree-e-nodes', JSON.stringify(nodes));
        } catch (error) {
            console.error('Failed to save nodes:', error);
        }
    };

    const loadFromStorage = () => {
        try {
            const saved = localStorage.getItem('tree-e-nodes');
            return saved ? JSON.parse(saved) : [];
        } catch (error) {
            console.error('Failed to load nodes:', error);
            return [];
        }
    };

    const saveThemeToStorage = (themeName) => {
        try {
            localStorage.setItem('tree-e-theme', themeName);
        } catch (error) {
            console.error('Failed to save theme:', error);
        }
    };

    const loadThemeFromStorage = () => {
        try {
            const saved = localStorage.getItem('tree-e-theme');
            return saved || 'matcha';
        } catch (error) {
            console.error('Failed to load theme:', error);
            return 'matcha';
        }
    };

    // Touch handling utilities
    const useTouchHandler = (onSwipeLeft, onSwipeRight, threshold = 50) => {
        const touchStart = useRef(null);
        const touchEnd = useRef(null);

        const onTouchStart = (e) => {
            touchEnd.current = null;
            touchStart.current = e.targetTouches[0].clientX;
        };

        const onTouchMove = (e) => {
            touchEnd.current = e.targetTouches[0].clientX;
        };

        const onTouchEnd = () => {
            if (!touchStart.current || !touchEnd.current) return;
            
            const distance = touchStart.current - touchEnd.current;
            const isLeftSwipe = distance > threshold;
            const isRightSwipe = distance < -threshold;

            if (isLeftSwipe && onSwipeLeft) {
                onSwipeLeft();
            }
            if (isRightSwipe && onSwipeRight) {
                onSwipeRight();
            }
        };

        return {
            onTouchStart,
            onTouchMove,
            onTouchEnd
        };
    };

    // Components
    const NodeComponent = ({ node, theme, isSelected, onTap, onIndent, onOutdent, onDelete, onFocus, onToggleTask, onToggleComplete, onLink, onUnlink, onJumpToLink }) => {
        const swipeHandlers = useTouchHandler(onOutdent, onIndent);

        return (
            <div className="node">
                <div className="node-indentation">
                    {Array.from({ length: node.level }, (_, i) => (
                        <div key={i} className="indent-spacer" />
                    ))}
                </div>
                
                <div className="node-content-wrapper">
                    <div 
                        className={`node-content ${isSelected ? 'selected' : ''} ${node.isTask && node.isCompleted ? 'completed' : ''} ${node.isNew ? 'new' : ''}`}
                        style={{
                            backgroundColor: isSelected ? theme.border : getColorForLevel(theme, node.level),
                            borderColor: isSelected ? theme.text : theme.border,
                            color: theme.text
                        }}
                        onClick={(e) => onTap(e)}
                        {...swipeHandlers}
                    >
                        {node.isTask && (
                            <div 
                                className="task-toggle" 
                                onClick={(e) => {
                                    e.stopPropagation();
                                    onToggleComplete();
                                }}
                                style={{ color: node.isCompleted ? '#22c55e' : theme.text + '99' }}
                            >
                                {node.isCompleted ? '‚òë' : '‚òê'}
                            </div>
                        )}
                        
                        <div className={`node-text ${node.isTask && node.isCompleted ? 'completed' : ''}`}>
                            {node.content}
                        </div>
                        
                        <div className="node-icons" style={{ color: theme.text + '99' }}>
                            {node.isTask && <span>‚òê</span>}
                            {node.note && node.note.trim() && <span>‚úé</span>}
                            {node.linkedNodeId && (
                                <span 
                                    onClick={(e) => {
                                        e.stopPropagation();
                                        onJumpToLink();
                                    }}
                                    style={{ color: '#3b82f6', cursor: 'pointer' }}
                                >
                                    ‚áó
                                </span>
                            )}
                        </div>
                    </div>
                    
                    {isSelected && (
                        <div className="node-actions">
                            <button className="action-btn task" onClick={onToggleTask}>
                                ‚òê <span>{node.isTask ? 'Note' : 'Task'}</span>
                            </button>
                            <button className="action-btn focus" onClick={onFocus}>
                                ‚úé <span>Notes</span>
                            </button>
                            {node.linkedNodeId ? (
                                <button className="action-btn unlink" onClick={onUnlink}>
                                    ‚õì <span>Unlink</span>
                                </button>
                            ) : (
                                <button className="action-btn link" onClick={onLink}>
                                    ‚õì <span>Link</span>
                                </button>
                            )}
                            <button className="action-btn delete" onClick={onDelete}>
                                ‚úï <span>Delete</span>
                            </button>
                        </div>
                    )}
                </div>
            </div>
        );
    };

    const Modal = ({ isOpen, onClose, title, children, theme }) => {
        if (!isOpen) return null;

        return (
            <div className="modal" onClick={onClose}>
                <div 
                    className="modal-content" 
                    style={{ backgroundColor: theme.background, color: theme.text }}
                    onClick={(e) => e.stopPropagation()}
                >
                    <div className="modal-header" style={{ borderColor: theme.border }}>
                        <h3 className="modal-title">{title}</h3>
                        <button 
                            className="modal-close" 
                            onClick={onClose}
                            style={{ color: theme.text }}
                        >
                            ‚úï
                        </button>
                    </div>
                    <div className="modal-body">
                        {children}
                    </div>
                </div>
            </div>
        );
    };

    const FocusView = ({ isOpen, onClose, node, theme, onSave }) => {
        const [note, setNote] = useState(node?.note || '');

        useEffect(() => {
            setNote(node?.note || '');
        }, [node]);

        const handleSave = () => {
            onSave(note);
            onClose();
        };

        return (
            <Modal isOpen={isOpen} onClose={handleSave} title={`Notes: ${node?.content || ''}`} theme={theme}>
                <textarea
                    className="note-editor"
                    value={note}
                    onChange={(e) => setNote(e.target.value)}
                    placeholder="Add detailed notes for this node..."
                    style={{
                        backgroundColor: getColorForLevel(theme, 1),
                        borderColor: theme.border,
                        color: theme.text
                    }}
                />
                <div style={{ marginTop: '16px', display: 'flex', justifyContent: 'flex-end' }}>
                    <button
                        onClick={handleSave}
                        style={{
                            background: '#3b82f6',
                            color: 'white',
                            border: 'none',
                            padding: '8px 16px',
                            borderRadius: '6px',
                            cursor: 'pointer'
                        }}
                    >
                        Save & Close
                    </button>
                </div>
            </Modal>
        );
    };

    const LinkPickerView = ({ isOpen, onClose, nodes, fromNodeId, theme, onLink }) => {
        const availableNodes = nodes.filter(node => node.id !== fromNodeId);

        return (
            <Modal isOpen={isOpen} onClose={onClose} title="Link to Node" theme={theme}>
                {availableNodes.length === 0 ? (
                    <div className="empty-state">
                        <div className="empty-icon">üîó</div>
                        <div className="empty-title">No other nodes to link to</div>
                        <div className="empty-desc">
                            Create more nodes to build connections between your thoughts.
                        </div>
                    </div>
                ) : (
                    <div className="link-list">
                        {availableNodes.map(node => (
                            <button
                                key={node.id}
                                className="link-item"
                                onClick={() => {
                                    onLink(node.id);
                                    onClose();
                                }}
                                style={{
                                    backgroundColor: getColorForLevel(theme, node.level),
                                    borderColor: theme.border,
                                    color: theme.text
                                }}
                            >
                                <div className="link-item-content">
                                    <span style={{ fontFamily: 'JetBrains Mono, monospace' }}>
                                        {'  '.repeat(node.level)}
                                    </span>
                                    <span>{node.content}</span>
                                </div>
                                <span className="link-chevron">‚á®</span>
                            </button>
                        ))}
                    </div>
                )}
            </Modal>
        );
    };

    const AboutView = ({ isOpen, onClose, theme }) => {
        return (
            <Modal isOpen={isOpen} onClose={onClose} title="About Tree-e" theme={theme}>
                <div className="about-content">
                    <div className="about-section">
                        <h4 className="about-title">The Philosophy</h4>
                        <p className="about-text">
                            Tree-e embraces the power of simplicity. Like branches forming trees, individual thoughts combine to create complex ideas. This minimalist approach lets you capture ideas quickly, organize them naturally, and let meaningful connections emerge organically.
                        </p>
                    </div>
                    
                    <div className="about-section">
                        <h4 className="about-title">Core Features</h4>
                        <div className="feature-list">
                            <div className="feature-item">
                                <div className="feature-title">Hierarchical Thinking:</div>
                                <div className="feature-desc">Use swipe gestures to create natural thought structures with color-coded levels.</div>
                            </div>
                            <div className="feature-item">
                                <div className="feature-title">Focus Mode:</div>
                                <div className="feature-desc">Tap the Notes button to dive deep into any node with detailed notes.</div>
                            </div>
                            <div className="feature-item">
                                <div className="feature-title">Task Management:</div>
                                <div className="feature-desc">Convert any node to a task with completion tracking.</div>
                            </div>
                            <div className="feature-item">
                                <div className="feature-title">Simple Linking:</div>
                                <div className="feature-desc">Create connections between related thoughts with visual indicators.</div>
                            </div>
                            <div className="feature-item">
                                <div className="feature-title">Stunning Themes:</div>
                                <div className="feature-desc">Choose from 8 beautiful themes including the wild Alien Guts and electric Neon.</div>
                            </div>
                        </div>
                    </div>
                    
                    <div className="about-section">
                        <h4 className="about-title">Getting Started</h4>
                        <div className="getting-started-list">
                            <div>‚Ä¢ Start typing at the > prompt</div>
                            <div>‚Ä¢ Swipe right to indent, left to outdent</div>
                            <div>‚Ä¢ Swipe on input box to adjust indent level</div>
                            <div>‚Ä¢ Notice how each level gets its own color</div>
                            <div>‚Ä¢ Tap nodes to access edit options</div>
                            <div>‚Ä¢ Use Notes to add detailed information</div>
                            <div>‚Ä¢ Use Link to connect related thoughts</div>
                            <div>‚Ä¢ Export button shares as Markdown</div>
                            <div>‚Ä¢ Your work auto-saves as you create</div>
                            <div>‚Ä¢ Use the checkmark button for manual save</div>
                        </div>
                    </div>
                </div>
            </Modal>
        );
    };

    const ThemeDropdown = ({ currentTheme, onThemeChange, isOpen, onToggle, theme }) => {
        return (
            <div className="dropdown">
                <button 
                    className="control-btn"
                    onClick={onToggle}
                    style={{
                        backgroundColor: getColorForLevel(theme, 0),
                        borderColor: theme.border,
                        color: theme.text
                    }}
                >
                    ‚öô
                </button>
                {isOpen && (
                    <div className="dropdown-content">
                        {Object.entries(themes).map(([key, themeOption]) => (
                            <button
                                key={key}
                                className="dropdown-item"
                                onClick={() => {
                                    onThemeChange(key);
                                    onToggle();
                                }}
                            >
                                <span>{themeOption.name}</span>
                                {currentTheme === key && <span>‚òÖ</span>}
                            </button>
                        ))}
                    </div>
                )}
            </div>
        );
    };

    const MarkdownView = ({ markdown, theme, onDownload }) => {
        return (
            <div style={{ 
                display: 'flex',
                flexDirection: 'column',
                flex: 1,
                overflow: 'hidden'
            }}>
                {/* Download button */}
                <div style={{
                    padding: 'clamp(0.75rem, 3vw, 1rem)',
                    borderBottom: `1px solid ${theme.border}`,
                    display: 'flex',
                    justifyContent: 'flex-end'
                }}>
                    <button
                        onClick={onDownload}
                        style={{
                            background: theme.text,
                            color: theme.background,
                            border: 'none',
                            padding: 'clamp(0.5rem, 2vw, 0.5rem) clamp(0.75rem, 3vw, 1rem)',
                            borderRadius: '6px',
                            fontSize: 'clamp(0.75rem, 3vw, 0.875rem)',
                            cursor: 'pointer',
                            display: 'flex',
                            alignItems: 'center',
                            gap: '0.5rem'
                        }}
                    >
                        ‚¨á Download MD
                    </button>
                </div>
                
                {/* Markdown content */}
                <div style={{ 
                    flex: 1, 
                    overflow: 'auto', 
                    padding: 'clamp(0.75rem, 3vw, 1rem)',
                    fontFamily: 'JetBrains Mono, monospace',
                    whiteSpace: 'pre-wrap',
                    lineHeight: 1.6,
                    fontSize: 'clamp(0.75rem, 3vw, 0.875rem)',
                    color: theme.text
                }}>
                    {markdown || 'No content to display'}
                </div>
            </div>
        );
    };

    // Main App Component
    const TreeApp = () => {
        // State
        const [nodes, setNodes] = useState([]);
        const [currentInput, setCurrentInput] = useState('');
        const [currentIndentLevel, setCurrentIndentLevel] = useState(0);
        const [selectedNodeId, setSelectedNodeId] = useState(null);
        const [focusedNode, setFocusedNode] = useState(null);
        const [currentTheme, setCurrentTheme] = useState('matcha');
        const [showAbout, setShowAbout] = useState(false);
        const [showLinkPicker, setShowLinkPicker] = useState(false);
        const [linkingFromNodeId, setLinkingFromNodeId] = useState(null);
        const [showThemeDropdown, setShowThemeDropdown] = useState(false);
        const [isInputFocused, setIsInputFocused] = useState(false);
        const [showMarkdownView, setShowMarkdownView] = useState(false);
        const [showClearConfirm, setShowClearConfirm] = useState(false);

        const inputRef = useRef(null);
        const nodesContainerRef = useRef(null);
        const maintainFocus = useRef(true); // Track if we should maintain focus

        // Load data on mount
        useEffect(() => {
            setNodes(loadFromStorage());
            setCurrentTheme(loadThemeFromStorage());
            
            // Auto-focus on mount
            setTimeout(() => {
                if (inputRef.current) {
                    inputRef.current.focus();
                    maintainFocus.current = true;
                }
            }, 500);
        }, []);

        // Auto-save when nodes change
        useEffect(() => {
            saveToStorage(nodes);
        }, [nodes]);

        // Save theme when it changes
        useEffect(() => {
            saveThemeToStorage(currentTheme);
        }, [currentTheme]);

        const theme = themes[currentTheme];

        // Touch handlers for input area
        const inputSwipeHandlers = useTouchHandler(
            () => setCurrentIndentLevel(prev => Math.max(0, prev - 1)),
            () => setCurrentIndentLevel(prev => prev + 1)
        );

        // Functions
        const addNode = () => {
            const content = currentInput.trim();
            if (!content) return;

            let insertIndex = nodes.length;
            let newLevel = currentIndentLevel;

            // If there's a selected node, insert as its child
            if (selectedNodeId) {
                const selectedNode = nodes.find(node => node.id === selectedNodeId);
                const selectedIndex = nodes.findIndex(node => node.id === selectedNodeId);
                
                if (selectedNode !== undefined && selectedIndex !== -1) {
                    newLevel = selectedNode.level + 1;
                    
                    // Find where to insert - after the selected node and all its children
                    let insertAfterIndex = selectedIndex;
                    
                    // Look for all children of the selected node
                    for (let i = selectedIndex + 1; i < nodes.length; i++) {
                        if (nodes[i].level > selectedNode.level) {
                            // This is a child/descendant of the selected node
                            insertAfterIndex = i;
                        } else {
                            // We've reached a sibling or parent level, stop here
                            break;
                        }
                    }
                    
                    // Insert right after the last child (or the selected node if no children)
                    insertIndex = insertAfterIndex + 1;
                }
            }

            const newNode = {
                id: generateId(),
                content,
                level: newLevel,
                note: '',
                linkedNodeId: null,
                isTask: false,
                isCompleted: false,
                isNew: true
            };

            const newNodes = [...nodes];
            newNodes.splice(insertIndex, 0, newNode);
            setNodes(newNodes);
            setCurrentInput('');
            setCurrentIndentLevel(newLevel);

            // Remove isNew flag after animation
            setTimeout(() => {
                setNodes(prev => prev.map(node => 
                    node.id === newNode.id ? { ...node, isNew: false } : node
                ));
            }, 300);

            // Scroll to new node in the main content area
            setTimeout(() => {
                const nodeElement = document.querySelector(`[data-node-id="${newNode.id}"]`);
                if (nodeElement && nodesContainerRef.current) {
                    nodeElement.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }
            }, 100);
        };

        const deleteNode = (nodeId) => {
            setNodes(prev => prev.filter(node => node.id !== nodeId));
            if (selectedNodeId === nodeId) {
                setSelectedNodeId(null);
            }
        };

        const indentNode = (nodeId) => {
            setNodes(prev => prev.map(node =>
                node.id === nodeId ? { ...node, level: node.level + 1 } : node
            ));
            setSelectedNodeId(null);
        };

        const outdentNode = (nodeId) => {
            setNodes(prev => prev.map(node =>
                node.id === nodeId ? { ...node, level: Math.max(0, node.level - 1) } : node
            ));
            setSelectedNodeId(null);
        };

        const toggleTask = (nodeId) => {
            setNodes(prev => prev.map(node =>
                node.id === nodeId ? { ...node, isTask: !node.isTask, isCompleted: false } : node
            ));
            setSelectedNodeId(null);
        };

        const toggleComplete = (nodeId) => {
            setNodes(prev => prev.map(node =>
                node.id === nodeId ? { ...node, isCompleted: !node.isCompleted } : node
            ));
        };

        const focusNode = (nodeId) => {
            const node = nodes.find(n => n.id === nodeId);
            if (node) {
                setFocusedNode(node);
            }
            setSelectedNodeId(null);
        };

        const saveFocusNote = (note) => {
            if (focusedNode) {
                setNodes(prev => prev.map(node =>
                    node.id === focusedNode.id ? { ...node, note } : node
                ));
            }
            setFocusedNode(null);
        };

        const startLinking = (nodeId) => {
            setLinkingFromNodeId(nodeId);
            setShowLinkPicker(true);
            setSelectedNodeId(null);
        };

        const linkNodes = (targetNodeId) => {
            if (linkingFromNodeId) {
                setNodes(prev => prev.map(node =>
                    node.id === linkingFromNodeId ? { ...node, linkedNodeId: targetNodeId } : node
                ));
            }
            setShowLinkPicker(false);
            setLinkingFromNodeId(null);
        };

        const unlinkNode = (nodeId) => {
            setNodes(prev => prev.map(node =>
                node.id === nodeId ? { ...node, linkedNodeId: null } : node
            ));
            setSelectedNodeId(null);
        };

        const jumpToLinkedNode = (nodeId) => {
            const node = nodes.find(n => n.id === nodeId);
            if (node?.linkedNodeId) {
                setSelectedNodeId(node.linkedNodeId);
                
                // Scroll to linked node
                setTimeout(() => {
                    const element = document.querySelector(`[data-node-id="${node.linkedNodeId}"]`);
                    if (element) {
                        element.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                }, 100);
            }
        };

        const generateMarkdown = () => {
            return nodes.map(node => {
                const indent = '  '.repeat(node.level);
                let content = `${indent}- ${node.content}`;
                
                if (node.linkedNodeId) {
                    const linkedNode = nodes.find(n => n.id === node.linkedNodeId);
                    if (linkedNode) {
                        content += ` ‚Üí linked to: ${linkedNode.content}`;
                    }
                }
                
                if (node.note && node.note.trim()) {
                    const noteLines = node.note.split('\n');
                    const indentedNote = noteLines.map(line => `${indent}  > ${line}`).join('\n');
                    content += '\n' + indentedNote;
                }
                
                return content;
            }).join('\n');
        };

        const toggleMarkdownView = () => {
            setShowMarkdownView(!showMarkdownView);
            // Reset selected node when switching views
            if (!showMarkdownView) {
                setSelectedNodeId(null);
                setIsInputFocused(false);
            }
        };

        const exportMarkdown = () => {
            const markdown = generateMarkdown();
            
            // Create a blob and download
            const blob = new Blob([markdown], { type: 'text/markdown' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'tree-e-export.md';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        };

        const clearAll = () => {
            setNodes([]);
            setCurrentIndentLevel(0);
            setSelectedNodeId(null);
            setFocusedNode(null);
            setShowClearConfirm(false);
        };

        const manualSave = () => {
            saveToStorage(nodes);
            // Show brief feedback
            const btn = document.querySelector('.save-btn');
            if (btn) {
                const originalText = btn.textContent;
                btn.textContent = '‚úì';
                setTimeout(() => {
                    btn.textContent = originalText;
                }, 1000);
            }
        };

        const selectedNode = selectedNodeId ? nodes.find(node => node.id === selectedNodeId) : null;

        // Handle clicking outside to deselect
        const handleBackgroundClick = (e) => {
            // Only deselect if clicking on the main app background, not on nodes or UI elements
            if (e.target.classList.contains('app') || 
                e.target.classList.contains('main-content') || 
                e.target.classList.contains('nodes-container')) {
                
                if (selectedNodeId) {
                    setSelectedNodeId(null);
                    // Reset indent level
                    if (nodes.length > 0) {
                        setCurrentIndentLevel(nodes[nodes.length - 1].level);
                    } else {
                        setCurrentIndentLevel(0);
                    }
                }
                setIsInputFocused(false);
                setShowThemeDropdown(false);
            }
        };

        return (
            <div 
                className="app" 
                style={{ 
                    backgroundColor: theme.background,
                    color: theme.text 
                }}
                onClick={handleBackgroundClick}
            >
                {/* Header */}
                <div className="header" style={{ backgroundColor: theme.background, borderColor: theme.border }}>
                    <h1 style={{ color: theme.text }}>Tree-e</h1>
                    
                    <div className="header-controls">
                        <button
                            className="control-btn save-btn"
                            onClick={(e) => {
                                e.stopPropagation();
                                manualSave();
                            }}
                            disabled={nodes.length === 0}
                            style={{
                                backgroundColor: getColorForLevel(theme, 0),
                                borderColor: theme.border,
                                color: theme.text
                            }}
                        >
                            ‚úì
                        </button>
                        
                        <button
                            className="control-btn"
                            onClick={(e) => {
                                e.stopPropagation();
                                setShowAbout(true);
                            }}
                            style={{
                                backgroundColor: getColorForLevel(theme, 0),
                                borderColor: theme.border,
                                color: theme.text
                            }}
                        >
                            ‚ìò
                        </button>
                        
                        <button
                            className="control-btn"
                            onClick={(e) => {
                                e.stopPropagation();
                                toggleMarkdownView();
                            }}
                            disabled={nodes.length === 0}
                            style={{
                                backgroundColor: showMarkdownView ? theme.text : getColorForLevel(theme, 0),
                                borderColor: theme.border,
                                color: showMarkdownView ? theme.background : theme.text
                            }}
                        >
                            {showMarkdownView ? '‚óÇ' : '‚ñ∏'}
                        </button>
                        
                        <button
                            className="control-btn"
                            onClick={(e) => {
                                e.stopPropagation();
                                if (nodes.length > 0) {
                                    setShowClearConfirm(true);
                                }
                            }}
                            disabled={nodes.length === 0}
                            style={{
                                backgroundColor: getColorForLevel(theme, 0),
                                borderColor: theme.border,
                                color: theme.text
                            }}
                        >
                            ‚å´
                        </button>
                        
                        <ThemeDropdown
                            currentTheme={currentTheme}
                            onThemeChange={setCurrentTheme}
                            isOpen={showThemeDropdown}
                            onToggle={(e) => {
                                if (e) e.stopPropagation();
                                setShowThemeDropdown(!showThemeDropdown);
                            }}
                            theme={theme}
                        />
                    </div>
                </div>

                {/* Main Content - Conditional Tree/Markdown View */}
                {showMarkdownView ? (
                    <MarkdownView 
                        markdown={generateMarkdown()} 
                        theme={theme} 
                        onDownload={exportMarkdown}
                    />
                ) : (
                    <div className="main-content">
                        <div className="nodes-container" ref={nodesContainerRef}>
                            {nodes.map(node => (
                                <div key={node.id} data-node-id={node.id}>
                                    <NodeComponent
                                        node={node}
                                        theme={theme}
                                        isSelected={selectedNodeId === node.id}
                                        onTap={(e) => {
                                            e.stopPropagation();
                                            
                                            if (selectedNodeId === node.id) {
                                                setSelectedNodeId(null);
                                                // Reset to the last node's level when deselecting
                                                if (nodes.length > 0) {
                                                    setCurrentIndentLevel(nodes[nodes.length - 1].level);
                                                } else {
                                                    setCurrentIndentLevel(0);
                                                }
                                            } else {
                                                setSelectedNodeId(node.id);
                                                setCurrentIndentLevel(node.level + 1);
                                                
                                                // Scroll to selected node
                                                setTimeout(() => {
                                                    const element = document.querySelector(`[data-node-id="${node.id}"]`);
                                                    if (element) {
                                                        element.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                                    }
                                                }, 100);
                                            }
                                        }}
                                        onIndent={() => indentNode(node.id)}
                                        onOutdent={() => outdentNode(node.id)}
                                        onDelete={() => deleteNode(node.id)}
                                        onFocus={() => focusNode(node.id)}
                                        onToggleTask={() => toggleTask(node.id)}
                                        onToggleComplete={() => toggleComplete(node.id)}
                                        onLink={() => startLinking(node.id)}
                                        onUnlink={() => unlinkNode(node.id)}
                                        onJumpToLink={() => jumpToLinkedNode(node.id)}
                                    />
                                </div>
                            ))}
                        </div>
                    </div>
                )}

                {/* Input Area - Fixed at Bottom (only show in tree view) */}
                {!showMarkdownView && (
                    <div className="input-area" style={{ backgroundColor: theme.background, borderColor: theme.border }}>
                        {isInputFocused && (
                            <div className="indent-controls">
                                <button
                                    className="indent-btn"
                                    onClick={() => setCurrentIndentLevel(prev => Math.max(0, prev - 1))}
                                    disabled={currentIndentLevel === 0}
                                    style={{
                                        backgroundColor: getColorForLevel(theme, 0),
                                        borderColor: theme.border,
                                        color: theme.text
                                    }}
                                >
                                    ‚Üê Outdent
                                </button>
                                <button
                                    className="indent-btn"
                                    onClick={() => setCurrentIndentLevel(prev => prev + 1)}
                                    style={{
                                        backgroundColor: getColorForLevel(theme, 0),
                                        borderColor: theme.border,
                                        color: theme.text
                                    }}
                                >
                                    Indent ‚Üí
                                </button>
                            </div>
                        )}
                        
                        <div 
                            className="input-container"
                            style={{
                                borderColor: theme.border,
                                backgroundColor: theme.background
                            }}
                            onClick={(e) => {
                                e.stopPropagation();
                                setIsInputFocused(true);
                                inputRef.current?.focus();
                            }}
                            {...inputSwipeHandlers}
                        >
                            <div className="input-prompt" style={{ color: theme.prompt }}>
                                >
                            </div>
                            
                            {currentIndentLevel > 0 && (
                                <div className="indent-indicator" style={{ color: theme.prompt }}>
                                    {'  ‚îÇ'.repeat(currentIndentLevel)}
                                </div>
                            )}
                            
                            <input
                                ref={inputRef}
                                className="main-input"
                                type="text"
                                value={currentInput}
                                onChange={(e) => setCurrentInput(e.target.value)}
                                onKeyPress={(e) => {
                                    if (e.key === 'Enter') {
                                        addNode();
                                    }
                                }}
                                onFocus={() => {
                                    setIsInputFocused(true);
                                }}
                                placeholder="Start your Tree-e..."
                                style={{ color: theme.text }}
                            />
                        </div>
                        
                        {selectedNode && (
                            <div 
                                className="context-indicator"
                                style={{
                                    backgroundColor: getColorForLevel(theme, 0),
                                    borderColor: theme.border,
                                    color: theme.text
                                }}
                            >
                                ‚§∑ Next node will be added as child of: "{selectedNode.content}" (Level {selectedNode.level + 1})
                            </div>
                        )}
                        
                        {nodes.length === 0 && (
                            <div className="instructions" style={{ color: theme.text }}>
                                Swipe right to indent ‚Ä¢ Swipe left to outdent ‚Ä¢ Swipe on input box to adjust level ‚Ä¢ Return to add node ‚Ä¢ Link to connect thoughts
                            </div>
                        )}
                    </div>
                )}

                {/* Modals */}
                <AboutView
                    isOpen={showAbout}
                    onClose={() => setShowAbout(false)}
                    theme={theme}
                />
                
                <FocusView
                    isOpen={!!focusedNode}
                    onClose={() => setFocusedNode(null)}
                    node={focusedNode}
                    theme={theme}
                    onSave={saveFocusNote}
                />
                
                <LinkPickerView
                    isOpen={showLinkPicker}
                    onClose={() => {
                        setShowLinkPicker(false);
                        setLinkingFromNodeId(null);
                    }}
                    nodes={nodes}
                    fromNodeId={linkingFromNodeId}
                    theme={theme}
                    onLink={linkNodes}
                />

                {/* Clear Confirmation */}
                {showClearConfirm && (
                    <Modal 
                        isOpen={showClearConfirm} 
                        onClose={() => setShowClearConfirm(false)} 
                        title="Clear your garden?" 
                        theme={theme}
                    >
                        <div style={{ marginBottom: '16px' }}>
                            {currentTheme === 'espresso' ? 
                                "This will empty your cup of all brewing thoughts. A fresh roast awaits your inspiration." :
                            currentTheme === 'alienGuts' ?
                                "This will dissolve all your otherworldly thoughts back into the cosmic void. New alien wisdom awaits your discovery." :
                            currentTheme === 'neon' ?
                                "This will power down all your electric thoughts. A fresh surge of inspiration awaits." :
                                "This will remove all your carefully cultivated thoughts. They cannot be replanted once cleared."
                            }
                        </div>
                        <div style={{ display: 'flex', gap: '12px', justifyContent: 'flex-end' }}>
                            <button
                                onClick={() => setShowClearConfirm(false)}
                                style={{
                                    background: theme.border,
                                    color: theme.text,
                                    border: 'none',
                                    padding: '8px 16px',
                                    borderRadius: '6px',
                                    cursor: 'pointer'
                                }}
                            >
                                Cancel
                            </button>
                            <button
                                onClick={clearAll}
                                style={{
                                    background: '#ef4444',
                                    color: 'white',
                                    border: 'none',
                                    padding: '8px 16px',
                                    borderRadius: '6px',
                                    cursor: 'pointer'
                                }}
                            >
                                Clear All
                            </button>
                        </div>
                    </Modal>
                )}
            </div>
        );
    };

    // Render the app
    ReactDOM.render(<TreeApp />, document.getElementById('root'));

    // Service Worker Registration for PWA
    if ('serviceWorker' in navigator) {
        const swCode = `
            const CACHE_NAME = 'tree-e-v1';
            const urlsToCache = [
                '/',
                '/index.html'
            ];

            self.addEventListener('install', event => {
                event.waitUntil(
                    caches.open(CACHE_NAME)
                        .then(cache => cache.addAll(urlsToCache))
                );
            });

            self.addEventListener('fetch', event => {
                event.respondWith(
                    caches.match(event.request)
                        .then(response => {
                            if (response) {
                                return response;
                            }
                            return fetch(event.request);
                        })
                );
            });
        `;
        
        const blob = new Blob([swCode], { type: 'application/javascript' });
        const swUrl = URL.createObjectURL(blob);
        
        navigator.serviceWorker.register(swUrl)
            .then(registration => {
                console.log('SW registered: ', registration);
            })
            .catch(registrationError => {
                console.log('SW registration failed: ', registrationError);
            });
    }
</script>


</body>
</html>
