<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tree-e - Hierarchical Note Taking</title>

<!-- PWA Meta Tags -->

<meta name="description" content="Tree-e: Hierarchical note-taking app with beautiful themes">
<meta name="theme-color" content="#e9f5e9">
<link rel="manifest" href="data:application/json;base64,eyJuYW1lIjoiVHJlZS1lIiwic2hvcnRfbmFtZSI6IlRyZWUtZSIsImRpc3BsYXkiOiJzdGFuZGFsb25lIiwic3RhcnRfdXJsIjoiLyIsInRoZW1lX2NvbG9yIjoiI2U5ZjVlOSIsImJhY2tncm91bmRfY29sb3IiOiIjZTlmNWU5IiwiaWNvbnMiOlt7InNyYyI6ImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIWnBaWGRDYjNnOUlqQWdNQ0F4TWpnZ01USTRMQ0lqSURFeU9DQXhNamt6TGpGMWNpNGhMU0lnWm1sc2JEMGlJek5tWm1NeVlpSStQR04xY21ObElDOStQSEJoZEdnZ1pEMGlUVEkxSURjMElHTnNhWEJRWVhSb1BDOWpkWEpqYkdVK1BHTnBjbU5zWlNCamVEMGlObVFpSUdONVBTSTJaQ0lnY2owNU1pd2dOUGdnTWpOa01EWk1OUzhpSUdac2JIcGJKVGMwT1RVaU5qWWlQand2WTJseVkyeGxQanh6ZEhKdmEyVWdkMmxrZEdnOVlqTWlJR2hsYVdkb2REMGlOakkwSWlCamIyeDFjeWNpSWlCelpubHNaVDBpZDBsa1lXWGtPVFprWnpBaE1qQXNPREkyWklCMFpXMWpkVDRpSUhCdlpXbHVkR2s5VGpFa2NTSXZQanczSWo0OEwzTjJaejQ9IiwidHlwZSI6ImltYWdlL3N2Zyt4bWwiLCJzaXplcyI6IjEyOHgxMjgifV19">

<!-- React and Babel -->

<script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>

<script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>

<script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>

<!-- Fonts -->

<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">

<style>
    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
    }
    
    body {
        font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        touch-action: manipulation;
        user-select: none;
        -webkit-user-select: none;
        -webkit-tap-highlight-color: transparent;
        overflow-x: hidden;
        font-size: 16px;
        margin: 0;
        padding: 0;
    }
    
    .app {
        height: 100vh;
        height: 100dvh;
        display: flex;
        flex-direction: column;
        overflow: hidden;
        min-width: 320px;
        width: 100vw;
    }
    
    .header {
        display: flex;
        flex-direction: column;
        gap: 0;
        padding: 1rem;
        flex-shrink: 0;
        border-bottom: 1px solid rgba(0,0,0,0.08);
        min-height: 60px;
    }
    
    .header-main {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.75rem;
    }
    
    .header-breadcrumb {
        margin-top: 0.25rem;
        padding-left: 0;
    }
    
    .header-breadcrumb-text {
        font-family: 'JetBrains Mono', monospace;
        font-size: clamp(0.6875rem, 2vw, 0.75rem);
        opacity: 0.5;
        color: inherit;
    }
    
    .header h1 {
        font-size: clamp(1.125rem, 4vw, 1.25rem);
        font-weight: 600;
        margin: 0;
        flex-shrink: 0;
    }
    
    .header-controls {
        display: flex;
        gap: clamp(0.5rem, 2vw, 0.75rem);
        flex-wrap: wrap;
        justify-content: flex-end;
    }
    
    .control-btn {
        width: clamp(32px, 8vw, 40px);
        height: clamp(32px, 8vw, 40px);
        border: none;
        border-radius: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: clamp(0.875rem, 3vw, 1rem);
        cursor: pointer;
        transition: all 0.2s ease;
        border: 1px solid;
        background: white;
        flex-shrink: 0;
    }
    
    .control-btn:hover {
        transform: scale(1.05);
    }
    
    .control-btn:disabled {
        opacity: 0.4;
        cursor: not-allowed;
        transform: none;
    }
    
    .main-content {
        flex: 1;
        overflow: hidden;
        display: flex;
        flex-direction: column;
        min-height: 0;
    }
    
    .trees-container {
        flex: 1;
        display: flex;
        overflow-x: auto;
        overflow-y: hidden;
        gap: 0;
        background: inherit;
        scroll-behavior: smooth;
    }
    
    .trees-container.mobile {
        flex-direction: column;
        position: relative;
        overflow-x: hidden;
    }
    
    .tree-pane {
        flex: 1;
        display: flex;
        flex-direction: column;
        overflow: hidden;
        min-width: 320px;
        background: inherit;
        border-right: 1px solid rgba(0,0,0,0.08);
    }
    
    .tree-pane:last-child {
        border-right: none;
    }
    
    .tree-pane.mobile {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        min-width: auto;
        border-right: none;
        transform: translateX(0);
        transition: transform 0.3s ease;
        background: inherit;
        z-index: 1;
    }
    
    .tree-pane.mobile.hidden {
        transform: translateX(100%);
    }
    
    .tree-nav-btn {
        width: clamp(24px, 6vw, 28px);
        height: clamp(24px, 6vw, 28px);
        border: 1px solid;
        border-radius: 4px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: clamp(0.625rem, 2.5vw, 0.75rem);
        cursor: pointer;
        transition: all 0.2s ease;
        background: transparent;
        flex-shrink: 0;
    }
    
    .tree-nav-btn:hover:not(:disabled) {
        transform: scale(1.05);
    }
    
    .tree-nav-btn:disabled {
        opacity: 0.3;
        cursor: not-allowed;
    }
    
    .tree-content {
        flex: 1;
        overflow-y: auto;
        overflow-x: hidden;
        padding: clamp(0.75rem, 3vw, 1rem);
        scroll-behavior: smooth;
        min-height: 0;
    }
    
    .nodes-container {
        display: flex;
        flex-direction: column;
        gap: clamp(0.125rem, 3vw, 0.145rem);
        min-height: min-content;
        width: 100%;
        max-width: none;
        padding-bottom: clamp(1rem, 4vw, 2rem);
    }
    
    .node {
        display: flex;
        align-items: flex-start;
        gap: 0;
        position: relative;
    }
    
    .node-indentation {
        display: flex;
        flex-shrink: 0;
    }
    
    .indent-spacer {
        width: clamp(30px, 5vw, 36px);
    }
    
    .node-content-wrapper {
        display: flex;
        flex-direction: column;
        align-items: flex-start;
    }
    
    .node-content {
        padding: 12px 16px;
        border-radius: 8px;
        border: 1px solid;
        cursor: pointer;
        transition: all 0.3s ease;
        display: inline-flex;
        align-items: center;
        gap: 12px;
        min-width: 80px;
        max-width: calc(100vw - 32px);
        width: auto;
        transform-origin: center;
        word-wrap: break-word;
        overflow-wrap: break-word;
    }
    
    .node-content:hover {
        transform: scale(1.02);
    }
    
    .node-content.selected {
        border-width: 2px;
    }
    
    .node-content.completed {
        opacity: 0.6;
    }
    
    .task-toggle {
        font-size: 18px;
        cursor: pointer;
        transition: color 0.2s ease;
    }
    
    .node-text {
        font-size: 16px;
        line-height: 1.4;
        max-width: 280px;
        word-wrap: break-word;
        overflow-wrap: break-word;
        hyphens: auto;
    }
    
    .node-text.completed {
        text-decoration: line-through;
    }
    
    .node-icons {
        display: flex;
        gap: 4px;
        font-size: 14px;
    }
    
    .node-actions {
        display: flex;
        gap: 8px;
        margin-top: 8px;
        flex-wrap: wrap;
        width: auto;
        min-width: fit-content;
    }
    
    .action-btn {
        display: flex;
        align-items: center;
        gap: 4px;
        padding: 6px 12px;
        border: none;
        border-radius: 6px;
        font-size: 12px;
        color: white;
        cursor: pointer;
        transition: all 0.2s ease;
    }
    
    .action-btn:hover {
        transform: scale(1.05);
    }
    
    .action-btn.edit { background: #6366f1; }
    .action-btn.task { background: #22c55e; }
    .action-btn.focus { background: #3b82f6; }
    .action-btn.link { background: #a855f7; }
    .action-btn.unlink { background: #f97316; }
    .action-btn.branch { background: #10b981; }
    .action-btn.delete { background: #ef4444; }
    
    .input-area {
        flex-shrink: 0;
        padding: 16px;
        border-top: 1px solid rgba(0,0,0,0.08);
        background: inherit;
    }
    
    .indent-controls {
        display: flex;
        gap: 16px;
        justify-content: center;
        margin-bottom: 12px;
    }
    
    .indent-btn {
        display: flex;
        align-items: center;
        gap: 4px;
        padding: 8px 16px;
        border: 1px solid;
        border-radius: 8px;
        font-size: 14px;
        cursor: pointer;
        transition: all 0.2s ease;
    }
    
    .indent-btn:hover {
        transform: scale(1.05);
    }
    
    .indent-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none;
    }
    
    .input-container {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 12px 16px;
        border: 1px solid;
        border-radius: 12px;
        background: inherit;
    }
    
    .input-prompt {
        font-family: 'JetBrains Mono', monospace;
        font-size: 24px;
        font-weight: 500;
    }
    
    .indent-indicator {
        font-family: 'JetBrains Mono', monospace;
        font-size: 14px;
        opacity: 0.6;
    }
    
    .main-input {
        flex: 1;
        border: none;
        outline: none;
        background: transparent;
        font-family: 'JetBrains Mono', monospace;
        font-size: 18px;
        color: inherit;
    }
    
    .main-input::placeholder {
        color: inherit;
        opacity: 0.6;
    }
    
    .context-indicator {
        margin-top: 12px;
        padding: 8px 16px;
        border: 1px solid;
        border-radius: 8px;
        font-family: 'JetBrains Mono', monospace;
        font-size: 12px;
        opacity: 0.9;
        text-align: center;
    }
    
    .instructions {
        margin-top: 12px;
        font-family: 'JetBrains Mono', monospace;
        font-size: 12px;
        opacity: 0.6;
        text-align: center;
        line-height: 1.4;
    }
    
    .modal {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0,0,0,0.5);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000;
        padding: 20px;
    }
    
    .modal-content {
        width: 100%;
        max-width: 500px;
        max-height: 80vh;
        border-radius: 12px;
        overflow: hidden;
        display: flex;
        flex-direction: column;
    }
    
    .modal-header {
        padding: 16px;
        border-bottom: 1px solid rgba(0,0,0,0.08);
        display: flex;
        align-items: center;
        justify-content: space-between;
    }
    
    .modal-title {
        font-size: 18px;
        font-weight: 600;
        margin: 0;
    }
    
    .modal-close {
        background: none;
        border: none;
        font-size: 16px;
        cursor: pointer;
        padding: 4px;
    }
    
    .modal-body {
        flex: 1;
        overflow-y: auto;
        padding: 16px;
    }
    
    .note-editor {
        width: 100%;
        min-height: 200px;
        padding: 12px;
        border: 1px solid rgba(0,0,0,0.15);
        border-radius: 8px;
        font-size: 16px;
        font-family: inherit;
        background: inherit;
        color: inherit;
        resize: vertical;
    }
    
    .link-list {
        display: flex;
        flex-direction: column;
        gap: 12px;
    }
    
    .link-item {
        display: flex;
        align-items: center;
        padding: 12px 16px;
        border: 1px solid;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.2s ease;
        background: inherit;
        color: inherit;
        text-align: left;
        width: 100%;
    }
    
    .link-item:hover {
        transform: scale(1.02);
    }
    
    .link-item-content {
        flex: 1;
        display: flex;
        align-items: center;
        gap: 8px;
    }
    
    .link-chevron {
        opacity: 0.6;
        font-size: 14px;
    }
    
    .about-content {
        display: flex;
        flex-direction: column;
        gap: clamp(1.25rem, 5vw, 1.25rem);
    }
    
    .about-section {
        display: flex;
        flex-direction: column;
        gap: clamp(0.75rem, 3vw, 0.75rem);
    }
    
    .about-title {
        font-size: clamp(1.125rem, 5vw, 1.25rem);
        font-weight: 600;
        margin: 0;
    }
    
    .about-text {
        line-height: 1.6;
        opacity: 0.9;
        font-size: clamp(0.875rem, 4vw, 1rem);
    }
    
    .feature-list {
        display: flex;
        flex-direction: column;
        gap: clamp(0.5rem, 2vw, 0.5rem);
    }
    
    .feature-item {
        display: flex;
        flex-direction: column;
        gap: 2px;
    }
    
    .feature-title {
        font-weight: 500;
        font-size: clamp(0.875rem, 4vw, 1rem);
    }
    
    .feature-desc {
        opacity: 0.9;
        font-size: clamp(0.75rem, 3vw, 0.875rem);
    }
    
    .getting-started-list {
        font-family: 'JetBrains Mono', monospace;
        font-size: clamp(0.75rem, 3vw, 0.875rem);
        opacity: 0.9;
        line-height: 1.4;
    }
    
    .getting-started-list div {
        margin-bottom: 2px;
    }
    
    .empty-state {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: clamp(1rem, 4vw, 1rem);
        padding: clamp(2.5rem, 8vw, 2.5rem) clamp(1.25rem, 5vw, 1.25rem);
        text-align: center;
    }
    
    .empty-icon {
        font-size: clamp(2.5rem, 10vw, 3rem);
        opacity: 0.6;
    }
    
    .empty-title {
        font-size: clamp(1rem, 4vw, 1.125rem);
        font-weight: 500;
    }
    
    .empty-desc {
        font-size: clamp(0.75rem, 3vw, 0.875rem);
        opacity: 0.7;
        line-height: 1.4;
    }
    
    .dropdown {
        position: relative;
        display: inline-block;
    }
    
    .dropdown-content {
        position: absolute;
        top: 100%;
        right: 0;
        background: white;
        border: 1px solid #ccc;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        z-index: 100;
        min-width: clamp(120px, 30vw, 160px);
        max-height: 300px;
        overflow-y: auto;
    }
    
    .dropdown-item {
        padding: clamp(0.75rem, 3vw, 0.75rem) clamp(0.875rem, 4vw, 1rem);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: space-between;
        transition: background 0.2s ease;
        border: none;
        background: none;
        width: 100%;
        text-align: left;
        font-size: clamp(0.75rem, 3vw, 0.875rem);
    }
    
    .dropdown-item:hover {
        background: rgba(0,0,0,0.05);
    }
    
    /* Mobile and responsive adjustments */
    @media (max-width: 768px) {
        .app {
            height: 100vh;
            height: 100dvh;
        }
        
        .header {
            padding: 0.75rem;
        }
        
        .header-main {
            flex-wrap: wrap;
            gap: 0.375rem;
        }
        
        .header h1 {
            font-size: 1rem;
        }
        
        .control-btn {
            width: 36px;
            height: 36px;
            font-size: 0.875rem;
        }
        
        .header-controls {
            gap: 0.375rem;
        }
        
        .action-btn span {
            display: none;
        }
        
        .node-text {
            font-size: 0.875rem;
            max-width: calc(100vw - 4rem);
        }
        
        .main-input {
            font-size: 1rem;
        }
        
        .input-prompt {
            font-size: 1.25rem;
        }
    }
    
    @media (max-width: 480px) {
        .header {
            padding: 0.5rem;
            gap: 0.375rem;
        }
        
        .header h1 {
            font-size: 0.875rem;
        }
        
        .control-btn {
            width: 32px;
            height: 32px;
            font-size: 0.75rem;
        }
        
        .node-content {
            padding: 0.5rem 0.75rem;
            gap: 0.5rem;
        }
        
        .node-text {
            font-size: 0.8125rem;
            max-width: calc(100vw - 3rem);
        }
        
        .indent-controls {
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
        }
        
        .main-input {
            font-size: 0.875rem;
        }
        
        .input-prompt {
            font-size: 1.125rem;
        }
    }
    
    @media (max-width: 360px) {
        .header-controls {
            gap: 0.25rem;
        }
        
        .control-btn {
            width: 28px;
            height: 28px;
            font-size: 0.6875rem;
        }
        
        .node-text {
            max-width: calc(100vw - 2.5rem);
        }
    }
</style>

</head>
<body>
    <div id="root"></div>

<script type="text/babel">
    const { useState, useEffect, useRef, useCallback } = React;

    // Theme definitions
    const themes = {
        matcha: {
            name: 'Matcha',
            background: '#e9f5e9',
            text: '#2e4a2e',
            prompt: '#59784a',
            border: '#c4d6c4',
            levelColors: ['#f0f8f0', '#ddf2dd', '#ccedcc', '#bae8ba', '#a9e3a9']
        },
        latte: {
            name: 'Latte',
            background: '#f5f0e9',
            text: '#4a3e2e',
            prompt: '#7a6b59',
            border: '#d6ccc4',
            levelColors: ['#f8f5f0', '#edebdd', '#e3dccc', '#d9cfba', '#cfc2a9']
        },
        ocean: {
            name: 'Ocean',
            background: '#e9f0f5',
            text: '#2e3e4a',
            prompt: '#596b7a',
            border: '#c4ccd6',
            levelColors: ['#f0f5f8', '#ddebf2', '#ccddec', '#bacfe8', '#a9c2e3']
        },
        midnight: {
            name: 'Midnight',
            background: '#0f0f24',
            text: '#e1e1e1',
            prompt: '#8c8c8c',
            border: '#2e2e45',
            levelColors: ['#1a1a2e', '#24243a', '#2e2e42', '#38384e', '#424256']
        },
        chess: {
            name: 'Chess',
            background: '#f7f7f7',
            text: '#1a1a1a',
            prompt: '#666666',
            border: '#e1e1e1',
            levelColors: ['#ffffff', '#f5f5f5', '#ebebeb', '#e1e1e1', '#d7d7d7']
        },
        espresso: {
            name: 'Espresso',
            background: '#2b1710',
            text: '#e8d7c4',
            prompt: '#b89470',
            border: '#5c3d29',
            levelColors: ['#3d241a', '#4d2e21', '#5c3829', '#6b4230', '#7a4c37']
        },
        alienGuts: {
            name: 'Alien Guts',
            background: '#141f14',
            text: '#d9f2bf',
            prompt: '#99cc80',
            border: '#66994d',
            levelColors: ['#33cc4d', '#9933cc', '#cc9933', '#3399cc', '#cc3366']
        },
        neon: {
            name: 'Neon',
            background: '#0d0d26',
            text: '#1a1a1a',
            prompt: '#cccccc',
            border: '#666699',
            levelColors: ['#ff3399', '#33ff99', '#ff9933', '#9933ff', '#33b3ff']
        }
    };

    // Utility functions
    const generateId = () => {
        return Date.now().toString(36) + Math.random().toString(36).substr(2);
    };

    const getColorForLevel = (theme, level) => {
        if (level < theme.levelColors.length) {
            return theme.levelColors[level];
        } else {
            const baseColorIndex = level % theme.levelColors.length;
            return theme.levelColors[baseColorIndex] + '80';
        }
    };

    // Storage utilities
    const saveToStorage = (trees) => {
        try {
            localStorage.setItem('tree-e-trees', JSON.stringify(trees));
            const mainTree = trees.find(tree => tree.id === 'main');
            if (mainTree) {
                localStorage.setItem('tree-e-nodes', JSON.stringify(mainTree.nodes));
            }
        } catch (error) {
            console.error('Failed to save trees:', error);
        }
    };

    const loadFromStorage = () => {
        try {
            const savedTrees = localStorage.getItem('tree-e-trees');
            if (savedTrees) {
                return JSON.parse(savedTrees);
            }
            
            const savedNodes = localStorage.getItem('tree-e-nodes');
            if (savedNodes) {
                const nodes = JSON.parse(savedNodes);
                return [{
                    id: 'main',
                    title: 'Main Tree',
                    nodes: nodes,
                    parentTreeId: null,
                    parentNodeId: null,
                    breadcrumb: []
                }];
            }
            
            return [{
                id: 'main',
                title: 'Main Tree',
                nodes: [],
                parentTreeId: null,
                parentNodeId: null,
                breadcrumb: []
            }];
        } catch (error) {
            console.error('Failed to load trees:', error);
            return [{
                id: 'main',
                title: 'Main Tree',
                nodes: [],
                parentTreeId: null,
                parentNodeId: null,
                breadcrumb: []
            }];
        }
    };

    const saveThemeToStorage = (themeName) => {
        try {
            localStorage.setItem('tree-e-theme', themeName);
        } catch (error) {
            console.error('Failed to save theme:', error);
        }
    };

    const loadThemeFromStorage = () => {
        try {
            const saved = localStorage.getItem('tree-e-theme');
            return saved || 'matcha';
        } catch (error) {
            console.error('Failed to load theme:', error);
            return 'matcha';
        }
    };

    // Touch handling utilities
    const useTouchHandler = (onSwipeLeft, onSwipeRight, threshold = 50) => {
        const touchStart = useRef(null);
        const touchEnd = useRef(null);

        const onTouchStart = (e) => {
            touchEnd.current = null;
            touchStart.current = e.targetTouches[0].clientX;
        };

        const onTouchMove = (e) => {
            touchEnd.current = e.targetTouches[0].clientX;
        };

        const onTouchEnd = () => {
            if (!touchStart.current || !touchEnd.current) return;
            
            const distance = touchStart.current - touchEnd.current;
            const isLeftSwipe = distance > threshold;
            const isRightSwipe = distance < -threshold;

            if (isLeftSwipe && onSwipeLeft) {
                onSwipeLeft();
            }
            if (isRightSwipe && onSwipeRight) {
                onSwipeRight();
            }
        };

        return {
            onTouchStart,
            onTouchMove,
            onTouchEnd
        };
    };

    // Components
    const NodeComponent = ({ node, theme, isSelected, backlinks = [], treesLength = 1, editingNodeId, onTap, onIndent, onOutdent, onDelete, onFocus, onToggleTask, onToggleComplete, onLink, onUnlink, onJumpToLink, onBranchOut, onEdit, onSaveEdit, onCancelEdit }) => {
        const swipeHandlers = useTouchHandler(onOutdent, onIndent);
        const [editText, setEditText] = useState(node.content);
        const editInputRef = useRef(null);

        const isEditing = editingNodeId === node.id;

        useEffect(() => {
            if (isEditing && editInputRef.current) {
                editInputRef.current.focus();
                editInputRef.current.select();
            }
        }, [isEditing]);

        useEffect(() => {
            setEditText(node.content);
        }, [node.content]);

        const handleSaveEdit = () => {
            const trimmedText = editText.trim();
            if (trimmedText && trimmedText !== node.content) {
                onSaveEdit(node.id, trimmedText);
            } else {
                onCancelEdit();
            }
        };

        const handleKeyPress = (e) => {
            if (e.key === 'Enter') {
                handleSaveEdit();
            } else if (e.key === 'Escape') {
                setEditText(node.content);
                onCancelEdit();
            }
        };

        return (
            <div className="node">
                <div className="node-indentation">
                    {Array.from({ length: node.level }, (_, i) => (
                        <div key={i} className="indent-spacer" />
                    ))}
                </div>
                
                <div className="node-content-wrapper">
                    <div 
                        className={`node-content ${isSelected ? 'selected' : ''} ${node.isTask && node.isCompleted ? 'completed' : ''}`}
                        style={{
                            backgroundColor: isSelected ? theme.border : getColorForLevel(theme, node.level),
                            borderColor: isSelected ? theme.text : theme.border,
                            color: theme.text
                        }}
                        onClick={(e) => !isEditing && onTap(e)}
                        {...(!isEditing ? swipeHandlers : {})}
                    >
                        {node.isTask && (
                            <div 
                                className="task-toggle" 
                                onClick={(e) => {
                                    e.stopPropagation();
                                    if (!isEditing) onToggleComplete();
                                }}
                                style={{ color: node.isCompleted ? '#22c55e' : theme.text + '99' }}
                            >
                                {node.isCompleted ? '☑' : '☐'}
                            </div>
                        )}
                        
                        {isEditing ? (
                            <input
                                ref={editInputRef}
                                type="text"
                                value={editText}
                                onChange={(e) => setEditText(e.target.value)}
                                onKeyDown={handleKeyPress}
                                onBlur={handleSaveEdit}
                                style={{
                                    background: 'transparent',
                                    border: 'none',
                                    outline: 'none',
                                    color: theme.text,
                                    font: 'inherit',
                                    fontSize: '16px',
                                    width: '100%',
                                    minWidth: '100px'
                                }}
                                onClick={(e) => e.stopPropagation()}
                            />
                        ) : (
                            <div className={`node-text ${node.isTask && node.isCompleted ? 'completed' : ''}`}>
                                {node.content}
                            </div>
                        )}
                        
                        {!isEditing && (
                            <div className="node-icons" style={{ color: theme.text + '99' }}>
                                {node.isTask && <span>□</span>}
                                {node.note && node.note.trim() && <span>◊</span>}
                                {node.linkedNodeId && (
                                    <span 
                                        onClick={(e) => {
                                            e.stopPropagation();
                                            onJumpToLink();
                                        }}
                                        style={{ color: '#3b82f6', cursor: 'pointer' }}
                                        title="Jumps to linked node"
                                    >
                                        ↗
                                    </span>
                                )}
                                {backlinks.length > 0 && (
                                    <span 
                                        style={{ color: '#8b5cf6', cursor: 'pointer' }}
                                        title={`${backlinks.length} node${backlinks.length > 1 ? 's' : ''} link${backlinks.length > 1 ? '' : 's'} to this`}
                                    >
                                        ↙
                                    </span>
                                )}
                            </div>
                        )}
                    </div>
                    
                    {isSelected && !isEditing && (
                        <div className="node-actions">
                            <button className="action-btn edit" onClick={() => onEdit(node.id)} style={{ background: '#6366f1' }}>
                                ✎ <span>Edit</span>
                            </button>
                            <button className="action-btn task" onClick={onToggleTask}>
                                □ <span>{node.isTask ? 'Note' : 'Task'}</span>
                            </button>
                            <button className="action-btn focus" onClick={onFocus}>
                                ◊ <span>Notes</span>
                            </button>
                            {node.linkedNodeId ? (
                                <button className="action-btn unlink" onClick={onUnlink}>
                                    ⧉ <span>Unlink</span>
                                </button>
                            ) : (
                                <button className="action-btn link" onClick={onLink}>
                                    ○—○ <span>Link</span>
                                </button>
                            )}
                            <button 
                                className="action-btn branch" 
                                onClick={onBranchOut} 
                                disabled={treesLength >= 5}
                                style={{ 
                                    background: treesLength >= 5 ? '#94a3b8' : '#10b981',
                                    cursor: treesLength >= 5 ? 'not-allowed' : 'pointer'
                                }}
                                title={treesLength >= 5 ? 'Maximum 5 trees allowed' : 'Branch out to explore this thought'}
                            >
                                ⫷ <span>Branch</span>
                            </button>
                            <button className="action-btn delete" onClick={onDelete}>
                                ╳ <span>Delete</span>
                            </button>
                        </div>
                    )}
                    
                    {isEditing && (
                        <div className="node-actions">
                            <button className="action-btn" onClick={handleSaveEdit} style={{ background: '#22c55e' }}>
                                ✓ <span>Save</span>
                            </button>
                            <button className="action-btn" onClick={() => { setEditText(node.content); onCancelEdit(); }} style={{ background: '#6b7280' }}>
                                ✕ <span>Cancel</span>
                            </button>
                        </div>
                    )}
                </div>
            </div>
        );
    };

    const Modal = ({ isOpen, onClose, title, children, theme }) => {
        if (!isOpen) return null;

        return (
            <div className="modal" onClick={onClose}>
                <div 
                    className="modal-content" 
                    style={{ backgroundColor: theme.background, color: theme.text }}
                    onClick={(e) => e.stopPropagation()}
                >
                    <div className="modal-header" style={{ borderColor: theme.border }}>
                        <h3 className="modal-title">{title}</h3>
                        <button 
                            className="modal-close" 
                            onClick={onClose}
                            style={{ color: theme.text }}
                        >
                            ╳
                        </button>
                    </div>
                    <div className="modal-body">
                        {children}
                    </div>
                </div>
            </div>
        );
    };

    const FocusView = ({ isOpen, onClose, node, theme, onSave }) => {
        const [note, setNote] = useState(node?.note || '');

        useEffect(() => {
            setNote(node?.note || '');
        }, [node]);

        const handleSave = () => {
            onSave(note);
            onClose();
        };

        return (
            <Modal isOpen={isOpen} onClose={handleSave} title={`Notes: ${node?.content || ''}`} theme={theme}>
                <textarea
                    className="note-editor"
                    value={note}
                    onChange={(e) => setNote(e.target.value)}
                    placeholder="Add detailed notes for this node..."
                    style={{
                        backgroundColor: getColorForLevel(theme, 1),
                        borderColor: theme.border,
                        color: theme.text
                    }}
                />
                <div style={{ marginTop: '16px', display: 'flex', justifyContent: 'flex-end' }}>
                    <button
                        onClick={handleSave}
                        style={{
                            background: '#3b82f6',
                            color: 'white',
                            border: 'none',
                            padding: '8px 16px',
                            borderRadius: '6px',
                            cursor: 'pointer'
                        }}
                    >
                        Save & Close
                    </button>
                </div>
            </Modal>
        );
    };

    const LinkPickerView = ({ isOpen, onClose, nodes, fromNodeId, theme, onLink }) => {
        const availableNodes = nodes.filter(node => node.id !== fromNodeId);

        return (
            <Modal isOpen={isOpen} onClose={onClose} title="Link to Node" theme={theme}>
                {availableNodes.length === 0 ? (
                    <div className="empty-state">
                        <div className="empty-icon">🔗</div>
                        <div className="empty-title">No other nodes to link to</div>
                        <div className="empty-desc">
                            Create more nodes to build connections between your thoughts.
                        </div>
                    </div>
                ) : (
                    <div className="link-list">
                        {availableNodes.map(node => (
                            <button
                                key={node.id}
                                className="link-item"
                                onClick={() => {
                                    onLink(node.id);
                                    onClose();
                                }}
                                style={{
                                    backgroundColor: getColorForLevel(theme, node.level),
                                    borderColor: theme.border,
                                    color: theme.text
                                }}
                            >
                                <div className="link-item-content">
                                    <span style={{ fontFamily: 'JetBrains Mono, monospace' }}>
                                        {'  '.repeat(node.level)}
                                    </span>
                                    <span>{node.content}</span>
                                </div>
                                <span className="link-chevron">→</span>
                            </button>
                        ))}
                    </div>
                )}
            </Modal>
        );
    };

    const AboutView = ({ isOpen, onClose, theme }) => {
        return (
            <Modal isOpen={isOpen} onClose={onClose} title="About Tree-e" theme={theme}>
                <div className="about-content">
                    <div className="about-section">
                        <h4 className="about-title">The Philosophy</h4>
                        <p className="about-text">
                            Tree-e embraces the power of simplicity and exploration. Like branches forming trees, individual thoughts combine to create complex ideas. The new branching feature lets you explore different paths and perspectives, creating a forest of interconnected knowledge.
                        </p>
                    </div>
                    
                    <div className="about-section">
                        <h4 className="about-title">Core Features</h4>
                        <div className="feature-list">
                            <div className="feature-item">
                                <div className="feature-title">Hierarchical Thinking:</div>
                                <div className="feature-desc">Use swipe gestures to create natural thought structures with color-coded levels.</div>
                            </div>
                            <div className="feature-item">
                                <div className="feature-title">Inline Editing:</div>
                                <div className="feature-desc">Edit any node text directly with a simple click. Perfect for refining thoughts as they evolve.</div>
                            </div>
                            <div className="feature-item">
                                <div className="feature-title">Branch-Out Exploration:</div>
                                <div className="feature-desc">Select any node and branch out to explore it in a dedicated workspace. Create up to 5 connected trees.</div>
                            </div>
                            <div className="feature-item">
                                <div className="feature-title">Focus Mode:</div>
                                <div className="feature-desc">Tap the Notes button to dive deep into any node with detailed notes.</div>
                            </div>
                            <div className="feature-item">
                                <div className="feature-title">Task Management:</div>
                                <div className="feature-desc">Convert any node to a task with completion tracking.</div>
                            </div>
                            <div className="feature-item">
                                <div className="feature-title">Simple Linking:</div>
                                <div className="feature-desc">Create connections between related thoughts with visual indicators.</div>
                            </div>
                            <div className="feature-item">
                                <div className="feature-title">Stunning Themes:</div>
                                <div className="feature-desc">Choose from 8 beautiful themes including the wild Alien Guts and electric Neon.</div>
                            </div>
                        </div>
                    </div>
                    
                    <div className="about-section">
                        <h4 className="about-title">Getting Started</h4>
                        <div className="getting-started-list">
                            <div>• Start typing at the > prompt</div>
                            <div>• Swipe right to indent, left to outdent</div>
                            <div>• Swipe on input box to adjust indent level</div>
                            <div>• Notice how each level gets its own color</div>
                            <div>• Tap nodes to access edit options</div>
                            <div>• Use Edit to modify node text inline</div>
                            <div>• Use Branch to explore thoughts in new trees</div>
                            <div>• Use Notes to add detailed information</div>
                            <div>• Use Link to connect related thoughts</div>
                            <div>• Export button shares all trees as Markdown</div>
                            <div>• Your work auto-saves as you create</div>
                            <div>• Navigate with breadcrumbs in the header</div>
                        </div>
                    </div>
                </div>
            </Modal>
        );
    };

    const FilterDropdown = ({ currentFilter, onFilterChange, isOpen, onToggle, theme, filterOptions }) => {
        return (
            <div className="dropdown">
                <button 
                    className="control-btn"
                    onClick={onToggle}
                    style={{
                        backgroundColor: currentFilter !== 'all' ? theme.text : getColorForLevel(theme, 0),
                        borderColor: theme.border,
                        color: currentFilter !== 'all' ? theme.background : theme.text
                    }}
                >
                    ◈
                </button>
                {isOpen && (
                    <div className="dropdown-content">
                        {filterOptions.map((option) => (
                            <button
                                key={option.key}
                                className="dropdown-item"
                                onClick={() => {
                                    onFilterChange(option.key);
                                    onToggle();
                                }}
                            >
                                <span style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                    <span>{option.icon}</span>
                                    <span>{option.label}</span>
                                </span>
                                {currentFilter === option.key && <span>●</span>}
                            </button>
                        ))}
                    </div>
                )}
            </div>
        );
    };

    const ThemeDropdown = ({ currentTheme, onThemeChange, isOpen, onToggle, theme }) => {
        return (
            <div className="dropdown">
                <button 
                    className="control-btn"
                    onClick={onToggle}
                    style={{
                        backgroundColor: getColorForLevel(theme, 0),
                        borderColor: theme.border,
                        color: theme.text
                    }}
                >
                    ◐
                </button>
                {isOpen && (
                    <div className="dropdown-content">
                        {Object.entries(themes).map(([key, themeOption]) => (
                            <button
                                key={key}
                                className="dropdown-item"
                                onClick={() => {
                                    onThemeChange(key);
                                    onToggle();
                                }}
                            >
                                <span>{themeOption.name}</span>
                                {currentTheme === key && <span>●</span>}
                            </button>
                        ))}
                    </div>
                )}
            </div>
        );
    };

    const MarkdownView = ({ markdown, theme, onDownload }) => {
        return (
            <div style={{ 
                display: 'flex',
                flexDirection: 'column',
                flex: 1,
                overflow: 'hidden'
            }}>
                <div style={{
                    padding: 'clamp(0.75rem, 3vw, 1rem)',
                    borderBottom: `1px solid ${theme.border}`,
                    display: 'flex',
                    justifyContent: 'flex-end'
                }}>
                    <button
                        onClick={onDownload}
                        style={{
                            background: theme.text,
                            color: theme.background,
                            border: 'none',
                            padding: 'clamp(0.5rem, 2vw, 0.5rem) clamp(0.75rem, 3vw, 1rem)',
                            borderRadius: '6px',
                            fontSize: 'clamp(0.75rem, 3vw, 0.875rem)',
                            cursor: 'pointer',
                            display: 'flex',
                            alignItems: 'center',
                            gap: '0.5rem'
                        }}
                    >
                        ↓ Download MD
                    </button>
                </div>
                
                <div style={{ 
                    flex: 1, 
                    overflow: 'auto', 
                    padding: 'clamp(0.75rem, 3vw, 1rem)',
                    fontFamily: 'JetBrains Mono, monospace',
                    whiteSpace: 'pre-wrap',
                    lineHeight: 1.6,
                    fontSize: 'clamp(0.75rem, 3vw, 0.875rem)',
                    color: theme.text
                }}>
                    {markdown || 'No content to display'}
                </div>
            </div>
        );
    };

    // Main App Component
    const TreeApp = () => {
        const [trees, setTrees] = useState([]);
        const [activeTreeIndex, setActiveTreeIndex] = useState(0);
        const [currentInput, setCurrentInput] = useState('');
        const [currentIndentLevel, setCurrentIndentLevel] = useState(0);
        const [selectedNodeId, setSelectedNodeId] = useState(null);
        const [selectedTreeIndex, setSelectedTreeIndex] = useState(0);
        const [editingNodeId, setEditingNodeId] = useState(null);
        const [focusedNode, setFocusedNode] = useState(null);
        const [currentTheme, setCurrentTheme] = useState('matcha');
        const [showAbout, setShowAbout] = useState(false);
        const [showLinkPicker, setShowLinkPicker] = useState(false);
        const [linkingFromNodeId, setLinkingFromNodeId] = useState(null);
        const [showThemeDropdown, setShowThemeDropdown] = useState(false);
        const [isInputFocused, setIsInputFocused] = useState(false);
        const [showMarkdownView, setShowMarkdownView] = useState(false);
        const [showClearConfirm, setShowClearConfirm] = useState(false);
        const [currentFilter, setCurrentFilter] = useState('all');
        const [showFilterDropdown, setShowFilterDropdown] = useState(false);
        const [isMobile, setIsMobile] = useState(false);

        const inputRef = useRef(null);
        const nodesContainerRef = useRef(null);
        const maintainFocus = useRef(true);

        useEffect(() => {
            const checkMobile = () => setIsMobile(window.innerWidth <= 768);
            checkMobile();
            window.addEventListener('resize', checkMobile);
            return () => window.removeEventListener('resize', checkMobile);
        }, []);

        const getCurrentNodes = () => {
            return trees[activeTreeIndex]?.nodes || [];
        };

        const updateCurrentNodes = (updater) => {
            setTrees(prev => prev.map((tree, index) => 
                index === activeTreeIndex 
                    ? { ...tree, nodes: typeof updater === 'function' ? updater(tree.nodes) : updater }
                    : tree
            ));
        };

        useEffect(() => {
            const loadedTrees = loadFromStorage();
            setTrees(loadedTrees);
            setCurrentTheme(loadThemeFromStorage());
            
            setTimeout(() => {
                if (inputRef.current) {
                    inputRef.current.focus();
                    maintainFocus.current = true;
                }
            }, 500);
        }, []);

        useEffect(() => {
            if (trees.length > 0) {
                saveToStorage(trees);
            }
        }, [trees]);

        useEffect(() => {
            saveThemeToStorage(currentTheme);
        }, [currentTheme]);

        const theme = themes[currentTheme];

        const inputSwipeHandlers = useTouchHandler(
            () => setCurrentIndentLevel(prev => Math.max(0, prev - 1)),
            () => setCurrentIndentLevel(prev => prev + 1)
        );

        const addNode = () => {
            const content = currentInput.trim();
            if (!content) return;

            const nodes = getCurrentNodes();
            let insertIndex = nodes.length;
            let newLevel = currentIndentLevel;

            if (selectedNodeId) {
                const selectedNode = nodes.find(node => node.id === selectedNodeId);
                const selectedIndex = nodes.findIndex(node => node.id === selectedNodeId);
                
                if (selectedNode !== undefined && selectedIndex !== -1) {
                    newLevel = selectedNode.level + 1;
                    
                    let insertAfterIndex = selectedIndex;
                    
                    for (let i = selectedIndex + 1; i < nodes.length; i++) {
                        if (nodes[i].level > selectedNode.level) {
                            insertAfterIndex = i;
                        } else {
                            break;
                        }
                    }
                    
                    insertIndex = insertAfterIndex + 1;
                }
            }

            const newNode = {
                id: generateId(),
                content,
                level: newLevel,
                note: '',
                linkedNodeId: null,
                isTask: false,
                isCompleted: false
            };

            updateCurrentNodes(prevNodes => {
                const newNodes = [...prevNodes];
                newNodes.splice(insertIndex, 0, newNode);
                return newNodes;
            });
            
            setCurrentInput('');
            setCurrentIndentLevel(newLevel);

            setTimeout(() => {
                const nodeElement = document.querySelector(`[data-node-id="${newNode.id}"]`);
                if (nodeElement && nodesContainerRef.current) {
                    nodeElement.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }
            }, 100);
        };

        const deleteNode = (nodeId) => {
            updateCurrentNodes(prevNodes => prevNodes.filter(node => node.id !== nodeId));
            if (selectedNodeId === nodeId) {
                setSelectedNodeId(null);
            }
        };

        const indentNode = (nodeId) => {
            updateCurrentNodes(prevNodes => prevNodes.map(node =>
                node.id === nodeId ? { ...node, level: node.level + 1 } : node
            ));
            setSelectedNodeId(null);
        };

        const outdentNode = (nodeId) => {
            updateCurrentNodes(prevNodes => prevNodes.map(node =>
                node.id === nodeId ? { ...node, level: Math.max(0, node.level - 1) } : node
            ));
            setSelectedNodeId(null);
        };

        const toggleTask = (nodeId) => {
            updateCurrentNodes(prevNodes => prevNodes.map(node =>
                node.id === nodeId ? { ...node, isTask: !node.isTask, isCompleted: false } : node
            ));
            setSelectedNodeId(null);
        };

        const toggleComplete = (nodeId) => {
            updateCurrentNodes(prevNodes => prevNodes.map(node =>
                node.id === nodeId ? { ...node, isCompleted: !node.isCompleted } : node
            ));
        };

        const focusNode = (nodeId) => {
            const nodes = getCurrentNodes();
            const node = nodes.find(n => n.id === nodeId);
            if (node) {
                setFocusedNode(node);
            }
            setSelectedNodeId(null);
        };

        const saveFocusNote = (note) => {
            if (focusedNode) {
                updateCurrentNodes(prevNodes => prevNodes.map(node =>
                    node.id === focusedNode.id ? { ...node, note } : node
                ));
            }
            setFocusedNode(null);
        };

        const startLinking = (nodeId) => {
            setLinkingFromNodeId(nodeId);
            setShowLinkPicker(true);
            setSelectedNodeId(null);
        };

        const linkNodes = (targetNodeId) => {
            if (linkingFromNodeId) {
                updateCurrentNodes(prevNodes => prevNodes.map(node =>
                    node.id === linkingFromNodeId ? { ...node, linkedNodeId: targetNodeId } : node
                ));
            }
            setShowLinkPicker(false);
            setLinkingFromNodeId(null);
        };

        const unlinkNode = (nodeId) => {
            updateCurrentNodes(prevNodes => prevNodes.map(node =>
                node.id === nodeId ? { ...node, linkedNodeId: null } : node
            ));
            setSelectedNodeId(null);
        };

        const jumpToLinkedNode = (nodeId) => {
            const nodes = getCurrentNodes();
            const node = nodes.find(n => n.id === nodeId);
            if (node?.linkedNodeId) {
                setSelectedNodeId(node.linkedNodeId);
                
                setTimeout(() => {
                    const element = document.querySelector(`[data-node-id="${node.linkedNodeId}"]`);
                    if (element) {
                        element.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                }, 100);
            }
        };

        const editNode = (nodeId) => {
            setEditingNodeId(nodeId);
            setSelectedNodeId(null);
        };

        const saveEditNode = (nodeId, newContent) => {
            updateCurrentNodes(prevNodes => prevNodes.map(node =>
                node.id === nodeId ? { ...node, content: newContent } : node
            ));
            setEditingNodeId(null);
        };

        const cancelEditNode = () => {
            setEditingNodeId(null);
        };

        const branchOut = (nodeId) => {
            const nodes = getCurrentNodes();
            const currentTree = trees[activeTreeIndex];
            const selectedNode = nodes.find(node => node.id === nodeId);
            
            if (!selectedNode || trees.length >= 5) return;

            const nodeAndChildren = [];
            let foundParent = false;
            
            for (const node of nodes) {
                if (node.id === selectedNode.id) {
                    foundParent = true;
                    nodeAndChildren.push({
                        ...node,
                        level: 0
                    });
                } else if (foundParent && node.level > selectedNode.level) {
                    const levelDifference = node.level - selectedNode.level;
                    nodeAndChildren.push({
                        ...node,
                        level: levelDifference
                    });
                } else if (foundParent && node.level <= selectedNode.level) {
                    break;
                }
            }

            const truncatedTitle = selectedNode.content.length > 20 
                ? selectedNode.content.substring(0, 17) + '...'
                : selectedNode.content;

            // Create minimal breadcrumb
            const newBreadcrumb = [...currentTree.breadcrumb];
            if (currentTree.title !== 'Main Tree') {
                newBreadcrumb.push(currentTree.title);
            }
            
            // Keep breadcrumb concise for mobile
            if (newBreadcrumb.length > 2) {
                newBreadcrumb.splice(0, newBreadcrumb.length - 2);
                newBreadcrumb[0] = '...' + newBreadcrumb[0];
            }

            const newTree = {
                id: generateId(),
                title: truncatedTitle,
                nodes: nodeAndChildren,
                parentTreeId: currentTree.id,
                parentNodeId: selectedNode.id,
                breadcrumb: newBreadcrumb
            };

            setTrees(prev => [...prev, newTree]);
            setActiveTreeIndex(trees.length);
            setSelectedNodeId(null);
            setCurrentIndentLevel(0);
        };

        const generateMarkdown = (useFilteredNodes = false) => {
            return trees.map((tree, index) => {
                const nodesToUse = useFilteredNodes ? getFilteredNodes(tree.nodes) : tree.nodes;
                
                let treeMarkdown = `# ${tree.title}`;
                if (tree.breadcrumb.length > 0) {
                    treeMarkdown += ` (Branch from: ${tree.breadcrumb.join(' > ')})`;
                }
                treeMarkdown += '\n\n';
                
                const nodeMarkdown = nodesToUse.map(node => {
                    const indent = '  '.repeat(node.level);
                    let content = `${indent}- ${node.content}`;
                    
                    if (node.linkedNodeId) {
                        let linkedNode = null;
                        for (const searchTree of trees) {
                            linkedNode = searchTree.nodes.find(n => n.id === node.linkedNodeId);
                            if (linkedNode) break;
                        }
                        if (linkedNode) {
                            content += ` → linked to: ${linkedNode.content}`;
                        }
                    }
                    
                    if (node.note && node.note.trim()) {
                        const noteLines = node.note.split('\n');
                        const indentedNote = noteLines.map(line => `${indent}  > ${line}`).join('\n');
                        content += '\n' + indentedNote;
                    }
                    
                    return content;
                }).join('\n');
                
                return treeMarkdown + (nodeMarkdown || '*Empty tree*');
            }).join('\n\n---\n\n');
        };

        const toggleMarkdownView = () => {
            setShowMarkdownView(!showMarkdownView);
            if (!showMarkdownView) {
                setSelectedNodeId(null);
                setIsInputFocused(false);
            }
        };

        const exportMarkdown = (useFilteredNodes = false) => {
            const markdown = generateMarkdown(useFilteredNodes);
            
            const blob = new Blob([markdown], { type: 'text/markdown' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            const filterSuffix = useFilteredNodes && currentFilter !== 'all' ? `-${currentFilter}` : '';
            a.download = `tree-e-export${filterSuffix}.md`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        };

        const clearAll = () => {
            setTrees([{
                id: 'main',
                title: 'Main Tree',
                nodes: [],
                parentTreeId: null,
                parentNodeId: null,
                breadcrumb: []
            }]);
            setActiveTreeIndex(0);
            setCurrentIndentLevel(0);
            setSelectedNodeId(null);
            setFocusedNode(null);
            setShowClearConfirm(false);
        };

        const manualSave = () => {
            saveToStorage(trees);
            const btn = document.querySelector('.save-btn');
            if (btn) {
                const originalText = btn.textContent;
                btn.textContent = '✓';
                setTimeout(() => {
                    btn.textContent = originalText;
                }, 1000);
            }
        };

        const getBacklinksForNode = (nodeId, nodesToSearch = null) => {
            const nodes = nodesToSearch || getCurrentNodes();
            return nodes.filter(node => node.linkedNodeId === nodeId);
        };

        const getFilteredNodes = (nodesToFilter = null) => {
            const nodes = nodesToFilter || getCurrentNodes();
            switch (currentFilter) {
                case 'tasks':
                    return nodes.filter(node => node.isTask);
                case 'notes':
                    return nodes.filter(node => node.note && node.note.trim());
                case 'linked':
                    return nodes.filter(node => node.linkedNodeId || getBacklinksForNode(node.id, nodes).length > 0);
                default:
                    return nodes;
            }
        };

        const selectedNode = selectedNodeId ? getCurrentNodes().find(node => node.id === selectedNodeId) : null;
        const currentNodes = getCurrentNodes();
        const filteredNodes = getFilteredNodes();

        const handleBackgroundClick = (e) => {
            if (e.target.classList.contains('app') || 
                e.target.classList.contains('main-content') || 
                e.target.classList.contains('trees-container') ||
                e.target.classList.contains('tree-content') ||
                e.target.classList.contains('nodes-container')) {
                
                if (selectedNodeId) {
                    setSelectedNodeId(null);
                    if (currentNodes.length > 0) {
                        setCurrentIndentLevel(currentNodes[currentNodes.length - 1].level);
                    } else {
                        setCurrentIndentLevel(0);
                    }
                }
                setIsInputFocused(false);
                setShowThemeDropdown(false);
                setShowFilterDropdown(false);
                
                // Cancel editing when clicking outside
                if (editingNodeId) {
                    setEditingNodeId(null);
                }
            }
        };

        const filterOptions = [
            { key: 'all', label: 'All Nodes', icon: '◎' },
            { key: 'tasks', label: 'Tasks', icon: '□' },
            { key: 'notes', label: 'With Notes', icon: '◊' },
            { key: 'linked', label: 'Linked', icon: '○—○' }
        ];

        return (
            <div 
                className="app" 
                style={{ 
                    backgroundColor: theme.background,
                    color: theme.text 
                }}
                onClick={handleBackgroundClick}
            >
                <div className="header" style={{ backgroundColor: theme.background, borderColor: theme.border }}>
                    <div className="header-main">
                        <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                            <h1 style={{ color: theme.text }}>Tree-e</h1>
                            {currentFilter !== 'all' && (
                                <span style={{ 
                                    fontSize: 'clamp(0.625rem, 2.5vw, 0.75rem)', 
                                    color: theme.text + '99',
                                    background: theme.border,
                                    padding: '0.125rem 0.375rem',
                                    borderRadius: '4px',
                                    display: 'flex',
                                    alignItems: 'center',
                                    gap: '0.25rem'
                                }}>
                                    {filterOptions.find(f => f.key === currentFilter)?.icon}
                                    {filterOptions.find(f => f.key === currentFilter)?.label}
                                </span>
                            )}
                            {trees.length > 1 && (
                                <span style={{ 
                                    fontSize: 'clamp(0.625rem, 2.5vw, 0.75rem)', 
                                    color: trees.length >= 5 ? 'white' : theme.text + '99',
                                    background: trees.length >= 5 ? '#ef4444' : theme.border,
                                    padding: '0.125rem 0.375rem',
                                    borderRadius: '4px'
                                }}>
                                    {trees.length}/5 trees
                                </span>
                            )}
                        </div>
                        
                        <div style={{ display: 'flex', alignItems: 'center', gap: 'clamp(0.5rem, 2vw, 0.75rem)' }}>
                            {/* Mobile tree navigation */}
                            {isMobile && trees.length > 1 && (
                                <div style={{ display: 'flex', gap: '0.25rem', alignItems: 'center' }}>
                                    <button
                                        className="tree-nav-btn"
                                        onClick={() => setActiveTreeIndex(Math.max(0, activeTreeIndex - 1))}
                                        disabled={activeTreeIndex === 0}
                                        style={{
                                            borderColor: theme.border,
                                            color: theme.text,
                                            background: 'transparent'
                                        }}
                                    >
                                        ‹
                                    </button>
                                    <span style={{ 
                                        fontSize: 'clamp(0.625rem, 2.5vw, 0.75rem)',
                                        color: theme.text,
                                        display: 'flex',
                                        alignItems: 'center',
                                        padding: '0 0.25rem'
                                    }}>
                                        {activeTreeIndex + 1}/{trees.length}
                                    </span>
                                    <button
                                        className="tree-nav-btn"
                                        onClick={() => setActiveTreeIndex(Math.min(trees.length - 1, activeTreeIndex + 1))}
                                        disabled={activeTreeIndex === trees.length - 1}
                                        style={{
                                            borderColor: theme.border,
                                            color: theme.text,
                                            background: 'transparent'
                                        }}
                                    >
                                        ›
                                    </button>
                                </div>
                            )}
                            
                            <div className="header-controls">
                                <FilterDropdown
                                    currentFilter={currentFilter}
                                    onFilterChange={setCurrentFilter}
                                    isOpen={showFilterDropdown}
                                    onToggle={(e) => {
                                        if (e) e.stopPropagation();
                                        setShowFilterDropdown(!showFilterDropdown);
                                    }}
                                    theme={theme}
                                    filterOptions={filterOptions}
                                />
                                
                                <button
                                    className="control-btn"
                                    onClick={(e) => {
                                        e.stopPropagation();
                                        setShowAbout(true);
                                    }}
                                    style={{
                                        backgroundColor: getColorForLevel(theme, 0),
                                        borderColor: theme.border,
                                        color: theme.text
                                    }}
                                >
                                    ◯
                                </button>
                                
                                <button
                                    className="control-btn"
                                    onClick={(e) => {
                                        e.stopPropagation();
                                        toggleMarkdownView();
                                    }}
                                    disabled={trees.length === 0 || trees.every(tree => tree.nodes.length === 0)}
                                    style={{
                                        backgroundColor: showMarkdownView ? theme.text : getColorForLevel(theme, 0),
                                        borderColor: theme.border,
                                        color: showMarkdownView ? theme.background : theme.text
                                    }}
                                >
                                    {showMarkdownView ? '◀' : '▶'}
                                </button>
                                
                                <button
                                    className="control-btn"
                                    onClick={(e) => {
                                        e.stopPropagation();
                                        if (trees.length > 0 && trees.some(tree => tree.nodes.length > 0)) {
                                            setShowClearConfirm(true);
                                        }
                                    }}
                                    disabled={trees.length === 0 || trees.every(tree => tree.nodes.length === 0)}
                                    style={{
                                        backgroundColor: getColorForLevel(theme, 0),
                                        borderColor: theme.border,
                                        color: theme.text
                                    }}
                                >
                                    ╳
                                </button>
                                
                                <ThemeDropdown
                                    currentTheme={currentTheme}
                                    onThemeChange={setCurrentTheme}
                                    isOpen={showThemeDropdown}
                                    onToggle={(e) => {
                                        if (e) e.stopPropagation();
                                        setShowThemeDropdown(!showThemeDropdown);
                                    }}
                                    theme={theme}
                                />
                            </div>
                        </div>
                    </div>
                    
                    {/* Breadcrumb navigation - only show when in branched tree and not main */}
                    {trees.length > 0 && trees[activeTreeIndex]?.breadcrumb?.length > 0 && trees[activeTreeIndex]?.id !== 'main' && (
                        <div className="header-breadcrumb">
                            <div className="header-breadcrumb-text" style={{ color: theme.text }}>
                                {[...trees[activeTreeIndex].breadcrumb, trees[activeTreeIndex].title].join(' / ')}
                            </div>
                        </div>
                    )}
                </div>

                {showMarkdownView ? (
                    <MarkdownView 
                        markdown={generateMarkdown(currentFilter !== 'all')} 
                        theme={theme} 
                        onDownload={() => exportMarkdown(currentFilter !== 'all')}
                    />
                ) : (
                    <div className="main-content">
                        <div className={`trees-container ${isMobile ? 'mobile' : ''}`}>
                            {trees.map((tree, treeIndex) => (
                                <div 
                                    key={tree.id} 
                                    className={`tree-pane ${isMobile ? `mobile ${treeIndex !== activeTreeIndex ? 'hidden' : ''}` : ''}`}
                                >
                                    <div className="tree-content">
                                        <div className="nodes-container" ref={treeIndex === activeTreeIndex ? nodesContainerRef : null}>
                                            {getFilteredNodes(tree.nodes).length === 0 && tree.nodes.length > 0 && currentFilter !== 'all' ? (
                                                <div className="empty-state">
                                                    <div className="empty-icon">{filterOptions.find(f => f.key === currentFilter)?.icon}</div>
                                                    <div className="empty-title">No {filterOptions.find(f => f.key === currentFilter)?.label.toLowerCase()} found</div>
                                                    <div className="empty-desc">
                                                        Try a different filter or add some {currentFilter === 'tasks' ? 'task nodes' : currentFilter === 'notes' ? 'notes to your nodes' : 'links between nodes'}.
                                                    </div>
                                                </div>
                                            ) : getFilteredNodes(tree.nodes).length === 0 ? (
                                                <div className="empty-state">
                                                    <div className="empty-icon">🌱</div>
                                                    <div className="empty-title">Empty tree</div>
                                                    <div className="empty-desc">
                                                        {tree.id === 'main' ? 'Start your Tree-e by adding your first thought below.' : 'This branch is ready for new ideas.'}
                                                    </div>
                                                </div>
                                            ) : (
                                                getFilteredNodes(tree.nodes).map(node => (
                                                    <div key={node.id} data-node-id={node.id}>
                                                        <NodeComponent
                                                            node={node}
                                                            theme={theme}
                                                            isSelected={selectedNodeId === node.id && treeIndex === activeTreeIndex}
                                                            backlinks={getBacklinksForNode(node.id, tree.nodes)}
                                                            treesLength={trees.length}
                                                            editingNodeId={editingNodeId}
                                                            onTap={(e) => {
                                                                e.stopPropagation();
                                                                
                                                                if (isMobile) {
                                                                    setActiveTreeIndex(treeIndex);
                                                                }
                                                                
                                                                if (selectedNodeId === node.id && activeTreeIndex === treeIndex) {
                                                                    setSelectedNodeId(null);
                                                                    if (tree.nodes.length > 0) {
                                                                        setCurrentIndentLevel(tree.nodes[tree.nodes.length - 1].level);
                                                                    } else {
                                                                        setCurrentIndentLevel(0);
                                                                    }
                                                                } else {
                                                                    setSelectedNodeId(node.id);
                                                                    setSelectedTreeIndex(treeIndex);
                                                                    setActiveTreeIndex(treeIndex);
                                                                    setCurrentIndentLevel(node.level + 1);
                                                                    
                                                                    setTimeout(() => {
                                                                        const element = document.querySelector(`[data-node-id="${node.id}"]`);
                                                                        if (element) {
                                                                            element.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                                                        }
                                                                    }, 100);
                                                                }
                                                            }}
                                                            onIndent={() => indentNode(node.id)}
                                                            onOutdent={() => outdentNode(node.id)}
                                                            onDelete={() => deleteNode(node.id)}
                                                            onFocus={() => focusNode(node.id)}
                                                            onToggleTask={() => toggleTask(node.id)}
                                                            onToggleComplete={() => toggleComplete(node.id)}
                                                            onLink={() => startLinking(node.id)}
                                                            onUnlink={() => unlinkNode(node.id)}
                                                            onJumpToLink={() => jumpToLinkedNode(node.id)}
                                                            onBranchOut={() => {
                                                                if (trees.length < 5) {
                                                                    branchOut(node.id);
                                                                }
                                                            }}
                                                            onEdit={() => editNode(node.id)}
                                                            onSaveEdit={saveEditNode}
                                                            onCancelEdit={cancelEditNode}
                                                        />
                                                    </div>
                                                ))
                                            )}
                                        </div>
                                    </div>
                                </div>
                            ))}
                        </div>
                    </div>
                )}

                {!showMarkdownView && (
                    <div className="input-area" style={{ backgroundColor: theme.background, borderColor: theme.border }}>
                        {isInputFocused && (
                            <div className="indent-controls">
                                <button
                                    className="indent-btn"
                                    onClick={() => setCurrentIndentLevel(prev => Math.max(0, prev - 1))}
                                    disabled={currentIndentLevel === 0}
                                    style={{
                                        backgroundColor: getColorForLevel(theme, 0),
                                        borderColor: theme.border,
                                        color: theme.text
                                    }}
                                >
                                    ← Outdent
                                </button>
                                <button
                                    className="indent-btn"
                                    onClick={() => setCurrentIndentLevel(prev => prev + 1)}
                                    style={{
                                        backgroundColor: getColorForLevel(theme, 0),
                                        borderColor: theme.border,
                                        color: theme.text
                                    }}
                                >
                                    Indent →
                                </button>
                            </div>
                        )}
                        
                        <div 
                            className="input-container"
                            style={{
                                borderColor: theme.border,
                                backgroundColor: theme.background
                            }}
                            onClick={(e) => {
                                e.stopPropagation();
                                setIsInputFocused(true);
                                inputRef.current?.focus();
                            }}
                            {...inputSwipeHandlers}
                        >
                            <div className="input-prompt" style={{ color: theme.prompt }}>
                                >
                            </div>
                            
                            {currentIndentLevel > 0 && (
                                <div className="indent-indicator" style={{ color: theme.prompt }}>
                                    {'  │'.repeat(currentIndentLevel)}
                                </div>
                            )}
                            
                            <input
                                ref={inputRef}
                                className="main-input"
                                type="text"
                                value={currentInput}
                                onChange={(e) => setCurrentInput(e.target.value)}
                                onKeyPress={(e) => {
                                    if (e.key === 'Enter') {
                                        addNode();
                                    }
                                }}
                                onFocus={() => {
                                    setIsInputFocused(true);
                                }}
                                placeholder={trees.length > 0 ? (
                                    trees[activeTreeIndex]?.breadcrumb?.length > 0 
                                        ? `Add to ${trees[activeTreeIndex].breadcrumb[trees[activeTreeIndex].breadcrumb.length - 1]}...`
                                        : "Add to tree..."
                                ) : "Start your Tree-e..."}
                                style={{ color: theme.text }}
                            />
                        </div>
                        
                        {selectedNode && (
                            <div 
                                className="context-indicator"
                                style={{
                                    backgroundColor: getColorForLevel(theme, 0),
                                    borderColor: theme.border,
                                    color: theme.text
                                }}
                            >
                                ↳ Next node will be added as child of: "{selectedNode.content}" (Level {selectedNode.level + 1})
                            </div>
                        )}
                        
                        {trees.length === 0 || (trees.length === 1 && currentNodes.length === 0) ? (
                            <div className="instructions" style={{ color: theme.text }}>
                                Swipe right to indent • Swipe left to outdent • Swipe on input box to adjust level • Return to add node • Link to connect thoughts
                            </div>
                        ) : currentFilter !== 'all' && (
                            <div className="instructions" style={{ color: theme.text }}>
                                Showing {filteredNodes.length} of {currentNodes.length} nodes • Filter: {filterOptions.find(f => f.key === currentFilter)?.label}
                                {trees[activeTreeIndex]?.breadcrumb?.length > 0 && ` • Path: ${[...trees[activeTreeIndex].breadcrumb, trees[activeTreeIndex].title].join(' / ')}`}
                            </div>
                        )}
                    </div>
                )}

                <AboutView
                    isOpen={showAbout}
                    onClose={() => setShowAbout(false)}
                    theme={theme}
                />
                
                <FocusView
                    isOpen={!!focusedNode}
                    onClose={() => setFocusedNode(null)}
                    node={focusedNode}
                    theme={theme}
                    onSave={saveFocusNote}
                />
                
                <LinkPickerView
                    isOpen={showLinkPicker}
                    onClose={() => {
                        setShowLinkPicker(false);
                        setLinkingFromNodeId(null);
                    }}
                    nodes={getCurrentNodes()}
                    fromNodeId={linkingFromNodeId}
                    theme={theme}
                    onLink={linkNodes}
                />

                {showClearConfirm && (
                    <Modal 
                        isOpen={showClearConfirm} 
                        onClose={() => setShowClearConfirm(false)} 
                        title={trees.length > 1 ? "Clear your entire forest?" : "Clear your garden?"} 
                        theme={theme}
                    >
                        <div style={{ marginBottom: '16px' }}>
                            {trees.length > 1 ? (
                                currentTheme === 'espresso' ? 
                                    "This will empty all your cups and clear every tree. A fresh forest of inspiration awaits." :
                                currentTheme === 'alienGuts' ?
                                    "This will dissolve your entire thought ecosystem back into the cosmic void. New alien wisdom awaits discovery across the multiverse." :
                                currentTheme === 'neon' ?
                                    "This will power down your entire electric network. A fresh surge of connected inspiration awaits." :
                                    "This will remove all your trees and every carefully cultivated thought. Your entire forest cannot be replanted once cleared."
                            ) : (
                                currentTheme === 'espresso' ? 
                                    "This will empty your cup of all brewing thoughts. A fresh roast awaits your inspiration." :
                                currentTheme === 'alienGuts' ?
                                    "This will dissolve all your otherworldly thoughts back into the cosmic void. New alien wisdom awaits your discovery." :
                                currentTheme === 'neon' ?
                                    "This will power down all your electric thoughts. A fresh surge of inspiration awaits." :
                                    "This will remove all your carefully cultivated thoughts. They cannot be replanted once cleared."
                            )}
                        </div>
                        <div style={{ display: 'flex', gap: '12px', justifyContent: 'flex-end' }}>
                            <button
                                onClick={() => setShowClearConfirm(false)}
                                style={{
                                    background: theme.border,
                                    color: theme.text,
                                    border: 'none',
                                    padding: '8px 16px',
                                    borderRadius: '6px',
                                    cursor: 'pointer'
                                }}
                            >
                                Cancel
                            </button>
                            <button
                                onClick={clearAll}
                                style={{
                                    background: '#ef4444',
                                    color: 'white',
                                    border: 'none',
                                    padding: '8px 16px',
                                    borderRadius: '6px',
                                    cursor: 'pointer'
                                }}
                            >
                                Clear All
                            </button>
                        </div>
                    </Modal>
                )}
            </div>
        );
    };

    ReactDOM.render(<TreeApp />, document.getElementById('root'));

    if ('serviceWorker' in navigator) {
        const swCode = `
            const CACHE_NAME = 'tree-e-v1';
            const urlsToCache = [
                '/',
                '/index.html'
            ];

            self.addEventListener('install', event => {
                event.waitUntil(
                    caches.open(CACHE_NAME)
                        .then(cache => cache.addAll(urlsToCache))
                );
            });

            self.addEventListener('fetch', event => {
                event.respondWith(
                    caches.match(event.request)
                        .then(response => {
                            if (response) {
                                return response;
                            }
                            return fetch(event.request);
                        })
                );
            });
        `;
        
        const blob = new Blob([swCode], { type: 'application/javascript' });
        const swUrl = URL.createObjectURL(blob);
        
        navigator.serviceWorker.register(swUrl)
            .then(registration => {
                console.log('SW registered: ', registration);
            })
            .catch(registrationError => {
                console.log('SW registration failed: ', registrationError);
            });
    }
</script>

</body>
</html>
