<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tree-e - Hierarchical Note Taking</title>

<!-- PWA Meta Tags -->

<meta name="description" content="Tree-e: Hierarchical note-taking app with beautiful themes">
<meta name="theme-color" content="#e9f5e9">
<link rel="icon" type="image/svg+xml" href="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgd2lkdGg9IjQwOTYiIGhlaWdodD0iNDA5NiIgdmlld0JveD0iMCAwIDQwOTYgNDA5NiI+PHJlY3Qgd2lkdGg9IjQwOTYiIGhlaWdodD0iNDA5NiIgZmlsbD0iI2U4ZTllNiIvPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDIwNDggMjA0OCkiPjxwYXRoIGQ9Ik00MDcuNTAxLDEzNTAuMDQgTDAsLTEzNTAuMDQgTC00MDcuNTAxLDEzNTAuMDQgTDQwNy41MDEsMTM1MC4wNCBaIiBmaWxsPSIjMzgyNDE4Ii8+PHBhdGggZD0iTS05LjA3NTIyZS0wNiwtOTQ1LjM2MiBDLTkuMDc1MjJlLTA2LC04MTUuNzA2IDEwNS44NjYsLTcwOS44NCAyMzUuNTIyLC03MDkuODQgTDk0MC45LC03MDkuODQgQzEwNzAuNTYsLTcwOS44NCAxMTc2LjQyLC04MTUuNzA2IDExNzYuNDIsLTk0NS4zNjIgQzExNzYuNDIsLTEwNzUuMDIgMTA3MC41NiwtMTE4MC44OCA5NDAuOSwtMTE4MC44OCBMMjM1LjUyMiwtMTE4MC44OCBDMTA1Ljg2NiwtMTE4MC44OCAtOS4wNzUyMmUtMDYsLTEwNzUuMDIgLTkuMDc1MjJlLTA2LC05NDUuMzYyIFoiIGZpbGw9IiM5YWJjNDUiLz48cGF0aCBkPSJNMTE3Ni40MiwtOTkuNTk1OSBDMTE3Ni40MiwzMC4wNjA0IDEwNzAuNTYsMTM1LjkyNiA5NDAuOSwxMzUuOTI2IEwyMzUuNTIyLDEzNS45MjYgQzEwNS44NjYsMTM1LjkyNiAtMy40MTA2MWUtMTMsMzAuMDYwNCAtMy40MTA2MWUtMTMsLTk5LjU5NTkgQy0zLjQxMDYxZS0xMywtMjI5LjI1MiAxMDUuODY2LC0zMzUuMTE4IDIzNS41MjIsLTMzNS4xMTggTDk0MC45LC0zMzUuMTE4IEMxMDcwLjU2LC0zMzUuMTE4IDExNzYuNDIsLTIyOS4yNTIgMTE3Ni40MiwtOTkuNTk1OSBaIiBmaWxsPSIjOWFiYzQ1Ii8+PHBhdGggZD0iTS0yLjI3Mzc0ZS0xMywtNTcwLjY0MSBDLTIuMjczNzRlLTEzLC00NDAuOTg0IC0xMDUuODY2LC0zMzUuMTE4IC0yMzUuNTIyLC0zMzUuMTE4IEwtOTQwLjksLTMzNS4xMTggQy0xMDcwLjU2LC0zMzUuMTE4IC0xMTc2LjQyLC00NDAuOTg0IC0xMTc2LjQyLC01NzAuNjQxIEMtMTE3Ni40MiwtNzAwLjI5NyAtMTA3MC41NiwtODA2LjE2MyAtOTQwLjksLTgwNi4xNjMgTC0yMzUuNTIyLC04MDYuMTYzIEMtMTA1Ljg2NiwtODA2LjE2MyAtMi4yNzM3NGUtMTMsLTcwMC4yOTcgLTIuMjczNzRlLTEzLC01NzAuNjQxIFoiIGZpbGw9IiNlMWY5YTQiLz48cGF0aCBkPSJNMCwzMjIuMjIxIEMwLDQ1MS44NzggLTEwNS44NjYsNTU3Ljc0NCAtMjM1LjUyMiw1NTcuNzQ0IEwtOTQwLjksNTU3Ljc0NCBDLTEwNzAuNTYsNTU3Ljc0NCAtMTE3Ni40Miw0NTEuODc4IC0xMTc2LjQyLDMyMi4yMjEgQy0xMTc2LjQyLDE5Mi41NjUgLTEwNzAuNTYsODYuNjk5IC05NDAuOSw4Ni42OTkgTC0yMzUuNTIyLDg2LjY5OSBDLTEwNS44NjYsODYuNjk5IDAsMTkyLjU2NSAwLDMyMi4yMjEgWiIgZmlsbD0iIzY0N2YyMSIvPjwvZz48L3N2Zz4=">
<link rel="manifest" href="data:application/json;base64,eyJuYW1lIjoiVHJlZS1lIiwic2hvcnRfbmFtZSI6IlRyZWUtZSIsImRpc3BsYXkiOiJzdGFuZGFsb25lIiwic3RhcnRfdXJsIjoiLyIsInRoZW1lX2NvbG9yIjoiI2U5ZjVlOSIsImJhY2tncm91bmRfY29sb3IiOiIjZTlmNWU5IiwiaWNvbnMiOlt7InNyYyI6ImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjJaWEp6YVc5dVBTSXhMakVpSUhodGJHNXpQU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh5TURBd0wzTjJaeUlnZDJsa2RHZzlJalF3T1RZaUlHaGxhV2RvZEQwaU5EQTVOaUlnZG1sbGQwSnZlRDBpTUNBd0lEUXdPVFlnTkRBNU5pSStQSEpsWTNRZ2QybGtkR2c5SWpRd09UWWlJR2hsYVdkb2REMGlOREE1TmlJZ1ptbHNiRDBpSTJVNFpUbGxOaUl2UGp4bklIUnlZVzV6Wm05eWJUMGlkSEpoYm5Oc1lYUmxLREkxTkRrZ01qVTBPQ2tpUGp4d1lYUm9JR1E5SWswME1EY3VOVEF4TERFek5UQXVNRFFnVERBc0xURXpOVEF1TURRZ1RDMDBNRGN1TlRBeExERXpOVEF1TkRRZ1REUXdOeTQxTURFc01UTTFNQzR3TkNCV2lGZGlhV3hzUFNJak16Z3lOREU0SWk4K1BIQmhkR2dnWkQwaVRTMDVMakEzTlRJeVpTMHdOaXd0T1RRMUXTTTJJRU10T1M0d056VXlNbVV0TURZC0xUZ3hOUzQzTURZZ01UQTFMamcyTml3dE56QTVMamcwSURJek5TNDFNaklzTFRjd09TNDRORXhPVUVKOU9RUXVPUkJRTWpRMUxqQXhNVHBqRkRZMUxqRTNOaklDTFRjeU1TNDBNak1nTXpjek5pNDVOVHh4VFRsR2VEQk1OUzB5TlNFUWp0ekxtbHNiRDBpSXprZ1ltTXpORlVpTHo0OGNHRjBhQ0JrUFNKTk1URTNOaTQwTWl3dE9UazFOVFE1SUVNeE1URTNOaTQwTWl3ek1DNDBNalJCUUUxd056VXVOall3TkRrZ01UUTFMREF5TmkxT1FEVTJMVEE0TVRjeU5qWWdNVE0xT1M0eU16WmhNVEkwTlM0MU1paXNMVGN3TWpRbU5IVXVPVkJEWWlKcE1UQXpNMEl0SWpGb2VEQWdMMDBpTFRjeU1TMDBNak1nTXpjNE5pNDVOUkJSVFRsR2VEQk1OUzB5TlNFUWp0ekxtbHNiRDBpSXprZ1ltTXpORlVpTHo0OGNHRjBhQ0JrUFNKTk1URTNOaTQwTWl3dE9UazFOVFE1SUVNeE1URTNOaTQwTWl3ek1DNDBNelFnTVRBMU5paTB4Y1E5dE1qVjJNakp5TlZaWWVCQlFNakU3Yyt1NGdNall6SXdFZ01UQXpNMEhnPSIsInR5cGUiOiJpbWFnZS9zdmcreG1sIiwic2l6ZXMiOiI0MDk2eDQwOTYifV19">

<!-- React and Babel -->

<script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>

<script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>

<script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>

<!-- QR Code Libraries -->

<script src="https://cdnjs.cloudflare.com/ajax/libs/qrcode/1.5.3/qrcode.min.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/lz-string/1.4.4/lz-string.min.js"></script>

<!-- Fonts -->

<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">

<style>
    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
    }
    
    body {
        font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        touch-action: manipulation;
        user-select: none;
        -webkit-user-select: none;
        -webkit-tap-highlight-color: transparent;
        overflow-x: hidden;
        font-size: 16px;
    }
    
    .app {
        height: 100vh;
        height: 100dvh;
        display: flex;
        flex-direction: column;
        overflow: hidden;
        width: 100vw;
    }
    
    .header {
        display: flex;
        flex-direction: column;
        padding: 1rem;
        flex-shrink: 0;
        border-bottom: 1px solid rgba(0,0,0,0.08);
        gap: 0.5rem;
    }
    
    .header-main {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.75rem;
    }
    
    .header-left {
        display: flex;
        align-items: center;
        gap: 0.75rem;
    }
    
    .header-title {
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }
    
    .header h1 {
        font-size: clamp(1rem, 4vw, 1.25rem);
        font-weight: 600;
        margin: 0;
    }
    
    .tree-dots {
        display: flex;
        gap: 4px;
        align-items: center;
    }
    
    .tree-dot {
        width: 6px;
        height: 6px;
        border-radius: 50%;
        transition: all 0.2s ease;
    }
    
    .tree-dot.active {
        width: 8px;
        height: 8px;
    }
    
    .badge {
        font-size: clamp(0.625rem, 2.5vw, 0.75rem);
        padding: 0.125rem 0.375rem;
        border-radius: 4px;
        display: flex;
        align-items: center;
        gap: 0.25rem;
    }
    
    .header-controls {
        display: flex;
        gap: clamp(0.375rem, 2vw, 0.5rem);
        align-items: center;
        position: relative;
    }
    
    .control-btn {
        width: clamp(32px, 8vw, 36px);
        height: clamp(32px, 8vw, 36px);
        border: 1px solid;
        border-radius: 6px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: clamp(0.875rem, 3vw, 1rem);
        cursor: pointer;
        background: transparent;
        flex-shrink: 0;
        transition: transform 0.1s ease;
    }
    
    .control-btn:active {
        transform: scale(0.95);
    }
    
    .control-btn:disabled {
        opacity: 0.4;
        cursor: not-allowed;
        transform: none;
    }
    
    .menu-btn {
        width: clamp(36px, 8vw, 40px);
        height: clamp(36px, 8vw, 40px);
        border: 1px solid;
        border-radius: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: clamp(0.875rem, 3vw, 1rem);
        cursor: pointer;
        background: transparent;
        transition: transform 0.1s ease;
    }
    
    .menu-btn:active {
        transform: scale(0.95);
    }
    
    .tree-nav {
        display: flex;
        gap: 0.25rem;
        align-items: center;
    }
    
    .nav-btn {
        width: 28px;
        height: 28px;
        border: 1px solid;
        border-radius: 4px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 0.75rem;
        cursor: pointer;
        background: transparent;
    }
    
    .nav-counter {
        font-size: 0.75rem;
        padding: 0 0.25rem;
        font-family: 'JetBrains Mono', monospace;
    }
    
    .breadcrumbs {
        display: flex;
        align-items: center;
        gap: 0.25rem;
        flex-wrap: wrap;
        font-family: 'JetBrains Mono', monospace;
        font-size: clamp(0.6875rem, 2vw, 0.75rem);
    }
    
    .breadcrumb-btn {
        background: none;
        border: none;
        cursor: pointer;
        text-decoration: underline;
        font: inherit;
    }
    
    .breadcrumb-sep {
        opacity: 0.6;
    }
    
    .breadcrumb-current {
        font-weight: 600;
        opacity: 1;
    }
    
    .close-btn {
        background: #22c55e;
        color: white;
        border: none;
        padding: 0.25rem 0.5rem;
        border-radius: 4px;
        font-size: 0.75rem;
        cursor: pointer;
        margin-left: 0.5rem;
    }
    
    .main-content {
        flex: 1;
        overflow: hidden;
        display: flex;
        flex-direction: column;
        position: relative;
    }
    
    .tree-container {
        flex: 1;
        overflow-y: auto;
        overflow-x: hidden;
        padding: clamp(0.75rem, 3vw, 1rem);
        position: relative;
    }
    
    .swipe-hints {
        position: absolute;
        top: 0;
        bottom: 0;
        width: 20px;
        pointer-events: none;
        z-index: 10;
        opacity: 0.3;
        transition: opacity 0.2s ease;
    }
    
    .swipe-hint-left {
        left: 0;
        background: linear-gradient(to right, rgba(0,0,0,0.1), transparent);
    }
    
    .swipe-hint-right {
        right: 0;
        background: linear-gradient(to left, rgba(0,0,0,0.1), transparent);
    }
    
    .swipe-hints.visible {
        opacity: 0.6;
    }
    
    .nodes-list {
        display: flex;
        flex-direction: column;
        gap: 0.125rem;
        padding-bottom: 2rem;
    }
    
    .node {
        display: flex;
        align-items: flex-start;
        gap: 0;
    }
    
    .node-indent {
        display: flex;
        flex-shrink: 0;
    }
    
    .indent-space {
        width: clamp(24px, 5vw, 32px);
    }
    
    .node-content-wrapper {
        display: flex;
        flex-direction: column;
        align-items: flex-start;
    }
    
    .node-content {
        padding: 8px 12px;
        border-radius: 6px;
        border: 1px solid;
        cursor: pointer;
        display: inline-flex;
        align-items: center;
        gap: 8px;
        word-wrap: break-word;
        overflow-wrap: break-word;
        transition: transform 0.1s ease;
        max-width: calc(100vw - 60px);
        width: auto;
    }
    
    .node-content:active {
        transform: scale(0.98);
    }
    
    .node-content.selected {
        border-width: 2px;
    }
    
    .node-content.completed {
        opacity: 0.6;
    }
    
    .task-toggle {
        font-size: 16px;
        cursor: pointer;
        flex-shrink: 0;
    }
    
    .node-text {
        flex: 1;
        font-size: clamp(0.875rem, 3vw, 1rem);
        line-height: 1.4;
        min-width: 0;
    }
    
    .node-text.completed {
        text-decoration: line-through;
    }
    
    .node-icons {
        display: flex;
        gap: 4px;
        font-size: 12px;
        opacity: 0.7;
        flex-shrink: 0;
    }
    
    .branch-link {
        color: #3b82f6;
        cursor: pointer;
        opacity: 1;
    }
    
    .node-actions {
        display: flex;
        gap: 6px;
        margin-top: 8px;
        flex-wrap: wrap;
    }
    
    .action-btn {
        display: flex;
        align-items: center;
        gap: 4px;
        padding: 5px 10px;
        border: none;
        border-radius: 4px;
        font-size: 11px;
        color: white;
        cursor: pointer;
        transition: transform 0.1s ease;
    }
    
    .action-btn:active {
        transform: scale(0.95);
    }
    
    .action-btn.edit { background: #6366f1; }
    .action-btn.task { background: #22c55e; }
    .action-btn.focus { background: #3b82f6; }
    .action-btn.branch { background: #10b981; }
    .action-btn.delete { background: #ef4444; }
    .action-btn.save { background: #22c55e; }
    .action-btn.cancel { background: #6b7280; }
    
    .node-edit-input {
        background: transparent;
        border: none;
        outline: none;
        font: inherit;
        width: 100%;
        min-width: 100px;
    }
    
    .input-area {
        flex-shrink: 0;
        padding: 16px;
        border-top: 1px solid rgba(0,0,0,0.08);
    }
    
    .input-container {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 12px 16px;
        border: 1px solid;
        border-radius: 8px;
        cursor: text;
    }
    
    .input-prompt {
        font-family: 'JetBrains Mono', monospace;
        font-size: 20px;
        font-weight: 500;
    }
    
    .indent-indicator {
        font-family: 'JetBrains Mono', monospace;
        font-size: 12px;
        opacity: 0.6;
    }
    
    .main-input {
        flex: 1;
        border: none;
        outline: none;
        background: transparent;
        font-family: 'JetBrains Mono', monospace;
        font-size: 16px;
    }
    
    .main-input::placeholder {
        opacity: 0.6;
    }
    
    .instructions {
        margin-top: 10px;
        font-family: 'JetBrains Mono', monospace;
        font-size: 11px;
        opacity: 0.6;
        text-align: center;
        line-height: 1.4;
    }
    
    .empty-state {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 1rem;
        padding: 3rem 1rem;
        text-align: center;
    }
    
    .empty-icon {
        font-size: 2.5rem;
        opacity: 0.6;
    }
    
    .empty-title {
        font-size: 1rem;
        font-weight: 500;
    }
    
    .empty-desc {
        font-size: 0.875rem;
        opacity: 0.7;
        line-height: 1.4;
    }
    
    .modal {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0,0,0,0.5);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000;
        padding: 20px;
    }
    
    .modal-content {
        width: 100%;
        max-width: 500px;
        max-height: 80vh;
        border-radius: 8px;
        overflow: hidden;
        display: flex;
        flex-direction: column;
    }
    
    .modal-header {
        padding: 16px;
        border-bottom: 1px solid rgba(0,0,0,0.08);
        display: flex;
        align-items: center;
        justify-content: space-between;
    }
    
    .modal-title {
        font-size: 16px;
        font-weight: 600;
        margin: 0;
    }
    
    .modal-close {
        background: none;
        border: none;
        font-size: 16px;
        cursor: pointer;
        padding: 4px;
    }
    
    .modal-body {
        flex: 1;
        overflow-y: auto;
        padding: 16px;
    }
    
    .note-editor {
        width: 100%;
        min-height: 200px;
        padding: 12px;
        border: 1px solid rgba(0,0,0,0.15);
        border-radius: 6px;
        font-size: 14px;
        font-family: inherit;
        resize: vertical;
    }
    
    .dropdown {
        position: relative;
        display: inline-block;
        z-index: 100;
    }
    
    .dropdown-content {
        position: absolute;
        top: 100%;
        right: 0;
        border-radius: 6px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        z-index: 1000;
        min-width: 140px;
        max-height: 300px;
        overflow-y: auto;
        border: 1px solid;
    }
    
    .dropdown-item {
        padding: 8px 12px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: space-between;
        border: none;
        background: none;
        width: 100%;
        text-align: left;
        font-size: 0.875rem;
        transition: background-color 0.15s ease;
    }
    
    .dropdown-item:hover {
        background: rgba(0,0,0,0.08);
    }
    
    .dropdown-item:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }
    
    .markdown-view {
        display: flex;
        flex-direction: column;
        flex: 1;
        overflow: hidden;
    }
    
    .markdown-header {
        padding: 1rem;
        border-bottom: 1px solid rgba(0,0,0,0.08);
        display: flex;
        justify-content: flex-end;
    }
    
    .download-btn {
        border: none;
        padding: 8px 16px;
        border-radius: 6px;
        font-size: 0.875rem;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }
    
    .markdown-content {
        flex: 1;
        overflow: auto;
        padding: 1rem;
        font-family: 'JetBrains Mono', monospace;
        white-space: pre-wrap;
        line-height: 1.6;
        font-size: 0.875rem;
    }

    /* QR Code specific styles */
    .qr-display {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 1rem;
        text-align: center;
    }

    .qr-code {
        padding: 1rem;
        background: white;
        border-radius: 8px;
        display: inline-block;
    }

    .qr-instructions {
        font-size: 0.875rem;
        opacity: 0.8;
        line-height: 1.4;
    }

    .qr-scanner {
        position: relative;
        width: 100%;
        max-width: 300px;
        aspect-ratio: 1;
        margin: 0 auto;
        border-radius: 8px;
        overflow: hidden;
        background: #000;
    }

    .qr-video {
        width: 100%;
        height: 100%;
        object-fit: cover;
    }

    .qr-overlay {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 200px;
        height: 200px;
        border: 2px solid #22c55e;
        border-radius: 8px;
        box-shadow: 0 0 0 99999px rgba(0,0,0,0.5);
    }

    .qr-overlay::before {
        content: '';
        position: absolute;
        top: -1px;
        left: -1px;
        right: -1px;
        bottom: -1px;
        border: 2px solid #22c55e;
        border-radius: 8px;
        animation: qr-scan 2s ease-in-out infinite;
    }

    @keyframes qr-scan {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.5; }
    }

    .sync-options {
        display: flex;
        flex-direction: column;
        gap: 1rem;
    }

    .sync-option {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 1rem;
        border: 1px solid;
        border-radius: 8px;
        cursor: pointer;
        transition: background-color 0.15s ease;
    }

    .sync-option:hover {
        background: rgba(0,0,0,0.05);
    }

    .sync-option-info {
        display: flex;
        flex-direction: column;
        gap: 0.25rem;
    }

    .sync-option-title {
        font-weight: 500;
        font-size: 0.875rem;
    }

    .sync-option-desc {
        font-size: 0.75rem;
        opacity: 0.7;
    }

    .sync-option-icon {
        font-size: 1.5rem;
    }

    .file-input {
        display: none;
    }

    .file-drop-zone {
        border: 2px dashed;
        border-radius: 8px;
        padding: 2rem;
        text-align: center;
        cursor: pointer;
        transition: background-color 0.15s ease;
    }

    .file-drop-zone:hover {
        background: rgba(0,0,0,0.05);
    }

    .file-drop-zone.drag-over {
        background: rgba(34, 197, 94, 0.1);
        border-color: #22c55e;
    }
    
    /* Mobile specific styles */
    @media (max-width: 768px) {
        .header {
            padding: 0.75rem;
        }
        
        .header h1 {
            font-size: 0.875rem;
        }
        
        .control-btn {
            width: 32px;
            height: 32px;
            font-size: 0.875rem;
        }
        
        .action-btn span {
            display: none;
        }
        
        .node-text {
            font-size: 0.875rem;
        }
        
        .main-input {
            font-size: 0.875rem;
        }
        
        .input-prompt {
            font-size: 1.125rem;
        }

        .qr-scanner {
            max-width: 250px;
        }
    }
</style>

</head>
<body>
    <div id="root"></div>

<script type="text/babel">
    const { useState, useEffect, useRef } = React;

    // Theme definitions - Simplified to essentials
    const builtInThemes = {
        light: {
            name: 'Light',
            background: '#fafafa',
            text: '#0a0a0a',
            prompt: '#525252',
            border: '#e5e5e5',
            levelColors: ['#ffffff', '#f8f8f8', '#f0f0f0', '#e8e8e8', '#d6d6d6']
        },
        dark: {
            name: 'Dark',
            background: '#0a0b14',
            text: '#e2e4e9',
            prompt: '#9ca3af',
            border: '#2d3748',
            levelColors: ['#1a1b26', '#24283b', '#414868', '#565f89', '#7c7f93']
        }
    };

    // Utility functions
    const generateId = () => Date.now().toString(36) + Math.random().toString(36).substr(2);

    const getColorForLevel = (theme, level) => {
        if (level < theme.levelColors.length) {
            return theme.levelColors[level];
        } else {
            const baseColorIndex = level % theme.levelColors.length;
            return theme.levelColors[baseColorIndex] + '80';
        }
    };

    // Dynamic text color based on background brightness
    const getTextColorForBackground = (backgroundColor) => {
        // Convert hex to RGB
        const hex = backgroundColor.replace('#', '');
        const r = parseInt(hex.substr(0, 2), 16);
        const g = parseInt(hex.substr(2, 2), 16);
        const b = parseInt(hex.substr(4, 2), 16);
        
        // Calculate brightness (0-255)
        const brightness = (r * 299 + g * 587 + b * 114) / 1000;
        
        // Return light text for dark backgrounds, dark text for light backgrounds
        return brightness < 128 ? '#ffffff' : '#000000';
    };

    // Storage utilities
    const saveToStorage = (trees) => {
        try {
            localStorage.setItem('tree-e-trees', JSON.stringify(trees));
        } catch (error) {
            console.error('Failed to save trees:', error);
        }
    };

    const loadFromStorage = () => {
        try {
            const saved = localStorage.getItem('tree-e-trees');
            if (saved) {
                return JSON.parse(saved);
            }
            
            // Migration from old format
            const oldNodes = localStorage.getItem('tree-e-nodes');
            if (oldNodes) {
                return [{
                    id: 'main',
                    title: 'Main Tree',
                    nodes: JSON.parse(oldNodes),
                    parentTreeId: null,
                    parentNodeId: null,
                    breadcrumb: []
                }];
            }
            
            return [{
                id: 'main',
                title: 'Main Tree',
                nodes: [],
                parentTreeId: null,
                parentNodeId: null,
                breadcrumb: []
            }];
        } catch (error) {
            console.error('Failed to load trees:', error);
            return [{
                id: 'main',
                title: 'Main Tree',
                nodes: [],
                parentTreeId: null,
                parentNodeId: null,
                breadcrumb: []
            }];
        }
    };

    const saveThemeToStorage = (themeName) => {
        try {
            localStorage.setItem('tree-e-theme', themeName);
        } catch (error) {
            console.error('Failed to save theme:', error);
        }
    };

    const loadThemeFromStorage = () => {
        try {
            return localStorage.getItem('tree-e-theme') || 'light';
        } catch (error) {
            console.error('Failed to load theme:', error);
            return 'light';
        }
    };

    // Custom theme management
    const saveCustomThemes = (customThemes) => {
        try {
            localStorage.setItem('tree-e-custom-themes', JSON.stringify(customThemes));
        } catch (error) {
            console.error('Failed to save custom themes:', error);
        }
    };

    const loadCustomThemes = () => {
        try {
            const saved = localStorage.getItem('tree-e-custom-themes');
            return saved ? JSON.parse(saved) : {};
        } catch (error) {
            console.error('Failed to load custom themes:', error);
            return {};
        }
    };

    const deleteCustomTheme = (themeKey) => {
        const customThemes = loadCustomThemes();
        delete customThemes[themeKey];
        saveCustomThemes(customThemes);
        return customThemes;
    };

    // QR Code utilities - Simplified approach without external crypto dependencies
    const generateRandomKey = () => {
        return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
    };

    const simpleEncrypt = (data, key) => {
        try {
            // Simple XOR-based encryption
            const keyBytes = key.split('').map(c => c.charCodeAt(0));
            const dataBytes = data.split('').map(c => c.charCodeAt(0));
            
            const encrypted = dataBytes.map((byte, i) => {
                return byte ^ keyBytes[i % keyBytes.length];
            });
            
            return btoa(String.fromCharCode(...encrypted));
        } catch (error) {
            console.error('Simple encryption failed:', error);
            throw new Error('Failed to encrypt data');
        }
    };

    const simpleDecrypt = (encryptedData, key) => {
        try {
            const keyBytes = key.split('').map(c => c.charCodeAt(0));
            const encryptedBytes = atob(encryptedData).split('').map(c => c.charCodeAt(0));
            
            const decrypted = encryptedBytes.map((byte, i) => {
                return byte ^ keyBytes[i % keyBytes.length];
            });
            
            return String.fromCharCode(...decrypted);
        } catch (error) {
            console.error('Simple decryption failed:', error);
            throw new Error('Failed to decrypt data');
        }
    };

    const encryptData = (data, key) => {
        try {
            // Try CryptoJS first, fall back to simple encryption
            if (typeof CryptoJS !== 'undefined' && CryptoJS.AES) {
                return 'aes:' + CryptoJS.AES.encrypt(data, key).toString();
            } else {
                console.log('Using simple encryption fallback');
                return 'simple:' + simpleEncrypt(data, key);
            }
        } catch (error) {
            console.error('Encryption failed:', error);
            throw new Error('Failed to encrypt data');
        }
    };

    const decryptData = (encryptedData, key) => {
        try {
            if (encryptedData.startsWith('aes:')) {
                // AES encrypted data
                const aesData = encryptedData.substring(4);
                if (typeof CryptoJS !== 'undefined' && CryptoJS.AES) {
                    const bytes = CryptoJS.AES.decrypt(aesData, key);
                    return bytes.toString(CryptoJS.enc.Utf8);
                } else {
                    throw new Error('CryptoJS not available for AES decryption');
                }
            } else if (encryptedData.startsWith('simple:')) {
                // Simple encrypted data
                const simpleData = encryptedData.substring(7);
                return simpleDecrypt(simpleData, key);
            } else {
                // Legacy format - try simple decryption
                return simpleDecrypt(encryptedData, key);
            }
        } catch (error) {
            console.error('Decryption failed:', error);
            throw new Error('Failed to decrypt data');
        }
    };

    const compressData = (data) => {
        try {
            if (typeof LZString !== 'undefined' && LZString.compress) {
                return LZString.compress(data);
            } else {
                // Simple compression fallback - remove extra whitespace
                console.log('Using simple compression fallback');
                return data.replace(/\s+/g, ' ').trim();
            }
        } catch (error) {
            console.error('Compression failed:', error);
            return data; // Return uncompressed data as fallback
        }
    };

    const decompressData = (compressedData) => {
        try {
            if (typeof LZString !== 'undefined' && LZString.decompress) {
                const result = LZString.decompress(compressedData);
                return result || compressedData; // Return original if decompression fails
            } else {
                return compressedData;
            }
        } catch (error) {
            console.error('Decompression failed:', error);
            return compressedData;
        }
    };

    const exportToQR = async (trees, currentTheme, customThemes, selectedTreesOnly = false) => {
        try {
            console.log('Starting QR export...');
            
            // Prepare data
            const dataToExport = selectedTreesOnly ? trees.filter(tree => tree.selected) : trees;
            
            // Prepare theme data safely
            let themeData = null;
            try {
                themeData = {
                    currentTheme,
                    customTheme: customThemes[currentTheme] || null,
                    isCustomTheme: !builtInThemes[currentTheme]
                };
                
                // Test if theme data can be serialized
                JSON.stringify(themeData);
                console.log('Theme data prepared successfully');
            } catch (themeError) {
                console.warn('Theme data caused issues, excluding from export:', themeError);
                themeData = { currentTheme: 'light', customTheme: null, isCustomTheme: false };
            }
            
            console.log('Preparing data for export...');
            const exportData = {
                version: '1.1',
                timestamp: Date.now(),
                trees: dataToExport.map(tree => ({
                    ...tree,
                    selected: undefined // Remove selection state from export
                }))
            };

            // Only add theme if it's safe
            if (themeData) {
                exportData.theme = themeData;
            }

            const jsonData = JSON.stringify(exportData);
            console.log('Data size:', jsonData.length, 'characters');

            // Test if JSON is valid
            JSON.parse(jsonData);
            console.log('JSON validation passed');

            // Compress
            console.log('Compressing data...');
            const compressed = compressData(jsonData);
            console.log('Compressed size:', compressed.length, 'characters');
            
            // Generate encryption key
            console.log('Generating encryption key...');
            const key = generateRandomKey();
            
            // Encrypt
            console.log('Encrypting data...');
            const encrypted = encryptData(compressed, key);
            
            // Create QR payload
            const qrPayload = `tree-e://${encrypted}|${key}`;
            console.log('QR payload size:', qrPayload.length, 'characters');
            
            // Check if payload is too large for QR code
            if (qrPayload.length > 2950) {
                throw new Error(`Data too large for QR code (${qrPayload.length} chars). Try exporting fewer trees or reducing content.`);
            }
            
            // Generate QR code
            console.log('Generating QR code...');
            let qrDataUrl;
            
            if (typeof QRCode !== 'undefined') {
                qrDataUrl = await QRCode.toDataURL(qrPayload, {
                    width: 300,
                    margin: 2,
                    color: {
                        dark: '#000000',
                        light: '#ffffff'
                    },
                    errorCorrectionLevel: 'M'
                });
            } else {
                throw new Error('QRCode library not available. Please refresh the page and try again.');
            }

            console.log('QR code generated successfully');

            return {
                qrDataUrl,
                treeCount: dataToExport.length,
                nodeCount: dataToExport.reduce((total, tree) => total + tree.nodes.length, 0),
                includesTheme: !!themeData && themeData.currentTheme !== 'light'
            };
        } catch (error) {
            console.error('QR export failed at step:', error.message);
            console.error('Full error:', error);
            throw new Error(`Export failed: ${error.message}`);
        }
    };

    const importFromQR = (qrData) => {
        try {
            console.log('Starting QR import...');
            
            // Check if it's a Tree-e QR code
            if (!qrData.startsWith('tree-e://')) {
                throw new Error('Not a valid Tree-e QR code');
            }

            // Extract encrypted data and key
            const payload = qrData.replace('tree-e://', '');
            const [encryptedData, key] = payload.split('|');
            
            if (!encryptedData || !key) {
                throw new Error('Invalid QR code format');
            }

            console.log('Decrypting data...');
            // Decrypt
            const compressed = decryptData(encryptedData, key);
            if (!compressed) {
                throw new Error('Failed to decrypt data - invalid key or corrupted data');
            }

            console.log('Decompressing data...');
            // Decompress
            const jsonData = decompressData(compressed);
            if (!jsonData) {
                throw new Error('Failed to decompress data');
            }

            console.log('Parsing JSON data...');
            // Parse
            let importedData;
            try {
                importedData = JSON.parse(jsonData);
            } catch (parseError) {
                console.error('JSON parse error:', parseError);
                throw new Error('Invalid data format - corrupted QR code');
            }
            
            if (!importedData.trees || !Array.isArray(importedData.trees)) {
                throw new Error('Invalid data structure - trees array missing');
            }

            console.log('Processing imported trees...');
            // Generate new IDs to avoid conflicts
            const processedTrees = importedData.trees.map(tree => ({
                ...tree,
                id: tree.id === 'main' ? 'main' : generateId(),
                nodes: (tree.nodes || []).map(node => ({
                    id: generateId(),
                    content: node.content || '',
                    level: node.level || 0,
                    note: node.note || '',
                    isTask: node.isTask || false,
                    isCompleted: node.isCompleted || false
                })),
                parentTreeId: tree.parentTreeId || null,
                parentNodeId: tree.parentNodeId || null,
                breadcrumb: tree.breadcrumb || []
            }));

            console.log('Import successful');

            return {
                trees: processedTrees,
                version: importedData.version || '1.0',
                timestamp: importedData.timestamp || Date.now(),
                theme: importedData.theme || null // Include theme data if present
            };
        } catch (error) {
            console.error('Failed to import from QR:', error);
            throw error;
        }
    };

    // QR Scanner component
    const QRScanner = ({ onScan, onError, onClose }) => {
        const videoRef = useRef(null);
        const canvasRef = useRef(null);
        const intervalRef = useRef(null);

        useEffect(() => {
            const startScanner = async () => {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: { facingMode: 'environment' }
                    });
                    
                    if (videoRef.current) {
                        videoRef.current.srcObject = stream;
                        videoRef.current.play();
                        
                        // Start scanning
                        intervalRef.current = setInterval(scanFrame, 500);
                    }
                } catch (err) {
                    console.error('Failed to start camera:', err);
                    onError('Failed to access camera. Please ensure camera permissions are granted.');
                }
            };

            const scanFrame = () => {
                if (!videoRef.current || !canvasRef.current) return;

                const video = videoRef.current;
                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d');

                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                ctx.drawImage(video, 0, 0);

                try {
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    // Simple QR detection - in a real implementation, you'd use a QR library
                    // For now, we'll simulate detection
                    detectQRFromImageData(imageData);
                } catch (err) {
                    // Ignore scanning errors
                }
            };

            const detectQRFromImageData = (imageData) => {
                // This is a simplified detection - in reality you'd use jsQR or similar
                // For demo purposes, we'll just check for manual input
            };

            startScanner();

            return () => {
                if (intervalRef.current) {
                    clearInterval(intervalRef.current);
                }
                if (videoRef.current && videoRef.current.srcObject) {
                    const tracks = videoRef.current.srcObject.getTracks();
                    tracks.forEach(track => track.stop());
                }
            };
        }, []);

        return (
            <div>
                <div className="qr-scanner">
                    <video
                        ref={videoRef}
                        className="qr-video"
                        playsInline
                        muted
                    />
                    <canvas ref={canvasRef} style={{ display: 'none' }} />
                    <div className="qr-overlay" />
                </div>
                
                <div style={{ marginTop: '1rem', textAlign: 'center' }}>
                    <p style={{ fontSize: '0.875rem', opacity: 0.8, marginBottom: '1rem' }}>
                        Position the QR code within the frame
                    </p>
                    
                    {/* Manual input fallback */}
                    <details style={{ marginTop: '1rem' }}>
                        <summary style={{ cursor: 'pointer', fontSize: '0.875rem', opacity: 0.7 }}>
                            Or enter QR data manually
                        </summary>
                        <div style={{ marginTop: '0.5rem' }}>
                            <input
                                type="text"
                                placeholder="Paste tree-e:// QR code data here"
                                style={{
                                    width: '100%',
                                    padding: '8px',
                                    border: '1px solid #ccc',
                                    borderRadius: '4px',
                                    fontSize: '0.75rem',
                                    fontFamily: 'monospace'
                                }}
                                onPaste={(e) => {
                                    setTimeout(() => {
                                        const value = e.target.value;
                                        if (value.startsWith('tree-e://')) {
                                            onScan(value);
                                        }
                                    }, 10);
                                }}
                            />
                        </div>
                    </details>
                </div>
            </div>
        );
    };

    // Touch handling
    const useTouchHandler = (onSwipeLeft, onSwipeRight, threshold = 50) => {
        const touchStart = useRef(null);
        const touchEnd = useRef(null);

        return {
            onTouchStart: (e) => {
                touchEnd.current = null;
                touchStart.current = e.targetTouches[0].clientX;
            },
            onTouchMove: (e) => {
                touchEnd.current = e.targetTouches[0].clientX;
            },
            onTouchEnd: () => {
                if (!touchStart.current || !touchEnd.current) return;
                
                const distance = touchStart.current - touchEnd.current;
                if (distance > threshold && onSwipeLeft) onSwipeLeft();
                if (distance < -threshold && onSwipeRight) onSwipeRight();
            }
        };
    };

    // Components
    const Modal = ({ isOpen, onClose, title, children, theme }) => {
        if (!isOpen) return null;

        return (
            <div className="modal" onClick={onClose}>
                <div 
                    className="modal-content" 
                    style={{ backgroundColor: theme.background, color: theme.text }}
                    onClick={(e) => e.stopPropagation()}
                >
                    <div className="modal-header" style={{ borderColor: theme.border }}>
                        <h3 className="modal-title">{title}</h3>
                        <button className="modal-close" onClick={onClose} style={{ color: theme.text }}>
                            ╳
                        </button>
                    </div>
                    <div className="modal-body">
                        {children}
                    </div>
                </div>
            </div>
        );
    };

    const NodeComponent = ({ node, theme, isSelected, isEditing, editText, onEditTextChange, trees, currentTreeId, onTap, onIndent, onOutdent, onDelete, onFocus, onToggleTask, onToggleComplete, onBranchOut, onEdit, onSaveEdit, onCancelEdit, onJumpToBranch, getTextColorForBackground, getColorForLevel }) => {
        const editInputRef = useRef(null);
        const isBranchedOut = trees.some(tree => tree.parentNodeId === node.id);
        
        const swipeHandlers = useTouchHandler(onOutdent, onIndent);

        useEffect(() => {
            if (isEditing && editInputRef.current) {
                editInputRef.current.focus();
                editInputRef.current.select();
            }
        }, [isEditing]);

        const handleKeyPress = (e) => {
            if (e.key === 'Enter') {
                onSaveEdit();
            } else if (e.key === 'Escape') {
                onCancelEdit();
            }
        };

        return (
            <div className="node">
                <div className="node-indent">
                    {Array.from({ length: node.level }, (_, i) => (
                        <div key={i} className="indent-space" />
                    ))}
                </div>
                
                <div className="node-content-wrapper">
                    <div 
                        className={`node-content ${isSelected ? 'selected' : ''} ${node.isTask && node.isCompleted ? 'completed' : ''}`}
                        style={{
                            backgroundColor: isSelected ? theme.border : getColorForLevel(theme, node.level),
                            borderColor: isSelected ? theme.text : theme.border,
                            color: isSelected ? getTextColorForBackground(theme.border) : getTextColorForBackground(getColorForLevel(theme, node.level)),
                            opacity: isBranchedOut && !isEditing ? 0.7 : 1
                        }}
                        onClick={(e) => !isEditing && onTap(e)}
                        {...(!isEditing ? swipeHandlers : {})}
                    >
                        {node.isTask && (
                            <div 
                                className="task-toggle" 
                                onClick={(e) => {
                                    e.stopPropagation();
                                    if (!isEditing) onToggleComplete();
                                }}
                                style={{ color: node.isCompleted ? '#22c55e' : isSelected ? getTextColorForBackground(theme.border) + '99' : getTextColorForBackground(getColorForLevel(theme, node.level)) + '99' }}
                            >
                                {node.isCompleted ? '☑' : '☐'}
                            </div>
                        )}
                        
                        {isEditing ? (
                            <input
                                ref={editInputRef}
                                className="node-edit-input"
                                type="text"
                                value={editText}
                                onChange={(e) => onEditTextChange(e.target.value)}
                                onKeyDown={handleKeyPress}
                                onBlur={onSaveEdit}
                                style={{ color: isSelected ? getTextColorForBackground(theme.border) : getTextColorForBackground(getColorForLevel(theme, node.level)) }}
                                onClick={(e) => e.stopPropagation()}
                            />
                        ) : (
                            <div className={`node-text ${node.isTask && node.isCompleted ? 'completed' : ''}`}>
                                {node.content}
                            </div>
                        )}
                        
                        {!isEditing && (
                            <div className="node-icons" style={{ color: isSelected ? getTextColorForBackground(theme.border) : getTextColorForBackground(getColorForLevel(theme, node.level)) }}>
                                {node.isTask && <span>□</span>}
                                {node.note && node.note.trim() && <span>◊</span>}
                                {isBranchedOut && (
                                    <span 
                                        className="branch-link"
                                        onClick={(e) => {
                                            e.stopPropagation();
                                            onJumpToBranch();
                                        }}
                                        title="Jump to branched tree"
                                        style={{ 
                                            color: isSelected ? getTextColorForBackground(theme.border) : getTextColorForBackground(getColorForLevel(theme, node.level))
                                        }}
                                    >
                                        ⫷
                                    </span>
                                )}
                            </div>
                        )}
                    </div>
                    
                    {isSelected && !isEditing && (
                        <div className="node-actions">
                            {!isBranchedOut && (
                                <button className="action-btn edit" onClick={onEdit}>
                                    ✎ <span>Edit</span>
                                </button>
                            )}
                            <button className="action-btn task" onClick={onToggleTask}>
                                □ <span>{node.isTask ? 'Note' : 'Task'}</span>
                            </button>
                            <button className="action-btn focus" onClick={onFocus}>
                                ◊ <span>Notes</span>
                            </button>
                            <button 
                                className="action-btn branch" 
                                onClick={onBranchOut} 
                                disabled={trees.length >= 5 || isBranchedOut}
                                style={{ 
                                    opacity: (trees.length >= 5 || isBranchedOut) ? 0.5 : 1,
                                    cursor: (trees.length >= 5 || isBranchedOut) ? 'not-allowed' : 'pointer'
                                }}
                                title={
                                    isBranchedOut ? 'Node already branched out' :
                                    trees.length >= 5 ? 'Maximum 5 trees allowed' : 
                                    'Branch out to explore this thought'
                                }
                            >
                                ⫷ <span>Branch</span>
                            </button>
                            <button className="action-btn delete" onClick={onDelete}>
                                ╳ <span>Delete</span>
                            </button>
                        </div>
                    )}
                    
                    {isEditing && (
                        <div className="node-actions">
                            <button className="action-btn save" onClick={onSaveEdit}>
                                ✓ <span>Save</span>
                            </button>
                            <button className="action-btn cancel" onClick={onCancelEdit}>
                                ✕ <span>Cancel</span>
                            </button>
                        </div>
                    )}
                </div>
            </div>
        );
    };

    // Main App Component
    const TreeApp = () => {
        // Core State
        const [trees, setTrees] = useState([]);
        const [activeTreeId, setActiveTreeId] = useState('main');
        const [selectedNodeId, setSelectedNodeId] = useState(null);
        
        // UI State
        const [ui, setUi] = useState({
            currentInput: '',
            indentLevel: 0,
            editingNodeId: null,
            editText: '',
            currentTheme: 'light',
            currentFilter: 'all',
            showAbout: false,
            showThemeDropdown: false,
            showFilterDropdown: false,
            showMarkdownView: false,
            showClearConfirm: false,
            showMainMenu: false,
            showLospecImport: false,
            lospecSlug: '',
            lospecLoading: false,
            lospecPreview: null,
            focusedNode: null,
            showSwipeHints: false,
            // QR Code states
            showQRExport: false,
            showQRImport: false,
            showSyncMenu: false,
            qrExportData: null,
            qrImportError: null,
            qrScanError: null
        });

        const [customThemes, setCustomThemes] = useState({});

        const inputRef = useRef(null);
        
        // Combine built-in and custom themes
        const allThemes = { ...builtInThemes, ...customThemes };
        const theme = allThemes[ui.currentTheme] || builtInThemes.light;

        // Helper functions
        const getActiveTree = () => trees.find(tree => tree.id === activeTreeId) || trees[0];
        const getActiveTreeIndex = () => trees.findIndex(tree => tree.id === activeTreeId);

        const updateUi = (updates) => setUi(prev => ({ ...prev, ...updates }));

        const updateActiveTree = (updater) => {
            setTrees(prev => prev.map(tree => 
                tree.id === activeTreeId 
                    ? { ...tree, nodes: typeof updater === 'function' ? updater(tree.nodes) : updater }
                    : tree
            ));
        };

        const setActiveTree = (treeId) => {
            setActiveTreeId(treeId);
            setSelectedNodeId(null);
            updateUi({ indentLevel: 0 });
        };

        const getFilteredNodes = (nodes = null) => {
            const targetNodes = nodes || getActiveTree()?.nodes || [];
            switch (ui.currentFilter) {
                case 'tasks': return targetNodes.filter(node => node.isTask);
                case 'notes': return targetNodes.filter(node => node.note && node.note.trim());
                case 'branched': return targetNodes.filter(node => trees.some(tree => tree.parentNodeId === node.id));
                default: return targetNodes;
            }
        };

        // QR Code functions
        const handleQRExport = async () => {
            try {
                // Quick check if we have data to export
                if (trees.length === 0 || trees.every(tree => tree.nodes.length === 0)) {
                    alert('No trees to export! Add some content first.');
                    return;
                }

                const qrData = await exportToQR(trees, ui.currentTheme, customThemes);
                updateUi({ 
                    qrExportData: qrData,
                    showQRExport: true,
                    showSyncMenu: false
                });
            } catch (error) {
                console.error('QR Export Error:', error);
                
                // Try without theme data as fallback
                try {
                    console.log('Trying export without theme data...');
                    const qrDataNoTheme = await exportToQRNoTheme(trees);
                    updateUi({ 
                        qrExportData: { ...qrDataNoTheme, includesTheme: false },
                        showQRExport: true,
                        showSyncMenu: false
                    });
                    alert('QR code generated successfully (without theme data due to compatibility issue)');
                    return;
                } catch (fallbackError) {
                    console.error('Fallback export also failed:', fallbackError);
                }
                
                let errorMessage = 'Failed to generate QR code';
                
                if (error.message.includes('too large')) {
                    errorMessage = 'Your trees are too large for QR code export. Try exporting fewer trees or reducing content length.';
                } else if (error.message.includes('QRCode library')) {
                    errorMessage = 'QR code library failed to load. Please refresh the page and try again.';
                } else if (error.message.includes('Export failed:')) {
                    errorMessage = error.message;
                }
                
                alert(errorMessage);
            }
        };

        const exportToQRNoTheme = async (trees, selectedTreesOnly = false) => {
            try {
                console.log('Starting simple QR export (no theme)...');
                
                // Prepare data without theme
                const dataToExport = selectedTreesOnly ? trees.filter(tree => tree.selected) : trees;
                
                const exportData = {
                    version: '1.0',
                    timestamp: Date.now(),
                    trees: dataToExport.map(tree => ({
                        id: tree.id,
                        title: tree.title,
                        nodes: tree.nodes.map(node => ({
                            id: node.id,
                            content: node.content,
                            level: node.level,
                            note: node.note || '',
                            isTask: node.isTask || false,
                            isCompleted: node.isCompleted || false
                        })),
                        parentTreeId: tree.parentTreeId,
                        parentNodeId: tree.parentNodeId,
                        breadcrumb: tree.breadcrumb || []
                    }))
                };

                const jsonData = JSON.stringify(exportData);
                console.log('Simple data size:', jsonData.length, 'characters');

                // Skip compression for simplicity
                const key = generateRandomKey();
                const encrypted = encryptData(jsonData, key);
                const qrPayload = `tree-e://${encrypted}|${key}`;
                
                console.log('Simple QR payload size:', qrPayload.length, 'characters');
                
                if (qrPayload.length > 2950) {
                    throw new Error(`Data too large for QR code (${qrPayload.length} chars)`);
                }
                
                const qrDataUrl = await QRCode.toDataURL(qrPayload, {
                    width: 300,
                    margin: 2,
                    color: { dark: '#000000', light: '#ffffff' },
                    errorCorrectionLevel: 'M'
                });

                console.log('Simple QR code generated successfully');

                return {
                    qrDataUrl,
                    treeCount: dataToExport.length,
                    nodeCount: dataToExport.reduce((total, tree) => total + tree.nodes.length, 0)
                };
            } catch (error) {
                console.error('Simple QR export failed:', error);
                throw error;
            }
        };

        const handleQRImport = () => {
            updateUi({ 
                showQRImport: true,
                showSyncMenu: false,
                qrImportError: null,
                qrScanError: null
            });
        };

        const onQRScan = async (qrData) => {
            try {
                const importedData = importFromQR(qrData);
                
                // Merge imported trees
                const mergedTrees = [...trees];
                
                for (const importedTree of importedData.trees) {
                    if (importedTree.id === 'main') {
                        // Merge main tree nodes
                        const mainTreeIndex = mergedTrees.findIndex(t => t.id === 'main');
                        if (mainTreeIndex !== -1) {
                            mergedTrees[mainTreeIndex] = {
                                ...mergedTrees[mainTreeIndex],
                                nodes: [...mergedTrees[mainTreeIndex].nodes, ...importedTree.nodes]
                            };
                        }
                    } else {
                        // Add as new tree
                        mergedTrees.push(importedTree);
                    }
                }
                
                setTrees(mergedTrees);
                
                // Handle theme import
                let successMessage = `Successfully imported ${importedData.trees.length} trees!`;
                
                if (importedData.theme) {
                    const { currentTheme, customTheme, isCustomTheme } = importedData.theme;
                    
                    if (isCustomTheme && customTheme) {
                        // Import custom theme
                        const baseKey = currentTheme;
                        let themeKey = baseKey;
                        let counter = 1;
                        
                        // Ensure unique key for custom theme
                        while (allThemes[themeKey]) {
                            themeKey = `${baseKey}_imported_${counter}`;
                            counter++;
                        }
                        
                        // Add custom theme
                        const newCustomThemes = {
                            ...customThemes,
                            [themeKey]: customTheme
                        };
                        setCustomThemes(newCustomThemes);
                        
                        // Apply the imported theme
                        updateUi({ currentTheme: themeKey });
                        successMessage += ` Theme "${customTheme.name}" imported and applied!`;
                        
                    } else if (builtInThemes[currentTheme]) {
                        // Apply built-in theme
                        updateUi({ currentTheme });
                        successMessage += ` Theme "${builtInThemes[currentTheme].name}" applied!`;
                    }
                }
                
                updateUi({ 
                    showQRImport: false,
                    qrImportError: null 
                });
                
                alert(successMessage);
            } catch (error) {
                updateUi({ qrImportError: error.message });
            }
        };

        const onQRScanError = (error) => {
            updateUi({ qrScanError: error });
        };

        // Load/Save
        useEffect(() => {
            const loadedTrees = loadFromStorage();
            const loadedCustomThemes = loadCustomThemes();
            const savedTheme = loadThemeFromStorage();
            
            setTrees(loadedTrees);
            setCustomThemes(loadedCustomThemes);
            
            // Check if saved theme exists, otherwise default to light
            const allAvailableThemes = { ...builtInThemes, ...loadedCustomThemes };
            const themeToUse = allAvailableThemes[savedTheme] ? savedTheme : 'light';
            updateUi({ currentTheme: themeToUse });
            
            // Check QR libraries availability
            if (typeof QRCode === 'undefined') {
                console.warn('QRCode library not loaded - QR sync will not work');
            }
            if (typeof CryptoJS === 'undefined') {
                console.warn('CryptoJS library not loaded - using fallback encoding');
            }
            if (typeof LZString === 'undefined') {
                console.warn('LZString library not loaded - skipping compression');
            }
            
            setTimeout(() => {
                if (inputRef.current) {
                    inputRef.current.focus();
                }
            }, 100);
        }, []);

        useEffect(() => {
            if (trees.length > 0) {
                saveToStorage(trees);
            }
        }, [trees]);

        useEffect(() => {
            saveThemeToStorage(ui.currentTheme);
        }, [ui.currentTheme]);

        useEffect(() => {
            saveCustomThemes(customThemes);
        }, [customThemes]);

        // Touch handlers for input
        const inputSwipeHandlers = useTouchHandler(
            () => updateUi({ indentLevel: Math.max(0, ui.indentLevel - 1) }),
            () => updateUi({ indentLevel: ui.indentLevel + 1 })
        );

        // Touch handlers for tree navigation
        const treeSwipeHandlers = useTouchHandler(
            () => {
                // Swipe left = next tree
                if (trees.length > 1) {
                    const currentIndex = getActiveTreeIndex();
                    const nextIndex = currentIndex < trees.length - 1 ? currentIndex + 1 : 0;
                    setActiveTree(trees[nextIndex].id);
                    updateUi({ showSwipeHints: false });
                }
            },
            () => {
                // Swipe right = previous tree
                if (trees.length > 1) {
                    const currentIndex = getActiveTreeIndex();
                    const prevIndex = currentIndex > 0 ? currentIndex - 1 : trees.length - 1;
                    setActiveTree(trees[prevIndex].id);
                    updateUi({ showSwipeHints: false });
                }
            }
        );

        // Enhanced touch handlers for tree navigation with hints
        const enhancedTreeSwipeHandlers = {
            ...treeSwipeHandlers,
            onTouchStart: (e) => {
                if (trees.length > 1) {
                    updateUi({ showSwipeHints: true });
                }
                treeSwipeHandlers.onTouchStart(e);
            },
            onTouchEnd: (e) => {
                updateUi({ showSwipeHints: false });
                treeSwipeHandlers.onTouchEnd(e);
            }
        };

        // Node operations
        const addNode = () => {
            const content = ui.currentInput.trim();
            if (!content) return;

            const activeTree = getActiveTree();
            if (!activeTree) return;

            const nodes = activeTree.nodes;
            let insertIndex = nodes.length;
            let newLevel = ui.indentLevel;

            if (selectedNodeId) {
                const selectedNode = nodes.find(node => node.id === selectedNodeId);
                const selectedIndex = nodes.findIndex(node => node.id === selectedNodeId);
                
                if (selectedNode && selectedIndex !== -1) {
                    newLevel = selectedNode.level + 1;
                    
                    let insertAfterIndex = selectedIndex;
                    for (let i = selectedIndex + 1; i < nodes.length; i++) {
                        if (nodes[i].level > selectedNode.level) {
                            insertAfterIndex = i;
                        } else {
                            break;
                        }
                    }
                    insertIndex = insertAfterIndex + 1;
                }
            }

            const newNode = {
                id: generateId(),
                content,
                level: newLevel,
                note: '',
                isTask: false,
                isCompleted: false
            };

            updateActiveTree(prevNodes => {
                const newNodes = [...prevNodes];
                newNodes.splice(insertIndex, 0, newNode);
                return newNodes;
            });
            
            updateUi({ currentInput: '', indentLevel: newLevel });
        };

        const selectNode = (nodeId) => {
            if (selectedNodeId === nodeId) {
                // Deselect
                setSelectedNodeId(null);
                const activeTree = getActiveTree();
                if (activeTree?.nodes.length > 0) {
                    updateUi({ indentLevel: activeTree.nodes[activeTree.nodes.length - 1].level });
                } else {
                    updateUi({ indentLevel: 0 });
                }
            } else {
                // Select
                setSelectedNodeId(nodeId);
                const activeTree = getActiveTree();
                const node = activeTree?.nodes.find(n => n.id === nodeId);
                if (node) {
                    updateUi({ indentLevel: node.level + 1 });
                }
            }
        };

        const deleteNode = (nodeId) => {
            updateActiveTree(prevNodes => prevNodes.filter(node => node.id !== nodeId));
            if (selectedNodeId === nodeId) {
                setSelectedNodeId(null);
            }
        };

        const indentNode = (nodeId) => {
            updateActiveTree(prevNodes => prevNodes.map(node =>
                node.id === nodeId ? { ...node, level: node.level + 1 } : node
            ));
            setSelectedNodeId(null);
        };

        const outdentNode = (nodeId) => {
            updateActiveTree(prevNodes => prevNodes.map(node =>
                node.id === nodeId ? { ...node, level: Math.max(0, node.level - 1) } : node
            ));
            setSelectedNodeId(null);
        };

        const toggleTask = (nodeId) => {
            updateActiveTree(prevNodes => prevNodes.map(node =>
                node.id === nodeId ? { ...node, isTask: !node.isTask, isCompleted: false } : node
            ));
            setSelectedNodeId(null);
        };

        const toggleComplete = (nodeId) => {
            updateActiveTree(prevNodes => prevNodes.map(node =>
                node.id === nodeId ? { ...node, isCompleted: !node.isCompleted } : node
            ));
        };

        const editNode = (nodeId) => {
            // Check if branched out
            const isBranchedOut = trees.some(tree => tree.parentNodeId === nodeId);
            if (isBranchedOut) return;
            
            const activeTree = getActiveTree();
            const node = activeTree?.nodes.find(n => n.id === nodeId);
            if (node) {
                updateUi({ editingNodeId: nodeId, editText: node.content });
                setSelectedNodeId(null);
            }
        };

        const saveEdit = () => {
            const trimmedText = ui.editText.trim();
            if (trimmedText && ui.editingNodeId) {
                updateActiveTree(prevNodes => prevNodes.map(node =>
                    node.id === ui.editingNodeId ? { ...node, content: trimmedText } : node
                ));
            }
            updateUi({ editingNodeId: null, editText: '' });
        };

        const cancelEdit = () => {
            updateUi({ editingNodeId: null, editText: '' });
        };

        const focusNode = (nodeId) => {
            const activeTree = getActiveTree();
            const node = activeTree?.nodes.find(n => n.id === nodeId);
            if (node) {
                updateUi({ focusedNode: node });
            }
            setSelectedNodeId(null);
        };

        const saveFocusNote = (note) => {
            if (ui.focusedNode) {
                updateActiveTree(prevNodes => prevNodes.map(node =>
                    node.id === ui.focusedNode.id ? { ...node, note } : node
                ));
            }
            updateUi({ focusedNode: null });
        };

        // Branch operations
        const branchOut = (nodeId) => {
            const activeTree = getActiveTree();
            if (!activeTree || trees.length >= 5) return;

            const selectedNode = activeTree.nodes.find(node => node.id === nodeId);
            if (!selectedNode) return;

            const nodeAndChildren = [];
            let foundParent = false;
            
            for (const node of activeTree.nodes) {
                if (node.id === selectedNode.id) {
                    foundParent = true;
                    nodeAndChildren.push({ ...node, level: 0 });
                } else if (foundParent && node.level > selectedNode.level) {
                    nodeAndChildren.push({ ...node, level: node.level - selectedNode.level });
                } else if (foundParent && node.level <= selectedNode.level) {
                    break;
                }
            }

            const truncatedTitle = selectedNode.content.length > 20 
                ? selectedNode.content.substring(0, 17) + '...'
                : selectedNode.content;

            const newBreadcrumb = [];
            if (activeTree.id !== 'main') {
                newBreadcrumb.push(...activeTree.breadcrumb, activeTree.title);
            }
            
            if (newBreadcrumb.length > 3) {
                newBreadcrumb.splice(1, newBreadcrumb.length - 3);
                newBreadcrumb[1] = '...';
            }

            const newTree = {
                id: generateId(),
                title: truncatedTitle,
                nodes: nodeAndChildren,
                parentTreeId: activeTree.id,
                parentNodeId: selectedNode.id,
                breadcrumb: newBreadcrumb
            };

            setTrees(prev => [...prev, newTree]);
            setActiveTree(newTree.id);
            setSelectedNodeId(null);
            updateUi({ indentLevel: 0 });
        };

        const closeTree = () => {
            const activeTree = getActiveTree();
            if (!activeTree || !activeTree.parentTreeId) return;

            const parentTree = trees.find(tree => tree.id === activeTree.parentTreeId);
            if (!parentTree) return;

            // Merge changes back
            setTrees(prev => {
                const newTrees = [...prev];
                const parentIndex = newTrees.findIndex(tree => tree.id === activeTree.parentTreeId);
                const parentNodes = [...newTrees[parentIndex].nodes];
                
                const originalNodeIndex = parentNodes.findIndex(node => node.id === activeTree.parentNodeId);
                if (originalNodeIndex === -1) return newTrees;

                const originalNode = parentNodes[originalNodeIndex];
                
                // Remove old children
                let removeUntilIndex = parentNodes.length;
                for (let i = originalNodeIndex + 1; i < parentNodes.length; i++) {
                    if (parentNodes[i].level <= originalNode.level) {
                        removeUntilIndex = i;
                        break;
                    }
                }
                
                // Replace with updated nodes
                const updatedNodes = activeTree.nodes.map(node => ({
                    ...node,
                    level: node.level + originalNode.level
                }));

                parentNodes.splice(originalNodeIndex, removeUntilIndex - originalNodeIndex, ...updatedNodes);
                newTrees[parentIndex] = { ...newTrees[parentIndex], nodes: parentNodes };

                // Remove the closed tree
                const activeTreeIndex = newTrees.findIndex(tree => tree.id === activeTreeId);
                newTrees.splice(activeTreeIndex, 1);

                return newTrees;
            });

            setActiveTree(activeTree.parentTreeId);
        };

        const jumpToBranch = (nodeId) => {
            const branchedTree = trees.find(tree => tree.parentNodeId === nodeId);
            if (branchedTree) {
                setActiveTree(branchedTree.id);
            }
        };

        // Lospec Integration
        const fetchLospecPalette = async (slug) => {
            if (!slug.trim()) return null;
            
            updateUi({ lospecLoading: true });
            
            try {
                const response = await fetch(`https://lospec.com/palette-list/${slug.trim()}.json`);
                
                if (!response.ok) {
                    throw new Error('Palette not found');
                }
                
                const data = await response.json();
                updateUi({ lospecLoading: false });
                
                return data;
            } catch (error) {
                updateUi({ lospecLoading: false });
                alert(`Error fetching palette: ${error.message}`);
                return null;
            }
        };

        const convertLospecToTheme = (lospecData) => {
            const colors = lospecData.colors.map(c => `#${c}`);
            const name = lospecData.name;
            
            // Calculate color brightness to determine theme type
            const getBrightness = (hex) => {
                const r = parseInt(hex.slice(1, 3), 16);
                const g = parseInt(hex.slice(3, 5), 16);
                const b = parseInt(hex.slice(5, 7), 16);
                return (r * 299 + g * 587 + b * 114) / 1000;
            };
            
            // Sort colors by brightness
            const sortedColors = [...colors].sort((a, b) => getBrightness(a) - getBrightness(b));
            const darkest = sortedColors[0];
            const lightest = sortedColors[sortedColors.length - 1];
            const darkestBrightness = getBrightness(darkest);
            const lightestBrightness = getBrightness(lightest);
            
            // Determine if this should be a dark or light theme
            const isDarkTheme = lightestBrightness - darkestBrightness > 100 && darkestBrightness < 80;
            
            let background, text, border;
            
            if (isDarkTheme) {
                background = darkest;
                text = lightest;
                border = sortedColors[Math.floor(sortedColors.length * 0.3)];
            } else {
                background = lightest;
                text = darkest;
                border = sortedColors[Math.floor(sortedColors.length * 0.7)];
            }
            
            // Choose prompt color (accent color)
            const midIndex = Math.floor(sortedColors.length / 2);
            const prompt = sortedColors[midIndex];
            
            // Distribute colors for levels - try to get good variety
            const levelColors = [];
            const step = Math.max(1, Math.floor(colors.length / 5));
            
            for (let i = 0; i < 5; i++) {
                const index = (i * step) % colors.length;
                levelColors.push(colors[index]);
            }
            
            // Ensure we have 5 unique colors for levels
            while (levelColors.length < 5) {
                levelColors.push(colors[levelColors.length % colors.length]);
            }
            
            return {
                name: `${name} (Lospec)`,
                background,
                text,
                prompt,
                border,
                levelColors: levelColors.slice(0, 5)
            };
        };

        const previewLospecPalette = async () => {
            const data = await fetchLospecPalette(ui.lospecSlug);
            if (data) {
                const theme = convertLospecToTheme(data);
                updateUi({ lospecPreview: theme });
            }
        };

        const importLospecTheme = () => {
            if (ui.lospecPreview) {
                // Generate a unique key for the theme
                const baseKey = ui.lospecSlug.toLowerCase().replace(/[^a-z0-9]/g, '');
                let themeKey = baseKey;
                let counter = 1;
                
                // Ensure unique key
                while (allThemes[themeKey]) {
                    themeKey = `${baseKey}${counter}`;
                    counter++;
                }
                
                // Add to custom themes
                const newCustomThemes = {
                    ...customThemes,
                    [themeKey]: ui.lospecPreview
                };
                
                setCustomThemes(newCustomThemes);
                updateUi({ 
                    currentTheme: themeKey,
                    showLospecImport: false, 
                    lospecSlug: '', 
                    lospecPreview: null 
                });
            }
        };

        const removeCustomTheme = (themeKey) => {
            if (builtInThemes[themeKey]) return; // Can't delete built-in themes
            
            const newCustomThemes = { ...customThemes };
            delete newCustomThemes[themeKey];
            setCustomThemes(newCustomThemes);
            
            // Switch to light theme if current theme was deleted
            if (ui.currentTheme === themeKey) {
                updateUi({ currentTheme: 'light' });
            }
        };

        // Export/Import
        const generateMarkdown = () => {
            return trees.map((tree) => {
                const nodesToUse = ui.currentFilter !== 'all' ? getFilteredNodes(tree.nodes) : tree.nodes;
                
                let treeMarkdown = tree.id === 'main' ? `# ${tree.title}` : `## ${tree.title}`;
                if (tree.breadcrumb.length > 0) {
                    treeMarkdown += ` (Branch from: ${tree.breadcrumb.join(' > ')})`;
                }
                treeMarkdown += '\n\n';
                
                const nodeMarkdown = nodesToUse.map(node => {
                    const indent = '  '.repeat(node.level);
                    let content;
                    
                    if (node.isTask) {
                        const taskSymbol = node.isCompleted ? '- [x]' : '- [ ]';
                        content = `${indent}${taskSymbol} ${node.content}`;
                    } else {
                        content = `${indent}- ${node.content}`;
                    }
                    
                    const isBranchedOut = trees.some(otherTree => otherTree.parentNodeId === node.id);
                    if (isBranchedOut) {
                        const branchedTree = trees.find(otherTree => otherTree.parentNodeId === node.id);
                        if (branchedTree) {
                            content += ` → branched to: ${branchedTree.title}`;
                        }
                    }
                    
                    if (node.note && node.note.trim()) {
                        const noteLines = node.note.split('\n');
                        const indentedNote = noteLines.map(line => `${indent}  > ${line}`).join('\n');
                        content += '\n' + indentedNote;
                    }
                    
                    return content;
                }).join('\n');
                
                return treeMarkdown + (nodeMarkdown || '*Empty tree*');
            }).join('\n\n---\n\n');
        };

        const exportMarkdown = () => {
            const markdown = generateMarkdown();
            const blob = new Blob([markdown], { type: 'text/markdown' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            const filterSuffix = ui.currentFilter !== 'all' ? `-${ui.currentFilter}` : '';
            a.download = `tree-e-export${filterSuffix}.md`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        };

        const clearAll = () => {
            setTrees([{
                id: 'main',
                title: 'Main Tree',
                nodes: [],
                parentTreeId: null,
                parentNodeId: null,
                breadcrumb: []
            }]);
            setActiveTreeId('main');
            setSelectedNodeId(null);
            updateUi({ 
                indentLevel: 0,
                showClearConfirm: false
            });
        };

        // Event handlers
        const handleBackgroundClick = (e) => {
            if (e.target.classList.contains('app') || 
                e.target.classList.contains('main-content') || 
                e.target.classList.contains('tree-container') ||
                e.target.classList.contains('nodes-list')) {
                
                setSelectedNodeId(null);
                updateUi({ 
                    showThemeDropdown: false,
                    showFilterDropdown: false,
                    showMainMenu: false,
                    showLospecImport: false,
                    showSyncMenu: false,
                    editingNodeId: null,
                    editText: '',
                    showSwipeHints: false
                });
                
                const activeTree = getActiveTree();
                if (activeTree?.nodes.length > 0) {
                    updateUi({ indentLevel: activeTree.nodes[activeTree.nodes.length - 1].level });
                } else {
                    updateUi({ indentLevel: 0 });
                }
            }
        };

        // Derived state
        const activeTree = getActiveTree();
        const currentNodes = activeTree?.nodes || [];
        const filteredNodes = getFilteredNodes();
        const selectedNode = selectedNodeId ? currentNodes.find(node => node.id === selectedNodeId) : null;
        
        const filterOptions = [
            { key: 'all', label: 'All Nodes', icon: '◎' },
            { key: 'tasks', label: 'Tasks', icon: '□' },
            { key: 'notes', label: 'With Notes', icon: '◊' },
            { key: 'branched', label: 'Branched', icon: '⫷' }
        ];

        return (
            <div 
                className="app" 
                style={{ 
                    backgroundColor: theme.background,
                    color: theme.text 
                }}
                onClick={handleBackgroundClick}
            >
                {/* Header */}
                <div className="header" style={{ backgroundColor: theme.background, borderColor: theme.border }} {...(trees.length > 1 ? enhancedTreeSwipeHandlers : {})}>
                    <div className="header-main">
                        <div className="header-left">
                            <div className="header-title">
                                {trees.length > 1 && (
                                    <div className="tree-dots" title="Swipe to navigate between trees">
                                        {trees.map((_, index) => (
                                            <div
                                                key={index}
                                                className={`tree-dot ${index === getActiveTreeIndex() ? 'active' : ''}`}
                                                style={{
                                                    backgroundColor: index === getActiveTreeIndex() ? theme.text : theme.text + '40'
                                                }}
                                            />
                                        ))}
                                    </div>
                                )}
                            </div>
                            
                            {ui.currentFilter !== 'all' && (
                                <span className="badge" style={{ 
                                    color: theme.text + '99',
                                    background: theme.border
                                }}>
                                    {filterOptions.find(f => f.key === ui.currentFilter)?.icon}
                                    {filterOptions.find(f => f.key === ui.currentFilter)?.label}
                                </span>
                            )}
                        </div>
                        
                        <div className="header-controls">
                            {/* Sync Button */}
                            <div className="dropdown">
                                <button 
                                    className="control-btn"
                                    onClick={(e) => {
                                        e.stopPropagation();
                                        updateUi({ 
                                            showSyncMenu: !ui.showSyncMenu, 
                                            showMainMenu: false, 
                                            showThemeDropdown: false 
                                        });
                                    }}
                                    style={{
                                        backgroundColor: getColorForLevel(theme, 0),
                                        borderColor: theme.border,
                                        color: theme.text
                                    }}
                                    title="Sync between devices"
                                >
                                    ⟲
                                </button>
                                {ui.showSyncMenu && (
                                    <div 
                                        className="dropdown-content"
                                        style={{
                                            backgroundColor: theme.background,
                                            borderColor: theme.border,
                                            color: theme.text
                                        }}
                                    >
                                        <button
                                            className="dropdown-item"
                                            onClick={handleQRExport}
                                            disabled={trees.length === 0 || trees.every(tree => tree.nodes.length === 0)}
                                            style={{ color: (trees.length === 0 || trees.every(tree => tree.nodes.length === 0)) ? theme.text + '50' : theme.text }}
                                        >
                                            <span>📤 Export QR</span>
                                        </button>
                                        <button
                                            className="dropdown-item"
                                            onClick={handleQRImport}
                                            style={{ color: theme.text }}
                                        >
                                            <span>📥 Import QR</span>
                                        </button>
                                    </div>
                                )}
                            </div>

                            {/* Main Menu */}
                            <div className="dropdown">
                                <button 
                                    className="menu-btn"
                                    onClick={(e) => {
                                        e.stopPropagation();
                                        updateUi({ 
                                            showMainMenu: !ui.showMainMenu, 
                                            showThemeDropdown: false, 
                                            showFilterDropdown: false,
                                            showSyncMenu: false
                                        });
                                    }}
                                    style={{
                                        backgroundColor: getColorForLevel(theme, 0),
                                        borderColor: theme.border,
                                        color: theme.text
                                    }}
                                >
                                    ≡
                                </button>
                                {ui.showMainMenu && (
                                    <div 
                                        className="dropdown-content"
                                        style={{
                                            backgroundColor: theme.background,
                                            borderColor: theme.border,
                                            color: theme.text
                                        }}
                                    >
                                        <button
                                            className="dropdown-item"
                                            onClick={() => {
                                                updateUi({ currentFilter: ui.currentFilter === 'all' ? 'tasks' : 'all', showMainMenu: false });
                                            }}
                                            style={{ color: theme.text }}
                                        >
                                            <span>Filter</span>
                                            <span>{ui.currentFilter !== 'all' ? '●' : ''}</span>
                                        </button>
                                        <button
                                            className="dropdown-item"
                                            onClick={() => {
                                                updateUi({ showMainMenu: false, showMarkdownView: !ui.showMarkdownView });
                                            }}
                                            disabled={trees.length === 0 || trees.every(tree => tree.nodes.length === 0)}
                                            style={{ color: (trees.length === 0 || trees.every(tree => tree.nodes.length === 0)) ? theme.text + '50' : theme.text }}
                                        >
                                            <span>{ui.showMarkdownView ? 'Back' : 'Export'}</span>
                                        </button>
                                        <button
                                            className="dropdown-item"
                                            onClick={() => {
                                                updateUi({ showThemeDropdown: !ui.showThemeDropdown, showMainMenu: false });
                                            }}
                                            style={{ color: theme.text }}
                                        >
                                            <span>Themes</span>
                                        </button>
                                        <button
                                            className="dropdown-item"
                                            onClick={() => {
                                                updateUi({ showAbout: true, showMainMenu: false });
                                            }}
                                            style={{ color: theme.text }}
                                        >
                                            <span>About</span>
                                        </button>
                                        <button
                                            className="dropdown-item"
                                            onClick={() => {
                                                if (trees.length > 0 && trees.some(tree => tree.nodes.length > 0)) {
                                                    updateUi({ showClearConfirm: true, showMainMenu: false });
                                                }
                                            }}
                                            disabled={trees.length === 0 || trees.every(tree => tree.nodes.length === 0)}
                                            style={{ color: trees.length === 0 || trees.every(tree => tree.nodes.length === 0) ? theme.text + '50' : '#ef4444' }}
                                        >
                                            <span>Clear All</span>
                                        </button>
                                    </div>
                                )}
                            </div>
                            
                            {/* Theme Dropdown - Fixed positioning */}
                            {ui.showThemeDropdown && (
                                <div style={{ position: 'absolute', top: '100%', right: 0, zIndex: 200 }}>
                                    <div 
                                        className="dropdown-content"
                                        style={{
                                            backgroundColor: theme.background,
                                            borderColor: theme.border,
                                            color: theme.text
                                        }}
                                    >
                                        {/* Built-in themes */}
                                        {Object.entries(builtInThemes).map(([key, themeOption]) => (
                                            <button
                                                key={key}
                                                className="dropdown-item"
                                                onClick={() => {
                                                    updateUi({ currentTheme: key, showThemeDropdown: false });
                                                }}
                                                style={{ color: theme.text }}
                                            >
                                                <span>{themeOption.name}</span>
                                                {ui.currentTheme === key && <span>●</span>}
                                            </button>
                                        ))}
                                        
                                        {/* Custom themes */}
                                        {Object.keys(customThemes).length > 0 && (
                                            <>
                                                <div style={{ borderTop: `1px solid ${theme.border}`, margin: '4px 0' }} />
                                                {Object.entries(customThemes).map(([key, themeOption]) => (
                                                    <div key={key} style={{ display: 'flex', alignItems: 'center' }}>
                                                        <button
                                                            className="dropdown-item"
                                                            onClick={() => {
                                                                updateUi({ currentTheme: key, showThemeDropdown: false });
                                                            }}
                                                            style={{ 
                                                                color: theme.text, 
                                                                flex: 1,
                                                                borderRadius: '0'
                                                            }}
                                                        >
                                                            <span>{themeOption.name}</span>
                                                            {ui.currentTheme === key && <span>●</span>}
                                                        </button>
                                                        <button
                                                            onClick={(e) => {
                                                                e.stopPropagation();
                                                                removeCustomTheme(key);
                                                            }}
                                                            style={{
                                                                background: 'none',
                                                                border: 'none',
                                                                color: '#ef4444',
                                                                cursor: 'pointer',
                                                                padding: '8px',
                                                                fontSize: '0.75rem'
                                                            }}
                                                            title="Delete custom theme"
                                                        >
                                                            ╳
                                                        </button>
                                                    </div>
                                                ))}
                                            </>
                                        )}
                                        
                                        <div style={{ borderTop: `1px solid ${theme.border}`, margin: '4px 0' }} />
                                        <button
                                            className="dropdown-item"
                                            onClick={() => {
                                                updateUi({ showLospecImport: true, showThemeDropdown: false });
                                            }}
                                            style={{ color: theme.prompt, fontStyle: 'italic' }}
                                        >
                                            <span>Import from Lospec...</span>
                                        </button>
                                    </div>
                                </div>
                            )}
                        </div>
                    </div>
                    
                    {/* Breadcrumbs - Pure Hierarchy */}
                    {activeTree?.id !== 'main' && (
                        <div className="breadcrumbs" style={{ color: theme.text }}>
                            <button
                                className="breadcrumb-btn"
                                onClick={() => setActiveTree('main')}
                                style={{ color: theme.text + '99' }}
                            >
                                Main Tree
                            </button>
                            
                            {activeTree?.breadcrumb?.map((crumb, index) => (
                                <React.Fragment key={index}>
                                    <span className="breadcrumb-sep"> > </span>
                                    <span style={{ color: theme.text + '99' }}>{crumb}</span>
                                </React.Fragment>
                            ))}
                            
                            <span className="breadcrumb-sep"> > </span>
                            <span className="breadcrumb-current" style={{ color: theme.text }}>
                                {activeTree?.title}
                            </span>
                            
                            <button
                                className="close-btn"
                                onClick={closeTree}
                                title="Close tree and merge changes back"
                            >
                                ✓ Close
                            </button>
                        </div>
                    )}
                </div>

                {/* Main Content */}
                {ui.showMarkdownView ? (
                    <div className="markdown-view">
                        <div className="markdown-header" style={{ borderColor: theme.border }}>
                            <button
                                className="download-btn"
                                onClick={exportMarkdown}
                                style={{
                                    background: theme.text,
                                    color: theme.background
                                }}
                            >
                                ↓ Download MD
                            </button>
                        </div>
                        <div className="markdown-content" style={{ color: theme.text }}>
                            {generateMarkdown() || 'No content to display'}
                        </div>
                    </div>
                ) : (
                    <div className="main-content">
                        <div className="tree-container">
                            {/* Swipe hints */}
                            {trees.length > 1 && (
                                <>
                                    <div className={`swipe-hints swipe-hint-left ${ui.showSwipeHints ? 'visible' : ''}`} style={{ background: `linear-gradient(to right, ${theme.border}, transparent)` }} />
                                    <div className={`swipe-hints swipe-hint-right ${ui.showSwipeHints ? 'visible' : ''}`} style={{ background: `linear-gradient(to left, ${theme.border}, transparent)` }} />
                                </>
                            )}
                            
                            <div className="nodes-list">
                                {filteredNodes.length === 0 && currentNodes.length > 0 && ui.currentFilter !== 'all' ? (
                                    <div className="empty-state" {...enhancedTreeSwipeHandlers}>
                                        <div className="empty-icon">{filterOptions.find(f => f.key === ui.currentFilter)?.icon}</div>
                                        <div className="empty-title">No {filterOptions.find(f => f.key === ui.currentFilter)?.label.toLowerCase()} found</div>
                                        <div className="empty-desc">
                                            Try a different filter or add some {ui.currentFilter === 'tasks' ? 'task nodes' : ui.currentFilter === 'notes' ? 'notes to your nodes' : 'branched nodes'}.
                                            {trees.length > 1 && <><br /><br />💡 Swipe here to navigate between trees</>}
                                        </div>
                                    </div>
                                ) : filteredNodes.length === 0 ? (
                                    <div className="empty-state" {...enhancedTreeSwipeHandlers}>
                                        <div className="empty-icon">🌱</div>
                                        <div className="empty-title">Empty tree</div>
                                        <div className="empty-desc">
                                            {activeTree?.id === 'main' ? 'Start your Tree-e by adding your first thought below.' : 'This branch is ready for new ideas.'}
                                            {trees.length > 1 && <><br /><br />💡 Swipe here to navigate between trees</>}
                                        </div>
                                    </div>
                                ) : (
                                    <>
                                        {filteredNodes.map(node => (
                                            <NodeComponent
                                                key={node.id}
                                                node={node}
                                                theme={theme}
                                                isSelected={selectedNodeId === node.id}
                                                isEditing={ui.editingNodeId === node.id}
                                                editText={ui.editText}
                                                onEditTextChange={(text) => updateUi({ editText: text })}
                                                trees={trees}
                                                currentTreeId={activeTreeId}
                                                getTextColorForBackground={getTextColorForBackground}
                                                getColorForLevel={getColorForLevel}
                                                onTap={(e) => {
                                                    e.stopPropagation();
                                                    selectNode(node.id);
                                                }}
                                                onIndent={() => indentNode(node.id)}
                                                onOutdent={() => outdentNode(node.id)}
                                                onDelete={() => deleteNode(node.id)}
                                                onFocus={() => focusNode(node.id)}
                                                onToggleTask={() => toggleTask(node.id)}
                                                onToggleComplete={() => toggleComplete(node.id)}
                                                onBranchOut={() => branchOut(node.id)}
                                                onEdit={() => editNode(node.id)}
                                                onSaveEdit={saveEdit}
                                                onCancelEdit={cancelEdit}
                                                onJumpToBranch={() => jumpToBranch(node.id)}
                                            />
                                        ))}
                                        
                                        {/* Empty space at bottom for tree navigation when nodes exist */}
                                        {trees.length > 1 && (
                                            <div 
                                                style={{ 
                                                    height: '100px', 
                                                    display: 'flex', 
                                                    alignItems: 'center', 
                                                    justifyContent: 'center',
                                                    opacity: 0.5,
                                                    fontSize: '0.875rem',
                                                    textAlign: 'center',
                                                    padding: '0 2rem'
                                                }}
                                                {...enhancedTreeSwipeHandlers}
                                            >
                                                💡 Swipe here to navigate between trees
                                            </div>
                                        )}
                                    </>
                                )}
                            </div>
                        </div>
                    </div>
                )}

                {/* Input Area */}
                {!ui.showMarkdownView && (
                    <div className="input-area" style={{ backgroundColor: theme.background, borderColor: theme.border }}>
                        <div 
                            className="input-container"
                            style={{
                                borderColor: theme.border,
                                backgroundColor: theme.background
                            }}
                            onClick={(e) => {
                                e.stopPropagation();
                                inputRef.current?.focus();
                            }}
                            {...inputSwipeHandlers}
                        >
                            <div className="input-prompt" style={{ color: theme.prompt }}>
                                >
                            </div>
                            
                            {ui.indentLevel > 0 && (
                                <div className="indent-indicator" style={{ color: theme.prompt }}>
                                    {'  │'.repeat(ui.indentLevel)}
                                </div>
                            )}
                            
                            <input
                                ref={inputRef}
                                className="main-input"
                                type="text"
                                value={ui.currentInput}
                                onChange={(e) => updateUi({ currentInput: e.target.value })}
                                onKeyDown={(e) => {
                                    if (e.key === 'Enter') {
                                        addNode();
                                    } else if (e.key === 'Tab') {
                                        e.preventDefault();
                                        if (e.shiftKey) {
                                            updateUi({ indentLevel: Math.max(0, ui.indentLevel - 1) });
                                        } else {
                                            updateUi({ indentLevel: ui.indentLevel + 1 });
                                        }
                                    }
                                }}
                                placeholder={
                                    activeTree 
                                        ? `${activeTree.id === 'main' ? 'Main Tree' : activeTree.title}${selectedNode ? `: ${selectedNode.content} (lvl ${selectedNode.level + 1})` : ''} / Swipe left or right here`
                                        : "Start your Tree-e / Swipe left or right here"
                                }
                                style={{ color: theme.text }}
                            />
                        </div>
                    </div>
                )}

                {/* Modals */}
                <Modal
                    isOpen={ui.showAbout}
                    onClose={() => updateUi({ showAbout: false })}
                    title="About Tree-e"
                    theme={theme}
                >
                    <div style={{ display: 'flex', flexDirection: 'column', gap: '1rem' }}>
                        <div>
                            <h4 style={{ marginBottom: '0.5rem', fontSize: '1rem', fontWeight: '600' }}>The Philosophy</h4>
                            <p style={{ lineHeight: 1.6, opacity: 0.9, fontSize: '0.875rem' }}>
                                Tree-e embraces the power of simplicity and exploration. Like branches forming trees, individual thoughts combine to create complex ideas. Branch out to explore different paths and perspectives, creating a forest of interconnected knowledge.
                            </p>
                        </div>
                        
                        <div>
                            <h4 style={{ marginBottom: '0.5rem', fontSize: '1rem', fontWeight: '600' }}>Getting Started</h4>
                            <div style={{ fontFamily: 'JetBrains Mono, monospace', fontSize: '0.75rem', opacity: 0.9, lineHeight: 1.4 }}>
                                <div>• Start typing at the > prompt</div>
                                <div>• Tab to indent, Shift+Tab to outdent</div>
                                <div>• Swipe on input to adjust indent level</div>
                                <div>• Tap nodes to select and access actions</div>
                                <div>• Use Branch to explore thoughts in new trees</div>
                                <div>• Click breadcrumbs to navigate between trees</div>
                                <div>• Click "✓ Close" to merge changes back</div>
                                <div>• Export button shares all trees as Markdown</div>
                                <div>• Use ⟲ button to sync trees and themes between devices via QR codes</div>
                            </div>
                        </div>
                    </div>
                </Modal>

                {/* QR Export Modal */}
                <Modal
                    isOpen={ui.showQRExport}
                    onClose={() => updateUi({ showQRExport: false, qrExportData: null })}
                    title="📤 Export to Another Device"
                    theme={theme}
                >
                    {ui.qrExportData && (
                        <div className="qr-display">
                            <div className="qr-code">
                                <img 
                                    src={ui.qrExportData.qrDataUrl} 
                                    alt="QR Code for Tree-e export"
                                    style={{ display: 'block' }}
                                />
                            </div>
                            
                            <div className="qr-instructions">
                                <p style={{ marginBottom: '0.5rem', fontWeight: '500' }}>
                                    📱 Scan this QR code with your other device
                                </p>
                                <p style={{ fontSize: '0.75rem', opacity: 0.8 }}>
                                    Exporting {ui.qrExportData.treeCount} trees with {ui.qrExportData.nodeCount} total nodes
                                    {ui.qrExportData.includesTheme ? <><br />Including "{theme.name}" theme</> : <><br />Theme will use default on import</>}
                                </p>
                                <p style={{ fontSize: '0.75rem', opacity: 0.7, marginTop: '0.5rem' }}>
                                    Open Tree-e on your other device → ⟲ → Import QR → Scan this code
                                    <br />
                                    Trees and theme will be synced automatically
                                </p>
                            </div>
                        </div>
                    )}
                </Modal>

                {/* QR Import Modal */}
                <Modal
                    isOpen={ui.showQRImport}
                    onClose={() => updateUi({ showQRImport: false, qrImportError: null, qrScanError: null })}
                    title="📥 Import from Another Device"
                    theme={theme}
                >
                    <div style={{ display: 'flex', flexDirection: 'column', gap: '1rem' }}>
                        {ui.qrImportError && (
                            <div style={{ 
                                padding: '0.75rem', 
                                background: '#fef2f2', 
                                color: '#dc2626', 
                                borderRadius: '6px',
                                fontSize: '0.875rem'
                            }}>
                                ❌ {ui.qrImportError}
                            </div>
                        )}

                        {ui.qrScanError && (
                            <div style={{ 
                                padding: '0.75rem', 
                                background: '#fef2f2', 
                                color: '#dc2626', 
                                borderRadius: '6px',
                                fontSize: '0.875rem'
                            }}>
                                📷 {ui.qrScanError}
                            </div>
                        )}

                        <QRScanner
                            onScan={onQRScan}
                            onError={onQRScanError}
                            onClose={() => updateUi({ showQRImport: false })}
                        />
                    </div>
                </Modal>
                
                <Modal
                    isOpen={!!ui.focusedNode}
                    onClose={() => updateUi({ focusedNode: null })}
                    title={`Notes: ${ui.focusedNode?.content || ''}`}
                    theme={theme}
                >
                    <textarea
                        className="note-editor"
                        value={ui.focusedNode?.note || ''}
                        onChange={(e) => updateUi({ 
                            focusedNode: { ...ui.focusedNode, note: e.target.value }
                        })}
                        placeholder="Add detailed notes for this node..."
                        style={{
                            backgroundColor: getColorForLevel(theme, 1),
                            borderColor: theme.border,
                            color: getTextColorForBackground(getColorForLevel(theme, 1))
                        }}
                    />
                    <div style={{ marginTop: '16px', display: 'flex', justifyContent: 'flex-end' }}>
                        <button
                            onClick={() => {
                                saveFocusNote(ui.focusedNode?.note || '');
                            }}
                            style={{
                                background: '#3b82f6',
                                color: 'white',
                                border: 'none',
                                padding: '8px 16px',
                                borderRadius: '6px',
                                cursor: 'pointer'
                            }}
                        >
                            Save & Close
                        </button>
                    </div>
                </Modal>

                <Modal 
                    isOpen={ui.showClearConfirm} 
                    onClose={() => updateUi({ showClearConfirm: false })} 
                    title={trees.length > 1 ? "Clear your entire forest?" : "Clear your garden?"} 
                    theme={theme}
                >
                    <div style={{ marginBottom: '16px' }}>
                        {trees.length > 1 ? 
                            "This will remove all your trees and every carefully cultivated thought. Your entire forest cannot be replanted once cleared." :
                            "This will remove all your carefully cultivated thoughts. They cannot be replanted once cleared."
                        }
                    </div>
                    <div style={{ display: 'flex', gap: '12px', justifyContent: 'flex-end' }}>
                        <button
                            onClick={() => updateUi({ showClearConfirm: false })}
                            style={{
                                background: theme.border,
                                color: theme.text,
                                border: 'none',
                                padding: '8px 16px',
                                borderRadius: '6px',
                                cursor: 'pointer'
                            }}
                        >
                            Cancel
                        </button>
                        <button
                            onClick={clearAll}
                            style={{
                                background: '#ef4444',
                                color: 'white',
                                border: 'none',
                                padding: '8px 16px',
                                borderRadius: '6px',
                                cursor: 'pointer'
                            }}
                        >
                            Clear All
                        </button>
                    </div>
                </Modal>

                <Modal
                    isOpen={ui.showLospecImport}
                    onClose={() => updateUi({ showLospecImport: false, lospecSlug: '', lospecPreview: null })}
                    title="Import Theme from Lospec"
                    theme={theme}
                >
                    <div style={{ display: 'flex', flexDirection: 'column', gap: '1rem' }}>
                        <div>
                            <label style={{ display: 'block', marginBottom: '0.5rem', fontSize: '0.875rem', fontWeight: '500' }}>
                                Palette Slug (from Lospec URL)
                            </label>
                            <div style={{ display: 'flex', gap: '0.5rem' }}>
                                <input
                                    type="text"
                                    value={ui.lospecSlug}
                                    onChange={(e) => updateUi({ lospecSlug: e.target.value })}
                                    placeholder="e.g., nintendo-gameboy-bgb"
                                    style={{
                                        flex: 1,
                                        padding: '8px 12px',
                                        border: `1px solid ${theme.border}`,
                                        borderRadius: '6px',
                                        backgroundColor: theme.background,
                                        color: theme.text,
                                        fontSize: '0.875rem'
                                    }}
                                    onKeyDown={(e) => {
                                        if (e.key === 'Enter') {
                                            previewLospecPalette();
                                        }
                                    }}
                                />
                                <button
                                    onClick={previewLospecPalette}
                                    disabled={ui.lospecLoading || !ui.lospecSlug.trim()}
                                    style={{
                                        background: '#3b82f6',
                                        color: 'white',
                                        border: 'none',
                                        padding: '8px 16px',
                                        borderRadius: '6px',
                                        cursor: ui.lospecLoading || !ui.lospecSlug.trim() ? 'not-allowed' : 'pointer',
                                        opacity: ui.lospecLoading || !ui.lospecSlug.trim() ? 0.5 : 1
                                    }}
                                >
                                    {ui.lospecLoading ? 'Loading...' : 'Preview'}
                                </button>
                            </div>
                            <div style={{ fontSize: '0.75rem', opacity: 0.7, marginTop: '0.5rem' }}>
                                Find palettes at <a href="https://lospec.com/palette-list" target="_blank" rel="noopener noreferrer" style={{ color: theme.prompt }}>lospec.com/palette-list</a>
                            </div>
                        </div>

                        {ui.lospecPreview && (
                            <div>
                                <h4 style={{ marginBottom: '0.5rem', fontSize: '1rem', fontWeight: '600' }}>
                                    Preview: {ui.lospecPreview.name}
                                </h4>
                                <div 
                                    style={{ 
                                        padding: '1rem', 
                                        borderRadius: '6px', 
                                        backgroundColor: ui.lospecPreview.background,
                                        color: ui.lospecPreview.text,
                                        border: `1px solid ${ui.lospecPreview.border}`
                                    }}
                                >
                                    <div style={{ marginBottom: '0.5rem', color: ui.lospecPreview.prompt, fontSize: '0.875rem', fontWeight: '500' }}>
                                        Sample Tree-e Theme
                                    </div>
                                    <div style={{ display: 'flex', gap: '4px', marginBottom: '0.5rem' }}>
                                        {ui.lospecPreview.levelColors.map((color, index) => (
                                            <div
                                                key={index}
                                                style={{
                                                    width: '24px',
                                                    height: '24px',
                                                    backgroundColor: color,
                                                    borderRadius: '4px',
                                                    border: `1px solid ${ui.lospecPreview.border}`
                                                }}
                                            />
                                        ))}
                                    </div>
                                    <div style={{ fontSize: '0.75rem', opacity: 0.8 }}>
                                        Level colors for hierarchy
                                    </div>
                                </div>

                                <div style={{ marginTop: '1rem', display: 'flex', gap: '12px', justifyContent: 'flex-end' }}>
                                    <button
                                        onClick={() => updateUi({ lospecPreview: null })}
                                        style={{
                                            background: theme.border,
                                            color: theme.text,
                                            border: 'none',
                                            padding: '8px 16px',
                                            borderRadius: '6px',
                                            cursor: 'pointer'
                                        }}
                                    >
                                        Back
                                    </button>
                                    <button
                                        onClick={importLospecTheme}
                                        style={{
                                            background: '#22c55e',
                                            color: 'white',
                                            border: 'none',
                                            padding: '8px 16px',
                                            borderRadius: '6px',
                                            cursor: 'pointer'
                                        }}
                                    >
                                        Import Theme
                                    </button>
                                </div>
                            </div>
                        )}
                    </div>
                </Modal>
            </div>
        );
    };

    ReactDOM.render(<TreeApp />, document.getElementById('root'));

    // Service Worker
    if ('serviceWorker' in navigator) {
        const swCode = `
            const CACHE_NAME = 'tree-e-v2';
            const urlsToCache = ['/', '/index.html'];

            self.addEventListener('install', event => {
                event.waitUntil(
                    caches.open(CACHE_NAME)
                        .then(cache => cache.addAll(urlsToCache))
                );
            });

            self.addEventListener('fetch', event => {
                event.respondWith(
                    caches.match(event.request)
                        .then(response => {
                            if (response) {
                                return response;
                            }
                            return fetch(event.request);
                        })
                );
            });
        `;
        
        const blob = new Blob([swCode], { type: 'application/javascript' });
        const swUrl = URL.createObjectURL(blob);
        
        navigator.serviceWorker.register(swUrl)
            .then(registration => {
                console.log('SW registered: ', registration);
            })
            .catch(registrationError => {
                console.log('SW registration failed: ', registrationError);
            });
    }
</script>

</body>
</html>
