<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tree-e - Hierarchical Note Taking</title>

<!-- PWA Meta Tags -->

<meta name="description" content="Tree-e: Hierarchical note-taking app with beautiful themes">
<meta name="theme-color" content="#e9f5e9">
<link rel="icon" type="image/svg+xml" href="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgd2lkdGg9IjQwOTYiIGhlaWdodD0iNDA5NiIgdmlld0JveD0iMCAwIDQwOTYgNDA5NiI+PHJlY3Qgd2lkdGg9IjQwOTYiIGhlaWdodD0iNDA5NiIgZmlsbD0iI2U4ZTllNiIvPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDIwNDggMjA0OCkiPjxwYXRoIGQ9Ik00MDcuNTAxLDEzNTAuMDQgTDAsLTEzNTAuMDQgTC00MDcuNTAxLDEzNTAuMDQgTDQwNy41MDEsMTM1MC4wNCBaIiBmaWxsPSIjMzgyNDE4Ii8+PHBhdGggZD0iTS05LjA3NTIyZS0wNiwtOTQ1LjM2MiBDLTkuMDc1MjJlLTA2LC04MTUuNzA2IDEwNS44NjYsLTcwOS44NCAyMzUuNTIyLC03MDkuODQgTDk0MC45LC03MDkuODQgQzEwNzAuNTYsLTcwOS44NCAxMTc2LjQyLC04MTUuNzA2IDExNzYuNDIsLTk0NS4zNjIgQzExNzYuNDIsLTEwNzUuMDIgMTA3MC41NiwtMTE4MC44OCA5NDAuOSwtMTE4MC44OCBMMjM1LjUyMiwtMTE4MC44OCBDMTA1Ljg2NiwtMTE4MC44OCAtOS4wNzUyMmUtMDYsLTEwNzUuMDIgLTkuMDc1MjJlLTA2LC05NDUuMzYyIFoiIGZpbGw9IiM5YWJjNDUiLz48cGF0aCBkPSJNMTE3Ni40MiwtOTkuNTk1OSBDMTE3Ni40MiwzMC4wNjA0IDEwNzAuNTYsMTM1LjkyNiA5NDAuOSwxMzUuOTI2IEwyMzUuNTIyLDEzNS45MjYgQzEwNS44NjYsMTM1LjkyNiAtMy40MTA2MWUtMTMsMzAuMDYwNCAtMy40MTA2MWUtMTMsLTk5LjU5NTkgQy0zLjQxMDYxZS0xMywtMjI5LjI1MiAxMDUuODY2LC0zMzUuMTE4IDIzNS41MjIsLTMzNS4xMTggTDk0MC45LC0zMzUuMTE4IEMxMDcwLjU2LC0zMzUuMTE4IDExNzYuNDIsLTIyOS4yNTIgMTE3Ni40MiwtOTkuNTk1OSBaIiBmaWxsPSIjOWFiYzQ1Ii8+PHBhdGggZD0iTS0yLjI3Mzc0ZS0xMywtNTcwLjY0MSBDLTIuMjczNzRlLTEzLC00NDAuOTg0IC0xMDUuODY2LC0zMzUuMTE4IC0yMzUuNTIyLC0zMzUuMTE4IEwtOTQwLjksLTMzNS4xMTggQy0xMDcwLjU2LC0zMzUuMTE4IC0xMTc2LjQyLC00NDAuOTg0IC0xMTc2LjQyLC01NzAuNjQxIEMtMTE3Ni40MiwtNzAwLjI5NyAtMTA3MC41NiwtODA2LjE2MyAtOTQwLjksLTgwNi4xNjMgTC0yMzUuNTIyLC04MDYuMTYzIEMtMTA1Ljg2NiwtODA2LjE2MyAtMi4yNzM3NGUtMTMsLTcwMC4yOTcgLTIuMjczNzRlLTEzLC01NzAuNjQxIFoiIGZpbGw9IiNlMWY5YTQiLz48cGF0aCBkPSJNMCwzMjIuMjIxIEMwLDQ1MS44NzggLTEwNS44NjYsNTU3Ljc0NCAtMjM1LjUyMiw1NTcuNzQ0IEwtOTQwLjksNTU3Ljc0NCBDLTEwNzAuNTYsNTU3Ljc0NCAtMTE3Ni40Miw0NTEuODc4IC0xMTc2LjQyLDMyMi4yMjEgQy0xMTc2LjQyLDE5Mi41NjUgLTEwNzAuNTYsODYuNjk5IC05NDAuOSw4Ni42OTkgTC0yMzUuNTIyLDg2LjY5OSBDLTEwNS44NjYsODYuNjk5IDAsMTkyLjU2NSAwLDMyMi4yMjEgWiIgZmlsbD0iIzY0N2YyMSIvPjwvZz48L3N2Zz4=">
<link rel="manifest" href="data:application/json;base64,eyJuYW1lIjoiVHJlZS1lIiwic2hvcnRfbmFtZSI6IlRyZWUtZSIsImRpc3BsYXkiOiJzdGFuZGFsb25lIiwic3RhcnRfdXJsIjoiLyIsInRoZW1lX2NvbG9yIjoiI2U5ZjVlOSIsImJhY2tncm91bmRfY29sb3IiOiIjZTlmNWU5IiwiaWNvbnMiOlt7InNyYyI6ImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjJaWEp6YVc5dVBTSXhMakVpSUhodGJHNXpQU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh5TURBd0wzTjJaeUlnZDJsa2RHZzlJalF3T1RZaUlHaGxhV2RvZEQwaU5EQTVOaUlnZG1sbGQwSnZlRDBpTUNBd0lEUXdPVFlnTkRBNU5pSStQSEpsWTNRZ2QybGtkR2c5SWpRd09UWWlJR2hsYVdkb2REMGlOREE1TmlJZ1ptbHNiRDBpSTJVNFpUbGxOaUl2UGp4bklIUnlZVzV6Wm05eWJUMGlkSEpoYm5Oc1lYUmxLREkxTkRrZ01qVTBPQ2tpUGo4OGNHRjBhQ0JrUFNKTk5EQTNMalV3TVN3eE16VXdMakEwSUV3d0xDMHhNelV3TGpBMElFd3RORkEzTGpVd01TdzFOall3TGpBMElFdzBNRGN1TlRBeExERXpOVEF1TUNReUhGaUdGWmtZU0laWm1sc2JEMGlJek00TWpReE9DSXZQaUIuTXAwd0xTMHhOWUEzNGNHUXRMeTJUZ3h5U3NJUWp1NTE2UXUweE5TaVFza280JjVMRXhNVFkwTy0zNVFyV1FGRG1aVGNGZHpPaTJJek1POUZlRU9GZUVacWRZdGVGQUYyZm1rbGJGUWlYeTAzT0NDSXlMa2wxRXhOVFpOTVpFVW9ZbFExN0xNaXZQZkJRdEZLRnRGZE5TMjFsUmpZak1FdGs2bmR0TGNKTTdQUHIyVHl0T0M1eWw1dU9GdHVPZ2VucUN3TWdhRXFNREV3aCZRTCl8QnFaMVMxNjhkNU9qNUZoWFJZMjI0am1DQWpGUzI0Vm04REZ4VGRjSFMySWMzdmlsbm5raE1qL2h3YXNzOTJ3N3E1OG9Bb3U2V0pRaTUzMzNQeVNGT3lXeHNlazNDSVdOMXhlSUVONFEzSDhTa1hQWmJoSDlMTVZkNW1PcVJpOXdOVGlMZjBiUktNOTlva3REUVJGNndaclZMTTA0S2dNTEVNV08raDJwUVRoTldFVWdDMHhxemNmbmx5ZVdLaUlHdFJIMUYrL2NkUTN1SytOZkVZRFEzSUV6bCZ3VXNJRjJwRUQsM2pjc0lPTExWZ0Q5QzBjOGpHQXcvUDBFVzNhZmNyM0ZHMGduM0F3RjltaWI4d1NtdlJ3dldmaFFoUzE0SUZzTEdEVW1IRVVUMDA3WWNRUGtFcHZsOHNIUXI4KzYxcUpJSFNOSDFzcHhIWGtZSkNqR0lwTnhVSU84OUZBNDRNM2Y5VGE5NUtLVE96WnFJK3B6L3VrZVBBcWNSZGlZcVVZaFplZTlUTi9wN3pGUWtKRWpLMzRLSE1Jc2lFeUx5VU03bmNpMU1KSkRNVERQTzBFbnhPUHU2UVhGZHd1TnNQOHlHUFJJaEo1OFlhUVhRSEovR0RPSWpidnVURThPWDliUGNrSUlubG1NMUpVZUYzb3FxdjlNaWVNcmxlSUlwczY3aGtKQWNhRW9JeFN5TnUrS2VJZFJNUWpQVkdUYVBJU1UxaFRhQU5tTWp6U2NPTzJBPUUwRWJUMU1sWUo1SmtPQXFGVE5ST2Z6VzNQcEZTMS9ndlVHYi9wbHJEdk1IMDQ0NzJJM1Y2OGFQVjFFQU1DY3hRdFVCNWNBanNSMDVaeFQ4bC5iRVhhazk9PT0iLCJ0eXBlIjoiaW1hZ2Uvc3ZnK3htbCIsInNpemVzIjoiNDA5Nng0MDk2In1dfQ==">

<!-- React and Babel -->

<script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>

<script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>

<script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>

<!-- Fonts -->

<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">

<style>
    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
    }
    
    body {
        font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        touch-action: manipulation;
        user-select: none;
        -webkit-user-select: none;
        -webkit-tap-highlight-color: transparent;
        overflow-x: hidden;
        font-size: 16px;
        overscroll-behavior: none;
        -webkit-overflow-scrolling: touch;
    }
    
    .app {
        height: 100vh;
        height: 100dvh;
        display: flex;
        flex-direction: column;
        overflow: hidden;
        width: 100vw;
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
    }
    
    .header {
        display: flex;
        flex-direction: column;
        padding: 1rem;
        flex-shrink: 0;
        border-bottom: 1px solid rgba(0,0,0,0.08);
        gap: 0.5rem;
        min-height: 0; /* Important for flex layout */
    }
    
    .header-main {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.75rem;
    }
    
    .header-left {
        display: flex;
        align-items: center;
        gap: 0.75rem;
    }
    
    .header-title {
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }
    
    .header h1 {
        font-size: clamp(1rem, 4vw, 1.25rem);
        font-weight: 600;
        margin: 0;
    }
    
    .tree-dots {
        display: flex;
        gap: 4px;
        align-items: center;
    }
    
    .tree-dot {
        width: 6px;
        height: 6px;
        border-radius: 50%;
        transition: all 0.2s ease;
    }
    
    .tree-dot.active {
        width: 8px;
        height: 8px;
    }
    
    .badge {
        font-size: clamp(0.625rem, 2.5vw, 0.75rem);
        padding: 0.125rem 0.375rem;
        border-radius: 4px;
        display: flex;
        align-items: center;
        gap: 0.25rem;
    }
    
    .header-controls {
        display: flex;
        gap: clamp(0.375rem, 2vw, 0.5rem);
        align-items: center;
        position: relative;
    }
    
    .control-btn, .menu-btn {
        width: clamp(32px, 8vw, 36px);
        height: clamp(32px, 8vw, 36px);
        border: 1px solid;
        border-radius: 6px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: clamp(0.875rem, 3vw, 1rem);
        cursor: pointer;
        background: transparent;
        flex-shrink: 0;
        transition: transform 0.1s ease;
    }
    
    .menu-btn {
        width: clamp(36px, 8vw, 40px);
        height: clamp(36px, 8vw, 40px);
        border-radius: 8px;
    }
    
    .control-btn:active, .menu-btn:active {
        transform: scale(0.95);
    }
    
    .control-btn:disabled {
        opacity: 0.4;
        cursor: not-allowed;
        transform: none;
    }
    
    .tree-nav {
        display: flex;
        gap: 0.25rem;
        align-items: center;
    }
    
    .nav-btn {
        width: 28px;
        height: 28px;
        border: 1px solid;
        border-radius: 4px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 0.75rem;
        cursor: pointer;
        background: transparent;
    }
    
    .nav-counter {
        font-size: 0.75rem;
        padding: 0 0.25rem;
        font-family: 'JetBrains Mono', monospace;
    }
    
    .breadcrumbs {
        display: flex;
        align-items: center;
        gap: 0.25rem;
        flex-wrap: wrap;
        font-family: 'JetBrains Mono', monospace;
        font-size: clamp(0.6875rem, 2vw, 0.75rem);
    }
    
    .breadcrumb-btn {
        background: none;
        border: none;
        cursor: pointer;
        text-decoration: underline;
        font: inherit;
    }
    
    .breadcrumb-sep {
        opacity: 0.6;
    }
    
    .breadcrumb-current {
        font-weight: 600;
        opacity: 1;
    }
    
    .close-btn {
        background: #22c55e;
        color: white;
        border: none;
        padding: 0.25rem 0.5rem;
        border-radius: 4px;
        font-size: 0.75rem;
        cursor: pointer;
        margin-left: 0.5rem;
    }
    
    .main-content {
        flex: 1;
        overflow: hidden;
        display: flex;
        flex-direction: column;
        position: relative;
        min-height: 0; /* Important for flex layout */
        height: 0; /* Force flex item to respect container height */
    }
    
    .tree-container {
        flex: 1;
        overflow-y: auto;
        overflow-x: hidden;
        padding: clamp(0.75rem, 3vw, 1rem);
        position: relative;
        min-height: 0; /* Important for flex layout */
        /* Ensure smooth scrolling on mobile */
        -webkit-overflow-scrolling: touch;
        overscroll-behavior-y: contain;
    }

    .tree-container.multi-tree {
        padding-left: clamp(1.5rem, 5vw, 2rem);
        padding-right: clamp(1.5rem, 5vw, 2rem);
    }
    
    .swipe-hints {
        position: absolute;
        top: 0;
        bottom: 0;
        width: clamp(20px, 4vw, 30px);
        pointer-events: none;
        z-index: 10;
        opacity: 0;
        transition: opacity 0.3s ease;
    }
    
    .swipe-hint-left {
        left: 0;
        background: linear-gradient(to right, rgba(0,0,0,0.03), transparent);
    }
    
    .swipe-hint-right {
        right: 0;
        background: linear-gradient(to left, rgba(0,0,0,0.03), transparent);
    }
    
    .swipe-hints.visible {
        opacity: 1;
    }

    .tree-container.multi-tree::before,
    .tree-container.multi-tree::after {
        content: '';
        position: absolute;
        top: 50%;
        transform: translateY(-50%);
        width: 4px;
        height: 20px;
        background: currentColor;
        opacity: 0.1;
        border-radius: 2px;
        pointer-events: none;
        z-index: 5;
        transition: opacity 0.3s ease;
    }

    .tree-container.multi-tree::before {
        left: 8px;
    }

    .tree-container.multi-tree::after {
        right: 8px;
    }

    .tree-container.multi-tree:hover::before,
    .tree-container.multi-tree:hover::after {
        opacity: 0.2;
    }
    
    .nodes-list {
        display: flex;
        flex-direction: column;
        gap: 0.125rem;
        padding-bottom: 4rem; /* Increased padding to ensure last item is visible */
        min-height: 100%; /* Ensure it takes full height of container */
    }
    
    .node {
        display: flex;
        align-items: flex-start;
        gap: 0;
    }
    
    .node-indent {
        display: flex;
        flex-shrink: 0;
    }
    
    .indent-space {
        width: clamp(24px, 5vw, 32px);
    }
    
    .node-content-wrapper {
        display: flex;
        flex-direction: column;
        align-items: flex-start;
    }
    
    .node-content {
        padding: 8px 12px;
        border-radius: 6px;
        border: 1px solid;
        cursor: pointer;
        display: inline-flex;
        align-items: center;
        gap: 8px;
        word-wrap: break-word;
        overflow-wrap: break-word;
        transition: transform 0.1s ease;
        max-width: calc(100vw - 60px);
        width: auto;
        position: relative;
    }
    
    .node-content:active {
        transform: scale(0.98);
    }
    
    .node-content.selected {
        border-width: 2px;
    }
    
    .node-content.completed {
        opacity: 0.6;
    }

    .node-content.draggable {
        cursor: grab;
    }

    .node-content.dragging {
        opacity: 0.5;
        transform: scale(0.95);
        cursor: grabbing;
    }

    .node-content.drag-over {
        border-style: dashed;
        border-width: 2px;
    }

    .node-content.drag-over-above {
        border-top: 3px solid #3b82f6;
    }

    .node-content.drag-over-below {
        border-bottom: 3px solid #3b82f6;
    }

    .drag-indicator {
        position: absolute;
        left: -8px;
        width: 4px;
        height: 100%;
        background: #3b82f6;
        border-radius: 2px;
        opacity: 0;
        transition: opacity 0.2s ease;
    }

    .node-content.drag-over .drag-indicator {
        opacity: 1;
    }
    
    .task-toggle {
        font-size: 16px;
        cursor: pointer;
        flex-shrink: 0;
    }
    
    .node-text {
        flex: 1;
        font-size: clamp(0.875rem, 3vw, 1rem);
        line-height: 1.4;
        min-width: 0;
    }
    
    .node-text.completed {
        text-decoration: line-through;
    }
    
    .node-icons {
        display: flex;
        gap: 4px;
        font-size: 12px;
        opacity: 0.7;
        flex-shrink: 0;
    }
    
    .branch-link {
        color: #3b82f6;
        cursor: pointer;
        opacity: 1;
    }
    
    .node-actions {
        display: flex;
        gap: 6px;
        margin-top: 8px;
        flex-wrap: wrap;
    }
    
    .action-btn {
        display: flex;
        align-items: center;
        gap: 4px;
        padding: 5px 10px;
        border: none;
        border-radius: 4px;
        font-size: 11px;
        color: white;
        cursor: pointer;
        transition: transform 0.1s ease;
    }
    
    .action-btn:active {
        transform: scale(0.95);
    }
    
    .action-btn.edit { background: #6366f1; }
    .action-btn.task { background: #22c55e; }
    .action-btn.focus { background: #3b82f6; }
    .action-btn.branch { background: #10b981; }
    .action-btn.delete { background: #ef4444; }
    .action-btn.save { background: #22c55e; }
    .action-btn.cancel { background: #6b7280; }
    
    .node-edit-input {
        background: transparent;
        border: none;
        outline: none;
        font: inherit;
        width: 100%;
        min-width: 100px;
    }
    
    .input-area {
        flex-shrink: 0;
        padding: 16px;
        border-top: 1px solid rgba(0,0,0,0.08);
        min-height: 0; /* Important for flex layout */
        /* Ensure it stays visible above mobile keyboards */
        position: relative;
        z-index: 10;
    }
    
    .input-container {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 12px 16px;
        border: 1px solid;
        border-radius: 8px;
        cursor: text;
    }
    
    .input-prompt {
        font-family: 'JetBrains Mono', monospace;
        font-size: 20px;
        font-weight: 500;
    }
    
    .indent-indicator {
        font-family: 'JetBrains Mono', monospace;
        font-size: 12px;
        opacity: 0.6;
    }
    
    .main-input {
        flex: 1;
        border: none;
        outline: none;
        background: transparent;
        font-family: 'JetBrains Mono', monospace;
        font-size: 16px;
    }
    
    .main-input::placeholder {
        opacity: 0.6;
    }
    
    .instructions {
        margin-top: 10px;
        font-family: 'JetBrains Mono', monospace;
        font-size: 11px;
        opacity: 0.6;
        text-align: center;
        line-height: 1.4;
    }
    
    .empty-state {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 1rem;
        padding: 3rem 1rem;
        text-align: center;
        min-height: 50vh; /* Ensure it takes up adequate space */
        justify-content: center;
    }
    
    .empty-icon {
        font-size: 2.5rem;
        opacity: 0.6;
    }
    
    .empty-title {
        font-size: 1rem;
        font-weight: 500;
    }
    
    .empty-desc {
        font-size: 0.875rem;
        opacity: 0.7;
        line-height: 1.4;
    }
    
    .modal {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0,0,0,0.5);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000;
        padding: 20px;
    }
    
    .modal-content {
        width: 100%;
        max-width: 500px;
        max-height: 80vh;
        border-radius: 8px;
        overflow: hidden;
        display: flex;
        flex-direction: column;
    }
    
    .modal-header {
        padding: 16px;
        border-bottom: 1px solid rgba(0,0,0,0.08);
        display: flex;
        align-items: center;
        justify-content: space-between;
    }
    
    .modal-title {
        font-size: 16px;
        font-weight: 600;
        margin: 0;
    }
    
    .modal-close {
        background: none;
        border: none;
        font-size: 16px;
        cursor: pointer;
        padding: 4px;
    }
    
    .modal-body {
        flex: 1;
        overflow-y: auto;
        padding: 16px;
    }
    
    .note-editor {
        width: 100%;
        min-height: 200px;
        padding: 12px;
        border: 1px solid rgba(0,0,0,0.15);
        border-radius: 6px;
        font-size: 14px;
        font-family: inherit;
        resize: vertical;
    }
    
    .dropdown {
        position: relative;
        display: inline-block;
        z-index: 100;
    }
    
    .dropdown-content {
        position: absolute;
        top: 100%;
        right: 0;
        border-radius: 6px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        z-index: 1000;
        min-width: 140px;
        max-height: 300px;
        overflow-y: auto;
        border: 1px solid;
    }
    
    .dropdown-item {
        padding: 8px 12px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: space-between;
        border: none;
        background: none;
        width: 100%;
        text-align: left;
        font-size: 0.875rem;
        transition: background-color 0.15s ease;
    }
    
    .dropdown-item:hover {
        background: rgba(0,0,0,0.08);
    }
    
    .dropdown-item:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }
    
    .markdown-view {
        display: flex;
        flex-direction: column;
        flex: 1;
        overflow: hidden;
        min-height: 0; /* Important for flex layout */
    }
    
    .markdown-header {
        padding: 1rem;
        border-bottom: 1px solid rgba(0,0,0,0.08);
        display: flex;
        justify-content: flex-end;
        flex-shrink: 0;
    }
    
    .download-btn {
        border: none;
        padding: 8px 16px;
        border-radius: 6px;
        font-size: 0.875rem;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }
    
    .markdown-content {
        flex: 1;
        overflow: auto;
        padding: 1rem;
        font-family: 'JetBrains Mono', monospace;
        white-space: pre-wrap;
        line-height: 1.6;
        font-size: 0.875rem;
        -webkit-overflow-scrolling: touch; /* Smooth scrolling on mobile */
    }

    .sync-options {
        display: flex;
        flex-direction: column;
        gap: 1rem;
    }

    .sync-option {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 1rem;
        border: 1px solid;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.15s ease;
    }

    .sync-option:hover {
        background: rgba(0,0,0,0.05);
        transform: translateY(-1px);
    }

    .sync-option-info {
        display: flex;
        flex-direction: column;
        gap: 0.25rem;
    }

    .sync-option-title {
        font-weight: 500;
        font-size: 0.875rem;
    }

    .sync-option-desc {
        font-size: 0.75rem;
        opacity: 0.7;
    }

    .sync-option-icon {
        font-size: 1.5rem;
    }

    .file-input {
        display: none;
    }

    .file-drop-zone {
        border: 2px dashed;
        border-radius: 8px;
        padding: 2rem;
        text-align: center;
        cursor: pointer;
        transition: all 0.15s ease;
    }

    .file-drop-zone:hover {
        background: rgba(0,0,0,0.05);
    }

    .file-drop-zone.drag-over {
        background: rgba(34, 197, 94, 0.1);
        border-color: #22c55e;
        transform: scale(1.02);
    }

    .btn {
        border: none;
        padding: 8px 16px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 0.875rem;
        font-weight: 500;
        transition: all 0.15s ease;
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
    }

    .btn:hover {
        transform: translateY(-1px);
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }

    .btn:active {
        transform: translateY(0);
    }

    .btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none;
        box-shadow: none;
    }

    .btn-primary { background: #3b82f6; color: white; }
    .btn-success { background: #22c55e; color: white; }
    .btn-danger { background: #ef4444; color: white; }
    .btn-secondary { background: #6b7280; color: white; }
    .btn-purple { background: #8b5cf6; color: white; }
    
    /* Mobile optimizations */
    @media (max-width: 768px) {
        .app {
            /* Ensure proper mobile viewport handling */
            height: 100vh;
            height: 100dvh;
            /* Prevent zoom on input focus */
            -webkit-text-size-adjust: 100%;
        }
        
        .header {
            padding: 0.75rem;
        }
        
        .header h1 {
            font-size: 0.875rem;
        }
        
        .control-btn, .menu-btn {
            width: 32px;
            height: 32px;
            font-size: 0.875rem;
        }
        
        .action-btn span {
            display: none;
        }
        
        .node-text {
            font-size: 0.875rem;
        }
        
        .main-input {
            font-size: 0.875rem;
        }
        
        .input-prompt {
            font-size: 1.125rem;
        }
        
        /* Ensure tree container has proper scrolling on mobile */
        .tree-container {
            padding: 0.75rem;
        }
        
        /* Better touch targets for mobile */
        .node-content {
            min-height: 44px; /* iOS recommended touch target size */
            padding: 12px;
        }
        
        /* Prevent overscroll bounce on body */
        body {
            overscroll-behavior: none;
            -webkit-overflow-scrolling: touch;
        }
    }
    
    /* Additional fix for very small screens */
    @media (max-width: 480px) {
        .input-area {
            padding: 12px;
        }
        
        .tree-container {
            padding: 0.5rem;
        }
        
        .header {
            padding: 0.5rem;
        }
    }
</style>

</head>
<body>
    <div id="root"></div>

<script type="text/babel">
    // ===============================
    // REACT APP STARTS HERE
    // ===============================

    const { useState, useEffect, useRef, useReducer, useCallback, useMemo } = React;

    // ===============================
    // CONSTANTS & UTILITIES
    // ===============================
    
    const THEMES = {
        light: {
            name: 'Light',
            background: '#fafafa',
            text: '#0a0a0a',
            prompt: '#525252',
            border: '#e5e5e5',
            levelColors: ['#ffffff', '#f8f8f8', '#f0f0f0', '#e8e8e8', '#d6d6d6']
        },
        dark: {
            name: 'Dark',
            background: '#0a0b14',
            text: '#e2e4e9',
            prompt: '#9ca3af',
            border: '#2d3748',
            levelColors: ['#1a1b26', '#24283b', '#414868', '#565f89', '#7c7f93']
        }
    };

    const FILTER_OPTIONS = [
        { key: 'all', label: 'All Nodes', icon: '◎' },
        { key: 'tasks', label: 'Tasks', icon: '□' },
        { key: 'notes', label: 'With Notes', icon: '◊' },
        { key: 'branched', label: 'Branched', icon: '⫷' }
    ];

    const STORAGE_KEYS = {
        trees: 'tree-e-trees',
        theme: 'tree-e-theme',
        customThemes: 'tree-e-custom-themes'
    };

    // Utility functions
    const generateId = () => Date.now().toString(36) + Math.random().toString(36).substr(2);
    
    const getColorForLevel = (theme, level) => {
        const colors = theme.levelColors;
        return level < colors.length ? colors[level] : colors[level % colors.length] + '80';
    };

    const getTextColorForBackground = (backgroundColor) => {
        const hex = backgroundColor.replace('#', '');
        const r = parseInt(hex.substr(0, 2), 16);
        const g = parseInt(hex.substr(2, 2), 16);
        const b = parseInt(hex.substr(4, 2), 16);
        const brightness = (r * 299 + g * 587 + b * 114) / 1000;
        return brightness < 128 ? '#ffffff' : '#000000';
    };

    // ===============================
    // STORAGE UTILITIES
    // ===============================

    const storage = {
        save: (key, data) => {
            try {
                localStorage.setItem(key, JSON.stringify(data));
            } catch (error) {
                console.error(`Failed to save ${key}:`, error);
            }
        },
        
        load: (key, defaultValue = null) => {
            try {
                const saved = localStorage.getItem(key);
                return saved ? JSON.parse(saved) : defaultValue;
            } catch (error) {
                console.error(`Failed to load ${key}:`, error);
                return defaultValue;
            }
        }
    };

    const loadInitialData = () => {
        const trees = storage.load(STORAGE_KEYS.trees) || 
                     (storage.load('tree-e-nodes') ? [{
                         id: 'main',
                         title: 'Main Tree',
                         nodes: storage.load('tree-e-nodes'),
                         parentTreeId: null,
                         parentNodeId: null,
                         breadcrumb: []
                     }] : [{
                         id: 'main',
                         title: 'Main Tree',
                         nodes: [],
                         parentTreeId: null,
                         parentNodeId: null,
                         breadcrumb: []
                     }]);

        const customThemes = storage.load(STORAGE_KEYS.customThemes, {});
        const savedTheme = storage.load(STORAGE_KEYS.theme, 'light');
        const allThemes = { ...THEMES, ...customThemes };
        const currentTheme = allThemes[savedTheme] ? savedTheme : 'light';

        return { trees, customThemes, currentTheme };
    };

    // ===============================
    // SYNC UTILITIES
    // ===============================

    const syncUtils = {
        export: (trees, currentTheme, customThemes) => {
            const exportData = {
                version: '1.0',
                timestamp: Date.now(),
                syncCode: Math.random().toString(36).substring(2, 8).toUpperCase(),
                trees: trees.map(tree => ({
                    id: tree.id,
                    title: tree.title,
                    nodes: tree.nodes.map(node => ({
                        id: node.id,
                        content: node.content,
                        level: node.level,
                        note: node.note || '',
                        isTask: node.isTask || false,
                        isCompleted: node.isCompleted || false
                    })),
                    parentTreeId: tree.parentTreeId,
                    parentNodeId: tree.parentNodeId,
                    breadcrumb: tree.breadcrumb || []
                })),
                theme: {
                    currentTheme,
                    customTheme: customThemes[currentTheme] || null,
                    isCustomTheme: !THEMES[currentTheme]
                }
            };
            return JSON.stringify(exportData, null, 2);
        },

        import: (jsonData) => {
            try {
                const data = JSON.parse(jsonData);
                
                if (!data.trees || !Array.isArray(data.trees)) {
                    throw new Error('Invalid export format - missing trees data');
                }

                return {
                    trees: data.trees.map(tree => ({
                        ...tree,
                        id: tree.id === 'main' ? 'main' : generateId(),
                        nodes: (tree.nodes || []).map(node => ({
                            id: generateId(),
                            content: node.content || '',
                            level: node.level || 0,
                            note: node.note || '',
                            isTask: node.isTask || false,
                            isCompleted: node.isCompleted || false
                        }))
                    })),
                    theme: data.theme || null,
                    version: data.version || '1.0',
                    timestamp: data.timestamp || Date.now(),
                    syncCode: data.syncCode || 'SYNC'
                };
            } catch (error) {
                console.error('Import error:', error);
                throw new Error(`Failed to import data: ${error.message}`);
            }
        }
    };

    // ===============================
    // CUSTOM HOOKS
    // ===============================

    const useTouchHandler = (onSwipeLeft, onSwipeRight, threshold = 50) => {
        const touchStart = useRef(null);
        const touchEnd = useRef(null);

        return {
            onTouchStart: (e) => {
                touchEnd.current = null;
                touchStart.current = e.targetTouches[0].clientX;
            },
            onTouchMove: (e) => {
                touchEnd.current = e.targetTouches[0].clientX;
            },
            onTouchEnd: () => {
                if (!touchStart.current || !touchEnd.current) return;
                const distance = touchStart.current - touchEnd.current;
                if (distance > threshold && onSwipeLeft) onSwipeLeft();
                if (distance < -threshold && onSwipeRight) onSwipeRight();
            }
        };
    };

    const useSmartTreeSwipe = (onSwipeLeft, onSwipeRight, threshold = 80) => {
        const touchStart = useRef(null);
        const touchEnd = useRef(null);
        const touchStartTarget = useRef(null);

        return {
            onTouchStart: (e) => {
                touchEnd.current = null;
                touchStart.current = e.targetTouches[0].clientX;
                touchStartTarget.current = e.target;
            },
            onTouchMove: (e) => {
                touchEnd.current = e.targetTouches[0].clientX;
            },
            onTouchEnd: (e) => {
                if (!touchStart.current || !touchEnd.current) return;
                
                const target = touchStartTarget.current;
                const isEmptySpace = target.classList.contains('tree-container') || 
                                   target.classList.contains('nodes-list') ||
                                   target.classList.contains('empty-state') ||
                                   (target.tagName === 'DIV' && !target.closest('.node-content'));
                
                if (!isEmptySpace) return;
                
                const distance = touchStart.current - touchEnd.current;
                const absDistance = Math.abs(distance);
                
                if (absDistance > threshold) {
                    if (distance > 0 && onSwipeLeft) {
                        e.preventDefault();
                        onSwipeLeft();
                    } else if (distance < 0 && onSwipeRight) {
                        e.preventDefault();
                        onSwipeRight();
                    }
                }
            }
        };
    };

    // ===============================
    // STATE MANAGEMENT
    // ===============================

    const initialAppState = {
        // Core state
        selectedNodeId: null,
        activeTreeId: 'main',
        
        // UI state
        currentInput: '',
        indentLevel: 0,
        currentFilter: 'all',
        
        // Modal states
        showAbout: false,
        showMarkdownView: false,
        showClearConfirm: false,
        focusedNode: null,
        
        // Dropdown states
        showThemeDropdown: false,
        showFilterDropdown: false,
        showMainMenu: false,
        showSyncMenu: false,
        
        // Edit state
        editingNodeId: null,
        editText: '',
        
        // Sync states
        showSyncExport: false,
        showSyncImport: false,
        syncExportData: null,
        syncImportData: '',
        syncImportError: null,
        
        // Visual feedback
        showSwipeHints: false,
        
        // Drag states
        draggedNodeId: null,
        dragOverNodeId: null,
        dragPosition: null,
        
        // Lospec states
        showLospecImport: false,
        lospecSlug: '',
        lospecLoading: false,
        lospecPreview: null
    };

    const appReducer = (state, action) => {
        switch (action.type) {
            case 'SET_MULTIPLE':
                return { ...state, ...action.payload };
            case 'RESET_DROPDOWNS':
                return {
                    ...state,
                    showThemeDropdown: false,
                    showFilterDropdown: false,
                    showMainMenu: false,
                    showSyncMenu: false,
                    showLospecImport: false,
                    editingNodeId: null,
                    editText: '',
                    showSwipeHints: false,
                    draggedNodeId: null,
                    dragOverNodeId: null,
                    dragPosition: null
                };
            default:
                return state;
        }
    };

    // ===============================
    // COMPONENTS
    // ===============================

    const Modal = ({ isOpen, onClose, title, children, theme }) => {
        if (!isOpen) return null;

        return (
            <div className="modal" onClick={onClose}>
                <div 
                    className="modal-content" 
                    style={{ backgroundColor: theme.background, color: theme.text }}
                    onClick={(e) => e.stopPropagation()}
                >
                    <div className="modal-header" style={{ borderColor: theme.border }}>
                        <h3 className="modal-title">{title}</h3>
                        <button className="modal-close" onClick={onClose} style={{ color: theme.text }}>
                            ╳
                        </button>
                    </div>
                    <div className="modal-body">
                        {children}
                    </div>
                </div>
            </div>
        );
    };

    const NodeComponent = ({ 
        node, theme, isSelected, isEditing, editText, onEditTextChange, 
        trees, currentTreeId, onTap, onIndent, onOutdent, onDelete, onFocus, 
        onToggleTask, onToggleComplete, onBranchOut, onEdit, onSaveEdit, 
        onCancelEdit, onJumpToBranch, isDragging, isDragOver, dragPosition, 
        onDragStart, onDragOver, onDragLeave, onDrop, onDragEnd, isFrozen 
    }) => {
        const editInputRef = useRef(null);
        const isBranchedOut = trees.some(tree => tree.parentNodeId === node.id);
        
        const swipeHandlers = useTouchHandler(
            () => !isFrozen && onOutdent(), 
            () => !isFrozen && onIndent()
        );

        const nodeSwipeHandlers = isFrozen ? {} : {
            ...swipeHandlers,
            onTouchStart: (e) => {
                e.stopPropagation();
                swipeHandlers.onTouchStart(e);
            },
            onTouchMove: (e) => {
                e.stopPropagation();
                swipeHandlers.onTouchMove(e);
            },
            onTouchEnd: (e) => {
                e.stopPropagation();
                swipeHandlers.onTouchEnd(e);
            }
        };

        useEffect(() => {
            if (isEditing && editInputRef.current) {
                editInputRef.current.focus();
                editInputRef.current.select();
            }
        }, [isEditing]);

        const handleKeyPress = (e) => {
            if (e.key === 'Enter') onSaveEdit();
            else if (e.key === 'Escape') onCancelEdit();
        };

        const getDragClasses = () => {
            let classes = 'node-content';
            if (isSelected) classes += ' selected';
            if (node.isTask && node.isCompleted) classes += ' completed';
            if (isFrozen) classes += ' frozen';
            else if (!isEditing && !isBranchedOut) classes += ' draggable';
            if (isDragging) classes += ' dragging';
            if (isDragOver && dragPosition === 'above') classes += ' drag-over-above';
            if (isDragOver && dragPosition === 'below') classes += ' drag-over-below';
            return classes;
        };

        const nodeColor = isSelected ? theme.border : getColorForLevel(theme, node.level);
        const textColor = isSelected ? getTextColorForBackground(theme.border) : getTextColorForBackground(getColorForLevel(theme, node.level));

        return (
            <div className="node">
                <div className="node-indent">
                    {Array.from({ length: node.level }, (_, i) => (
                        <div key={i} className="indent-space" />
                    ))}
                </div>
                
                <div className="node-content-wrapper">
                    <div 
                        className={getDragClasses()}
                        style={{
                            backgroundColor: nodeColor,
                            borderColor: isSelected ? theme.text : theme.border,
                            color: textColor
                        }}
                        onClick={(e) => !isFrozen && !isEditing && (e.stopPropagation(), onTap(e))}
                        {...nodeSwipeHandlers}
                        draggable={!isEditing && !isBranchedOut && !isFrozen}
                        onDragStart={!isFrozen ? (e) => onDragStart(e, node.id) : undefined}
                        onDragOver={!isFrozen ? (e) => onDragOver(e, node.id) : undefined}
                        onDragLeave={!isFrozen ? onDragLeave : undefined}
                        onDrop={!isFrozen ? (e) => onDrop(e, node.id) : undefined}
                        onDragEnd={!isFrozen ? onDragEnd : undefined}
                        title={isFrozen ? "This node is part of a branched tree and cannot be edited here" : undefined}
                    >
                        {isDragOver && !isFrozen && <div className="drag-indicator" />}
                        
                        {node.isTask && (
                            <div 
                                className="task-toggle" 
                                onClick={(e) => (e.stopPropagation(), !isFrozen && !isEditing && onToggleComplete())}
                                style={{ 
                                    color: node.isCompleted ? '#22c55e' : textColor + '99',
                                    cursor: isFrozen ? 'not-allowed' : 'pointer'
                                }}
                            >
                                {node.isCompleted ? '☑' : '☐'}
                            </div>
                        )}
                        
                        {isEditing && !isFrozen ? (
                            <input
                                ref={editInputRef}
                                className="node-edit-input"
                                type="text"
                                value={editText}
                                onChange={(e) => onEditTextChange(e.target.value)}
                                onKeyDown={handleKeyPress}
                                onBlur={onSaveEdit}
                                style={{ color: textColor }}
                                onClick={(e) => e.stopPropagation()}
                            />
                        ) : (
                            <div className={`node-text ${node.isTask && node.isCompleted ? 'completed' : ''}`}>
                                {node.content}
                                {isFrozen && (
                                    <span style={{ 
                                        fontSize: '0.75rem', 
                                        opacity: 0.6, 
                                        marginLeft: '0.5rem',
                                        fontStyle: 'italic'
                                    }}>
                                        (in branch)
                                    </span>
                                )}
                            </div>
                        )}
                        
                        {!isEditing && (
                            <div className="node-icons" style={{ color: textColor }}>
                                {node.isTask && <span>☐</span>}
                                {node.note && node.note.trim() && <span>📝</span>}
                                {isBranchedOut && (
                                    <span 
                                        className="branch-link"
                                        onClick={(e) => {
                                            e.stopPropagation();
                                            onJumpToBranch();
                                        }}
                                        title="Jump to branched tree"
                                        style={{ color: textColor }}
                                    >
                                        🌿
                                    </span>
                                )}
                            </div>
                        )}
                    </div>
                    
                    {isSelected && !isEditing && !isFrozen && (
                        <div className="node-actions">
                            {!isBranchedOut && (
                                <button className="action-btn edit" onClick={onEdit}>
                                    ✏️ <span>Edit</span>
                                </button>
                            )}
                            <button className="action-btn task" onClick={onToggleTask}>
                                ✅ <span>{node.isTask ? 'Normal' : 'Task'}</span>
                            </button>
                            <button className="action-btn focus" onClick={onFocus}>
                                📝 <span>Notes</span>
                            </button>
                            <button 
                                className="action-btn branch" 
                                onClick={onBranchOut} 
                                disabled={trees.length >= 5 || isBranchedOut}
                                style={{ 
                                    opacity: (trees.length >= 5 || isBranchedOut) ? 0.5 : 1,
                                    cursor: (trees.length >= 5 || isBranchedOut) ? 'not-allowed' : 'pointer'
                                }}
                                title={
                                    isBranchedOut ? 'Node already branched out' :
                                    trees.length >= 5 ? 'Maximum 5 trees allowed' : 
                                    'Branch out to explore this thought'
                                }
                            >
                                🌿 <span>Branch</span>
                            </button>
                            <button className="action-btn delete" onClick={onDelete}>
                                🗑️ <span>Delete</span>
                            </button>
                        </div>
                    )}
                    
                    {isEditing && !isFrozen && (
                        <div className="node-actions">
                            <button className="action-btn save" onClick={onSaveEdit}>
                                ✅ <span>Save</span>
                            </button>
                            <button className="action-btn cancel" onClick={onCancelEdit}>
                                ❌ <span>Cancel</span>
                            </button>
                        </div>
                    )}

                    {isFrozen && isSelected && (
                        <div style={{ 
                            marginTop: '8px',
                            padding: '6px 12px',
                            background: 'rgba(156, 163, 175, 0.1)',
                            borderRadius: '4px',
                            fontSize: '0.75rem',
                            color: 'rgba(156, 163, 175, 0.8)',
                            textAlign: 'center'
                        }}>
                            🔒 This node is part of a branched tree. Edit it in the branched tree instead.
                        </div>
                    )}
                </div>
            </div>
        );
    };

    // ===============================
    // MAIN APP COMPONENT
    // ===============================

    const TreeApp = () => {
        // Load initial data
        const { trees: initialTrees, customThemes: initialCustomThemes, currentTheme: initialTheme } = loadInitialData();
        
        // State
        const [trees, setTrees] = useState(initialTrees);
        const [customThemes, setCustomThemes] = useState(initialCustomThemes);
        const [currentTheme, setCurrentTheme] = useState(initialTheme);
        const [appState, dispatch] = useReducer(appReducer, initialAppState);
        
        const inputRef = useRef(null);
        const treeContainerRef = useRef(null);
        
        // Derived state
        const allThemes = useMemo(() => ({ ...THEMES, ...customThemes }), [customThemes]);
        const theme = allThemes[currentTheme] || THEMES.light;
        const activeTree = trees.find(tree => tree.id === appState.activeTreeId) || trees[0];
        const activeTreeIndex = trees.findIndex(tree => tree.id === appState.activeTreeId);
        const currentNodes = activeTree?.nodes || [];
        const filteredNodes = useMemo(() => {
            switch (appState.currentFilter) {
                case 'tasks': return currentNodes.filter(node => node.isTask);
                case 'notes': return currentNodes.filter(node => node.note && node.note.trim());
                case 'branched': return currentNodes.filter(node => trees.some(tree => tree.parentNodeId === node.id));
                default: return currentNodes;
            }
        }, [currentNodes, appState.currentFilter, trees]);
        
        const selectedNode = appState.selectedNodeId ? currentNodes.find(node => node.id === appState.selectedNodeId) : null;

        // Helper functions
        const updateState = useCallback((updates) => {
            dispatch({ type: 'SET_MULTIPLE', payload: updates });
        }, []);

        const resetDropdowns = useCallback(() => {
            dispatch({ type: 'RESET_DROPDOWNS' });
        }, []);

        const updateActiveTree = useCallback((updater) => {
            setTrees(prev => prev.map(tree => 
                tree.id === appState.activeTreeId 
                    ? { ...tree, nodes: typeof updater === 'function' ? updater(tree.nodes) : updater }
                    : tree
            ));
        }, [appState.activeTreeId]);

        const setActiveTree = useCallback((treeId) => {
            updateState({ 
                activeTreeId: treeId, 
                selectedNodeId: null, 
                indentLevel: 0 
            });

            // Scroll to top when switching trees
            setTimeout(() => {
                if (treeContainerRef.current) {
                    treeContainerRef.current.scrollTop = 0;
                }
            }, 50);
        }, [updateState]);

        const isNodeInBranchedSubtree = useCallback((nodeId, nodeIndex = null) => {
            if (!activeTree || activeTree.parentTreeId) return false;
            
            const nodes = activeTree.nodes;
            const targetIndex = nodeIndex !== null ? nodeIndex : nodes.findIndex(n => n.id === nodeId);
            
            if (targetIndex === -1) return false;
            
            if (trees.some(tree => tree.parentNodeId === nodeId)) return true;
            
            const targetNode = nodes[targetIndex];
            
            for (let i = targetIndex - 1; i >= 0; i--) {
                const potentialParent = nodes[i];
                
                if (potentialParent.level <= targetNode.level) {
                    if (potentialParent.level < targetNode.level && 
                        trees.some(tree => tree.parentNodeId === potentialParent.id)) {
                        return true;
                    }
                    if (potentialParent.level <= targetNode.level) break;
                }
                
                if (potentialParent.level < targetNode.level && 
                    trees.some(tree => tree.parentNodeId === potentialParent.id)) {
                    return true;
                }
            }
            
            return false;
        }, [activeTree, trees]);

        // Sync functionality
        const handleSyncExport = useCallback(() => {
            try {
                if (trees.length === 0 || trees.every(tree => tree.nodes.length === 0)) {
                    alert('No trees to export! Add some content first.');
                    return;
                }

                const exportData = syncUtils.export(trees, currentTheme, customThemes);
                updateState({ 
                    syncExportData: exportData,
                    showSyncExport: true,
                    showSyncMenu: false
                });
            } catch (error) {
                console.error('Sync export error:', error);
                alert('Failed to export trees: ' + error.message);
            }
        }, [trees, currentTheme, customThemes, updateState]);

        const processSyncImport = useCallback(() => {
            try {
                if (!appState.syncImportData.trim()) {
                    updateState({ syncImportError: 'Please paste the export data' });
                    return;
                }

                const importedData = syncUtils.import(appState.syncImportData);
                
                const mergedTrees = [...trees];
                
                for (const importedTree of importedData.trees) {
                    if (importedTree.id === 'main') {
                        const mainTreeIndex = mergedTrees.findIndex(t => t.id === 'main');
                        if (mainTreeIndex !== -1) {
                            mergedTrees[mainTreeIndex] = {
                                ...mergedTrees[mainTreeIndex],
                                nodes: [...mergedTrees[mainTreeIndex].nodes, ...importedTree.nodes]
                            };
                        }
                    } else {
                        mergedTrees.push(importedTree);
                    }
                }
                
                setTrees(mergedTrees);
                
                let successMessage = `Successfully imported ${importedData.trees.length} trees!`;
                
                if (importedData.theme) {
                    const { currentTheme: importedTheme, customTheme, isCustomTheme } = importedData.theme;
                    
                    if (isCustomTheme && customTheme) {
                        let themeKey = importedTheme;
                        let counter = 1;
                        
                        while (allThemes[themeKey]) {
                            themeKey = `${importedTheme}_imported_${counter}`;
                            counter++;
                        }
                        
                        const newCustomThemes = { ...customThemes, [themeKey]: customTheme };
                        setCustomThemes(newCustomThemes);
                        setCurrentTheme(themeKey);
                        successMessage += ` Theme "${customTheme.name}" imported and applied!`;
                        
                    } else if (THEMES[importedTheme]) {
                        setCurrentTheme(importedTheme);
                        successMessage += ` Theme "${THEMES[importedTheme].name}" applied!`;
                    }
                }
                
                updateState({ 
                    showSyncImport: false,
                    syncImportError: null,
                    syncImportData: ''
                });
                
                alert(successMessage);
            } catch (error) {
                updateState({ syncImportError: error.message });
            }
        }, [appState.syncImportData, trees, customThemes, allThemes, updateState]);

        const copyToClipboard = useCallback(async (text) => {
            try {
                await navigator.clipboard.writeText(text);
                alert('Copied to clipboard! Now paste this on your other device.');
            } catch (error) {
                const textArea = document.createElement('textarea');
                textArea.value = text;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                alert('Copied to clipboard! Now paste this on your other device.');
            }
        }, []);

        const shareData = useCallback(async (text) => {
            if (navigator.share) {
                try {
                    await navigator.share({ title: 'Tree-e Export', text });
                } catch (error) {
                    if (error.name !== 'AbortError') {
                        copyToClipboard(text);
                    }
                }
            } else {
                copyToClipboard(text);
            }
        }, [copyToClipboard]);

        // Node operations
        const addNode = useCallback(() => {
            const content = appState.currentInput.trim();
            if (!content || !activeTree) return;

            const nodes = activeTree.nodes;
            let insertIndex = nodes.length;
            let newLevel = appState.indentLevel;

            if (appState.selectedNodeId) {
                const selectedNode = nodes.find(node => node.id === appState.selectedNodeId);
                const selectedIndex = nodes.findIndex(node => node.id === appState.selectedNodeId);
                
                if (selectedNode && selectedIndex !== -1) {
                    newLevel = selectedNode.level + 1;
                    
                    let insertAfterIndex = selectedIndex;
                    for (let i = selectedIndex + 1; i < nodes.length; i++) {
                        if (nodes[i].level > selectedNode.level) {
                            insertAfterIndex = i;
                        } else {
                            break;
                        }
                    }
                    insertIndex = insertAfterIndex + 1;
                }
            }

            const newNode = {
                id: generateId(),
                content,
                level: newLevel,
                note: '',
                isTask: false,
                isCompleted: false
            };

            updateActiveTree(prevNodes => {
                const newNodes = [...prevNodes];
                newNodes.splice(insertIndex, 0, newNode);
                return newNodes;
            });
            
            updateState({ currentInput: '', indentLevel: newLevel });

            // Scroll to the new node after it's added
            setTimeout(() => {
                if (treeContainerRef.current) {
                    // If we're adding at the end, scroll to bottom
                    if (insertIndex >= nodes.length) {
                        treeContainerRef.current.scrollTop = treeContainerRef.current.scrollHeight;
                    } else {
                        // Otherwise, find the new node and scroll to it
                        const nodeElements = treeContainerRef.current.querySelectorAll('.node');
                        if (nodeElements[insertIndex]) {
                            nodeElements[insertIndex].scrollIntoView({ 
                                behavior: 'smooth', 
                                block: 'center' 
                            });
                        }
                    }
                }
            }, 50); // Small delay to ensure DOM is updated
        }, [appState.currentInput, appState.indentLevel, appState.selectedNodeId, activeTree, updateActiveTree, updateState]);

        const selectNode = useCallback((nodeId) => {
            if (appState.selectedNodeId === nodeId) {
                updateState({ 
                    selectedNodeId: null,
                    indentLevel: activeTree?.nodes.length > 0 ? activeTree.nodes[activeTree.nodes.length - 1].level : 0
                });
            } else {
                const node = activeTree?.nodes.find(n => n.id === nodeId);
                updateState({ 
                    selectedNodeId: nodeId,
                    indentLevel: node ? node.level + 1 : 0
                });

                // Scroll selected node into view
                setTimeout(() => {
                    if (treeContainerRef.current) {
                        const nodeElements = treeContainerRef.current.querySelectorAll('.node');
                        const nodeIndex = activeTree?.nodes.findIndex(n => n.id === nodeId);
                        if (nodeIndex !== -1 && nodeElements[nodeIndex]) {
                            nodeElements[nodeIndex].scrollIntoView({ 
                                behavior: 'smooth', 
                                block: 'center' 
                            });
                        }
                    }
                }, 50);
            }
        }, [appState.selectedNodeId, activeTree, updateState]);

        // Additional node operations
        const nodeOperations = useMemo(() => ({
            delete: (nodeId) => {
                if (isNodeInBranchedSubtree(nodeId)) return;
                updateActiveTree(prevNodes => prevNodes.filter(node => node.id !== nodeId));
                if (appState.selectedNodeId === nodeId) {
                    updateState({ selectedNodeId: null });
                }
            },
            
            indent: (nodeId) => {
                if (isNodeInBranchedSubtree(nodeId)) return;
                updateActiveTree(prevNodes => prevNodes.map(node =>
                    node.id === nodeId ? { ...node, level: node.level + 1 } : node
                ));
                updateState({ selectedNodeId: null });
            },
            
            outdent: (nodeId) => {
                if (isNodeInBranchedSubtree(nodeId)) return;
                updateActiveTree(prevNodes => prevNodes.map(node =>
                    node.id === nodeId ? { ...node, level: Math.max(0, node.level - 1) } : node
                ));
                updateState({ selectedNodeId: null });
            },
            
            toggleTask: (nodeId) => {
                if (isNodeInBranchedSubtree(nodeId)) return;
                updateActiveTree(prevNodes => prevNodes.map(node =>
                    node.id === nodeId ? { ...node, isTask: !node.isTask, isCompleted: false } : node
                ));
                updateState({ selectedNodeId: null });
            },
            
            toggleComplete: (nodeId) => {
                if (isNodeInBranchedSubtree(nodeId)) return;
                updateActiveTree(prevNodes => prevNodes.map(node =>
                    node.id === nodeId ? { ...node, isCompleted: !node.isCompleted } : node
                ));
            },
            
            edit: (nodeId) => {
                if (isNodeInBranchedSubtree(nodeId)) return;
                const isBranchedOut = trees.some(tree => tree.parentNodeId === nodeId);
                if (isBranchedOut) return;
                
                const node = activeTree?.nodes.find(n => n.id === nodeId);
                if (node) {
                    updateState({ editingNodeId: nodeId, editText: node.content, selectedNodeId: null });
                }
            },
            
            saveEdit: () => {
                const trimmedText = appState.editText.trim();
                if (trimmedText && appState.editingNodeId) {
                    updateActiveTree(prevNodes => prevNodes.map(node =>
                        node.id === appState.editingNodeId ? { ...node, content: trimmedText } : node
                    ));
                }
                updateState({ editingNodeId: null, editText: '' });
            },
            
            cancelEdit: () => {
                updateState({ editingNodeId: null, editText: '' });
            },
            
            focus: (nodeId) => {
                if (isNodeInBranchedSubtree(nodeId)) return;
                const node = activeTree?.nodes.find(n => n.id === nodeId);
                if (node) {
                    updateState({ focusedNode: node, selectedNodeId: null });
                }
            },
            
            saveFocus: (note) => {
                if (appState.focusedNode) {
                    updateActiveTree(prevNodes => prevNodes.map(node =>
                        node.id === appState.focusedNode.id ? { ...node, note } : node
                    ));
                }
                updateState({ focusedNode: null });
            }
        }), [isNodeInBranchedSubtree, updateActiveTree, appState, updateState, activeTree, trees]);

        // Drag and drop operations
        const dragOperations = useMemo(() => ({
            start: (e, nodeId) => {
                if (isNodeInBranchedSubtree(nodeId)) {
                    e.preventDefault();
                    return;
                }
                updateState({ draggedNodeId: nodeId });
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/html', nodeId);
            },
            
            over: (e, nodeId) => {
                if (isNodeInBranchedSubtree(nodeId)) {
                    e.dataTransfer.dropEffect = 'none';
                    return;
                }
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
                
                const rect = e.currentTarget.getBoundingClientRect();
                const y = e.clientY;
                const middle = rect.top + rect.height / 2;
                const position = y < middle ? 'above' : 'below';
                
                updateState({ 
                    dragOverNodeId: nodeId,
                    dragPosition: position
                });
            },
            
            leave: (e) => {
                if (!e.currentTarget.contains(e.relatedTarget)) {
                    updateState({ 
                        dragOverNodeId: null,
                        dragPosition: null
                    });
                }
            },
            
            drop: (e, targetNodeId) => {
                e.preventDefault();
                
                const draggedNodeId = appState.draggedNodeId;
                const position = appState.dragPosition;
                
                if (isNodeInBranchedSubtree(draggedNodeId) || isNodeInBranchedSubtree(targetNodeId)) {
                    updateState({ 
                        draggedNodeId: null, 
                        dragOverNodeId: null,
                        dragPosition: null
                    });
                    return;
                }
                
                if (!draggedNodeId || draggedNodeId === targetNodeId) {
                    updateState({ 
                        draggedNodeId: null, 
                        dragOverNodeId: null,
                        dragPosition: null
                    });
                    return;
                }

                updateActiveTree(prevNodes => {
                    const nodes = [...prevNodes];
                    const draggedIndex = nodes.findIndex(node => node.id === draggedNodeId);
                    const targetIndex = nodes.findIndex(node => node.id === targetNodeId);
                    
                    if (draggedIndex === -1 || targetIndex === -1) return nodes;
                    
                    const [draggedNode] = nodes.splice(draggedIndex, 1);
                    
                    let newIndex = targetIndex;
                    if (draggedIndex < targetIndex) {
                        newIndex = targetIndex - 1;
                    }
                    
                    if (position === 'above') {
                        nodes.splice(newIndex, 0, draggedNode);
                    } else {
                        nodes.splice(newIndex + 1, 0, draggedNode);
                    }
                    
                    return nodes;
                });

                updateState({ 
                    draggedNodeId: null, 
                    dragOverNodeId: null,
                    dragPosition: null
                });
            },
            
            end: () => {
                updateState({ 
                    draggedNodeId: null, 
                    dragOverNodeId: null,
                    dragPosition: null
                });
            }
        }), [isNodeInBranchedSubtree, updateState, appState, updateActiveTree]);

        // Tree operations
        const treeOperations = useMemo(() => ({
            branch: (nodeId) => {
                if (isNodeInBranchedSubtree(nodeId) || !activeTree || trees.length >= 5) return;

                const selectedNode = activeTree.nodes.find(node => node.id === nodeId);
                if (!selectedNode) return;

                const nodeAndChildren = [];
                let foundParent = false;
                
                for (const node of activeTree.nodes) {
                    if (node.id === selectedNode.id) {
                        foundParent = true;
                        nodeAndChildren.push({ ...node, level: 0 });
                    } else if (foundParent && node.level > selectedNode.level) {
                        nodeAndChildren.push({ ...node, level: node.level - selectedNode.level });
                    } else if (foundParent && node.level <= selectedNode.level) {
                        break;
                    }
                }

                const truncatedTitle = selectedNode.content.length > 20 
                    ? selectedNode.content.substring(0, 17) + '...'
                    : selectedNode.content;

                const newBreadcrumb = [];
                if (activeTree.id !== 'main') {
                    newBreadcrumb.push(...activeTree.breadcrumb, activeTree.title);
                }
                
                if (newBreadcrumb.length > 3) {
                    newBreadcrumb.splice(1, newBreadcrumb.length - 3);
                    newBreadcrumb[1] = '...';
                }

                const newTree = {
                    id: generateId(),
                    title: truncatedTitle,
                    nodes: nodeAndChildren,
                    parentTreeId: activeTree.id,
                    parentNodeId: selectedNode.id,
                    breadcrumb: newBreadcrumb
                };

                setTrees(prev => [...prev, newTree]);
                setActiveTree(newTree.id);
            },
            
            close: () => {
                if (!activeTree || !activeTree.parentTreeId) return;

                setTrees(prev => {
                    const newTrees = [...prev];
                    const parentIndex = newTrees.findIndex(tree => tree.id === activeTree.parentTreeId);
                    const parentNodes = [...newTrees[parentIndex].nodes];
                    
                    const originalNodeIndex = parentNodes.findIndex(node => node.id === activeTree.parentNodeId);
                    if (originalNodeIndex === -1) return newTrees;

                    const originalNode = parentNodes[originalNodeIndex];
                    
                    let removeUntilIndex = parentNodes.length;
                    for (let i = originalNodeIndex + 1; i < parentNodes.length; i++) {
                        if (parentNodes[i].level <= originalNode.level) {
                            removeUntilIndex = i;
                            break;
                        }
                    }
                    
                    const updatedNodes = activeTree.nodes.map(node => ({
                        ...node,
                        level: node.level + originalNode.level
                    }));

                    parentNodes.splice(originalNodeIndex, removeUntilIndex - originalNodeIndex, ...updatedNodes);
                    newTrees[parentIndex] = { ...newTrees[parentIndex], nodes: parentNodes };

                    const activeTreeIndex = newTrees.findIndex(tree => tree.id === appState.activeTreeId);
                    newTrees.splice(activeTreeIndex, 1);

                    return newTrees;
                });

                setActiveTree(activeTree.parentTreeId);
            },
            
            jump: (nodeId) => {
                const branchedTree = trees.find(tree => tree.parentNodeId === nodeId);
                if (branchedTree) {
                    setActiveTree(branchedTree.id);
                }
            }
        }), [isNodeInBranchedSubtree, activeTree, trees, appState.activeTreeId, setActiveTree]);

        // Touch handlers
        const inputSwipeHandlers = useTouchHandler(
            () => updateState({ indentLevel: Math.max(0, appState.indentLevel - 1) }),
            () => updateState({ indentLevel: appState.indentLevel + 1 })
        );

        const safeInputSwipeHandlers = {
            ...inputSwipeHandlers,
            onTouchStart: (e) => {
                e.stopPropagation();
                inputSwipeHandlers.onTouchStart(e);
            },
            onTouchMove: (e) => {
                e.stopPropagation();
                inputSwipeHandlers.onTouchMove(e);
            },
            onTouchEnd: (e) => {
                e.stopPropagation();
                inputSwipeHandlers.onTouchEnd(e);
            }
        };

        const smartTreeSwipeHandlers = useSmartTreeSwipe(
            () => {
                if (trees.length > 1) {
                    const nextIndex = activeTreeIndex < trees.length - 1 ? activeTreeIndex + 1 : 0;
                    setActiveTree(trees[nextIndex].id);
                    updateState({ showSwipeHints: false });
                }
            },
            () => {
                if (trees.length > 1) {
                    const prevIndex = activeTreeIndex > 0 ? activeTreeIndex - 1 : trees.length - 1;
                    setActiveTree(trees[prevIndex].id);
                    updateState({ showSwipeHints: false });
                }
            }
        );

        const enhancedSmartTreeSwipeHandlers = {
            ...smartTreeSwipeHandlers,
            onTouchStart: (e) => {
                const target = e.target;
                const isEmptySpace = target.classList.contains('tree-container') || 
                                   target.classList.contains('nodes-list') ||
                                   target.classList.contains('empty-state') ||
                                   (target.tagName === 'DIV' && !target.closest('.node-content'));
                
                if (trees.length > 1 && isEmptySpace) {
                    updateState({ showSwipeHints: true });
                }
                smartTreeSwipeHandlers.onTouchStart(e);
            },
            onTouchEnd: (e) => {
                updateState({ showSwipeHints: false });
                smartTreeSwipeHandlers.onTouchEnd(e);
            }
        };

        // Utility functions for export/import
        const generateMarkdown = useCallback(() => {
            return trees.map((tree) => {
                const nodesToUse = appState.currentFilter !== 'all' ? 
                    (appState.currentFilter === 'tasks' ? tree.nodes.filter(node => node.isTask) :
                     appState.currentFilter === 'notes' ? tree.nodes.filter(node => node.note && node.note.trim()) :
                     appState.currentFilter === 'branched' ? tree.nodes.filter(node => trees.some(otherTree => otherTree.parentNodeId === node.id)) :
                     tree.nodes) : tree.nodes;
                
                let treeMarkdown = tree.id === 'main' ? `# ${tree.title}` : `## ${tree.title}`;
                if (tree.breadcrumb.length > 0) {
                    treeMarkdown += ` (Branch from: ${tree.breadcrumb.join(' > ')})`;
                }
                treeMarkdown += '\n\n';
                
                const nodeMarkdown = nodesToUse.map(node => {
                    const indent = '  '.repeat(node.level);
                    let content;
                    
                    if (node.isTask) {
                        const taskSymbol = node.isCompleted ? '- [x]' : '- [ ]';
                        content = `${indent}${taskSymbol} ${node.content}`;
                    } else {
                        content = `${indent}- ${node.content}`;
                    }
                    
                    const isBranchedOut = trees.some(otherTree => otherTree.parentNodeId === node.id);
                    if (isBranchedOut) {
                        const branchedTree = trees.find(otherTree => otherTree.parentNodeId === node.id);
                        if (branchedTree) {
                            content += ` → branched to: ${branchedTree.title}`;
                        }
                    }
                    
                    if (node.note && node.note.trim()) {
                        const noteLines = node.note.split('\n');
                        const indentedNote = noteLines.map(line => `${indent}  > ${line}`).join('\n');
                        content += '\n' + indentedNote;
                    }
                    
                    return content;
                }).join('\n');
                
                return treeMarkdown + (nodeMarkdown || '*Empty tree*');
            }).join('\n\n---\n\n');
        }, [trees, appState.currentFilter]);

        const exportMarkdown = useCallback(() => {
            const markdown = generateMarkdown();
            const blob = new Blob([markdown], { type: 'text/markdown' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            const filterSuffix = appState.currentFilter !== 'all' ? `-${appState.currentFilter}` : '';
            a.download = `tree-e-export${filterSuffix}.md`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }, [generateMarkdown, appState.currentFilter]);

        const clearAll = useCallback(() => {
            setTrees([{
                id: 'main',
                title: 'Main Tree',
                nodes: [],
                parentTreeId: null,
                parentNodeId: null,
                breadcrumb: []
            }]);
            setActiveTree('main');
            updateState({ showClearConfirm: false });
        }, [setActiveTree, updateState]);

        // Event handlers
        const handleBackgroundClick = useCallback((e) => {
            if (e.target.classList.contains('app') || 
                e.target.classList.contains('main-content') || 
                e.target.classList.contains('tree-container') ||
                e.target.classList.contains('nodes-list')) {
                
                resetDropdowns();
                updateState({ selectedNodeId: null });
                
                if (activeTree?.nodes.length > 0) {
                    updateState({ indentLevel: activeTree.nodes[activeTree.nodes.length - 1].level });
                } else {
                    updateState({ indentLevel: 0 });
                }
            }
        }, [resetDropdowns, updateState, activeTree]);

        // Effects
        useEffect(() => {
            if (trees.length > 0) {
                storage.save(STORAGE_KEYS.trees, trees);
            }
        }, [trees]);

        useEffect(() => {
            storage.save(STORAGE_KEYS.theme, currentTheme);
        }, [currentTheme]);

        useEffect(() => {
            storage.save(STORAGE_KEYS.customThemes, customThemes);
        }, [customThemes]);

        useEffect(() => {
            setTimeout(() => {
                if (inputRef.current) {
                    inputRef.current.focus();
                }
            }, 100);
        }, []);

        // Custom theme management
        const removeCustomTheme = useCallback((themeKey) => {
            if (THEMES[themeKey]) return;
            
            const newCustomThemes = { ...customThemes };
            delete newCustomThemes[themeKey];
            setCustomThemes(newCustomThemes);
            
            if (currentTheme === themeKey) {
                setCurrentTheme('light');
            }
        }, [customThemes, currentTheme]);

        // Lospec integration
        const fetchLospecPalette = useCallback(async (slug) => {
            if (!slug.trim()) return null;
            
            updateState({ lospecLoading: true });
            
            try {
                const response = await fetch(`https://lospec.com/palette-list/${slug.trim()}.json`);
                
                if (!response.ok) {
                    throw new Error('Palette not found');
                }
                
                const data = await response.json();
                updateState({ lospecLoading: false });
                
                return data;
            } catch (error) {
                updateState({ lospecLoading: false });
                alert(`Error fetching palette: ${error.message}`);
                return null;
            }
        }, [updateState]);

        const convertLospecToTheme = useCallback((lospecData) => {
            const colors = lospecData.colors.map(c => `#${c}`);
            const name = lospecData.name;
            
            const getBrightness = (hex) => {
                const r = parseInt(hex.slice(1, 3), 16);
                const g = parseInt(hex.slice(3, 5), 16);
                const b = parseInt(hex.slice(5, 7), 16);
                return (r * 299 + g * 587 + b * 114) / 1000;
            };
            
            const sortedColors = [...colors].sort((a, b) => getBrightness(a) - getBrightness(b));
            const darkest = sortedColors[0];
            const lightest = sortedColors[sortedColors.length - 1];
            const darkestBrightness = getBrightness(darkest);
            const lightestBrightness = getBrightness(lightest);
            
            const isDarkTheme = lightestBrightness - darkestBrightness > 100 && darkestBrightness < 80;
            
            let background, text, border;
            
            if (isDarkTheme) {
                background = darkest;
                text = lightest;
                border = sortedColors[Math.floor(sortedColors.length * 0.3)];
            } else {
                background = lightest;
                text = darkest;
                border = sortedColors[Math.floor(sortedColors.length * 0.7)];
            }
            
            const midIndex = Math.floor(sortedColors.length / 2);
            const prompt = sortedColors[midIndex];
            
            const levelColors = [];
            const step = Math.max(1, Math.floor(colors.length / 5));
            
            for (let i = 0; i < 5; i++) {
                const index = (i * step) % colors.length;
                levelColors.push(colors[index]);
            }
            
            while (levelColors.length < 5) {
                levelColors.push(colors[levelColors.length % colors.length]);
            }
            
            return {
                name: `${name} (Lospec)`,
                background,
                text,
                prompt,
                border,
                levelColors: levelColors.slice(0, 5)
            };
        }, []);

        const previewLospecPalette = useCallback(async () => {
            const data = await fetchLospecPalette(appState.lospecSlug);
            if (data) {
                const theme = convertLospecToTheme(data);
                updateState({ lospecPreview: theme });
            }
        }, [fetchLospecPalette, appState.lospecSlug, convertLospecToTheme, updateState]);

        const importLospecTheme = useCallback(() => {
            if (appState.lospecPreview) {
                const baseKey = appState.lospecSlug.toLowerCase().replace(/[^a-z0-9]/g, '');
                let themeKey = baseKey;
                let counter = 1;
                
                while (allThemes[themeKey]) {
                    themeKey = `${baseKey}${counter}`;
                    counter++;
                }
                
                const newCustomThemes = {
                    ...customThemes,
                    [themeKey]: appState.lospecPreview
                };
                
                setCustomThemes(newCustomThemes);
                setCurrentTheme(themeKey);
                updateState({ 
                    showLospecImport: false, 
                    lospecSlug: '', 
                    lospecPreview: null 
                });
            }
        }, [appState.lospecPreview, appState.lospecSlug, allThemes, customThemes, updateState]);

        // Render
        return (
            <div 
                className="app" 
                style={{ 
                    backgroundColor: theme.background,
                    color: theme.text 
                }}
                onClick={handleBackgroundClick}
            >
                {/* Header */}
                <div className="header" style={{ backgroundColor: theme.background, borderColor: theme.border }} {...(trees.length > 1 ? enhancedSmartTreeSwipeHandlers : {})}>
                    <div className="header-main">
                        <div className="header-left">
                            <div className="header-title">
                                {trees.length > 1 && (
                                    <div className="tree-dots" title="Swipe to navigate between trees">
                                        {trees.map((_, index) => (
                                            <div
                                                key={index}
                                                className={`tree-dot ${index === activeTreeIndex ? 'active' : ''}`}
                                                style={{
                                                    backgroundColor: index === activeTreeIndex ? theme.text : theme.text + '40'
                                                }}
                                            />
                                        ))}
                                    </div>
                                )}
                            </div>
                            
                            {appState.currentFilter !== 'all' && (
                                <span className="badge" style={{ 
                                    color: theme.text + '99',
                                    background: theme.border
                                }}>
                                    {FILTER_OPTIONS.find(f => f.key === appState.currentFilter)?.icon}
                                    {FILTER_OPTIONS.find(f => f.key === appState.currentFilter)?.label}
                                </span>
                            )}
                        </div>
                        
                        <div className="header-controls">
                            {/* Sync Button */}
                            <div className="dropdown">
                                <button 
                                    className="control-btn"
                                    onClick={(e) => {
                                        e.stopPropagation();
                                        updateState({ 
                                            showSyncMenu: !appState.showSyncMenu, 
                                            showMainMenu: false, 
                                            showThemeDropdown: false 
                                        });
                                    }}
                                    style={{
                                        backgroundColor: getColorForLevel(theme, 0),
                                        borderColor: theme.border,
                                        color: theme.text
                                    }}
                                    title="Sync between devices"
                                >
                                    ⟲
                                </button>
                                {appState.showSyncMenu && (
                                    <div 
                                        className="dropdown-content"
                                        style={{
                                            backgroundColor: theme.background,
                                            borderColor: theme.border,
                                            color: theme.text
                                        }}
                                    >
                                        <button
                                            className="dropdown-item"
                                            onClick={handleSyncExport}
                                            disabled={trees.length === 0 || trees.every(tree => tree.nodes.length === 0)}
                                            style={{ color: (trees.length === 0 || trees.every(tree => tree.nodes.length === 0)) ? theme.text + '50' : theme.text }}
                                        >
                                            <span>📤 Export Data</span>
                                        </button>
                                        <button
                                            className="dropdown-item"
                                            onClick={() => updateState({ showSyncImport: true, showSyncMenu: false })}
                                            style={{ color: theme.text }}
                                        >
                                            <span>📥 Import Data</span>
                                        </button>
                                    </div>
                                )}
                            </div>

                            {/* Main Menu */}
                            <div className="dropdown">
                                <button 
                                    className="menu-btn"
                                    onClick={(e) => {
                                        e.stopPropagation();
                                        updateState({ 
                                            showMainMenu: !appState.showMainMenu, 
                                            showThemeDropdown: false, 
                                            showFilterDropdown: false,
                                            showSyncMenu: false
                                        });
                                    }}
                                    style={{
                                        backgroundColor: getColorForLevel(theme, 0),
                                        borderColor: theme.border,
                                        color: theme.text
                                    }}
                                >
                                    ≡
                                </button>
                                {appState.showMainMenu && (
                                    <div 
                                        className="dropdown-content"
                                        style={{
                                            backgroundColor: theme.background,
                                            borderColor: theme.border,
                                            color: theme.text
                                        }}
                                    >
                                        <button
                                            className="dropdown-item"
                                            onClick={() => {
                                                updateState({ currentFilter: appState.currentFilter === 'all' ? 'tasks' : 'all', showMainMenu: false });
                                            }}
                                            style={{ color: theme.text }}
                                        >
                                            <span>Filter</span>
                                            <span>{appState.currentFilter !== 'all' ? '●' : ''}</span>
                                        </button>
                                        <button
                                            className="dropdown-item"
                                            onClick={() => {
                                                updateState({ showMainMenu: false, showMarkdownView: !appState.showMarkdownView });
                                            }}
                                            disabled={trees.length === 0 || trees.every(tree => tree.nodes.length === 0)}
                                            style={{ color: (trees.length === 0 || trees.every(tree => tree.nodes.length === 0)) ? theme.text + '50' : theme.text }}
                                        >
                                            <span>{appState.showMarkdownView ? 'Back' : 'Export'}</span>
                                        </button>
                                        <button
                                            className="dropdown-item"
                                            onClick={() => {
                                                updateState({ showThemeDropdown: !appState.showThemeDropdown, showMainMenu: false });
                                            }}
                                            style={{ color: theme.text }}
                                        >
                                            <span>Themes</span>
                                        </button>
                                        <button
                                            className="dropdown-item"
                                            onClick={() => {
                                                updateState({ showAbout: true, showMainMenu: false });
                                            }}
                                            style={{ color: theme.text }}
                                        >
                                            <span>About</span>
                                        </button>
                                        <button
                                            className="dropdown-item"
                                            onClick={() => {
                                                if (trees.length > 0 && trees.some(tree => tree.nodes.length > 0)) {
                                                    updateState({ showClearConfirm: true, showMainMenu: false });
                                                }
                                            }}
                                            disabled={trees.length === 0 || trees.every(tree => tree.nodes.length === 0)}
                                            style={{ color: trees.length === 0 || trees.every(tree => tree.nodes.length === 0) ? theme.text + '50' : '#ef4444' }}
                                        >
                                            <span>Clear All</span>
                                        </button>
                                    </div>
                                )}
                            </div>
                            
                            {/* Theme Dropdown */}
                            {appState.showThemeDropdown && (
                                <div style={{ position: 'absolute', top: '100%', right: 0, zIndex: 200 }}>
                                    <div 
                                        className="dropdown-content"
                                        style={{
                                            backgroundColor: theme.background,
                                            borderColor: theme.border,
                                            color: theme.text
                                        }}
                                    >
                                        {/* Built-in themes */}
                                        {Object.entries(THEMES).map(([key, themeOption]) => (
                                            <button
                                                key={key}
                                                className="dropdown-item"
                                                onClick={() => {
                                                    setCurrentTheme(key);
                                                    updateState({ showThemeDropdown: false });
                                                }}
                                                style={{ color: theme.text }}
                                            >
                                                <span>{themeOption.name}</span>
                                                {currentTheme === key && <span>●</span>}
                                            </button>
                                        ))}
                                        
                                        {/* Custom themes */}
                                        {Object.keys(customThemes).length > 0 && (
                                            <>
                                                <div style={{ borderTop: `1px solid ${theme.border}`, margin: '4px 0' }} />
                                                {Object.entries(customThemes).map(([key, themeOption]) => (
                                                    <div key={key} style={{ display: 'flex', alignItems: 'center' }}>
                                                        <button
                                                            className="dropdown-item"
                                                            onClick={() => {
                                                                setCurrentTheme(key);
                                                                updateState({ showThemeDropdown: false });
                                                            }}
                                                            style={{ 
                                                                color: theme.text, 
                                                                flex: 1,
                                                                borderRadius: '0'
                                                            }}
                                                        >
                                                            <span>{themeOption.name}</span>
                                                            {currentTheme === key && <span>●</span>}
                                                        </button>
                                                        <button
                                                            onClick={(e) => {
                                                                e.stopPropagation();
                                                                removeCustomTheme(key);
                                                            }}
                                                            style={{
                                                                background: 'none',
                                                                border: 'none',
                                                                color: '#ef4444',
                                                                cursor: 'pointer',
                                                                padding: '8px',
                                                                fontSize: '0.75rem'
                                                            }}
                                                            title="Delete custom theme"
                                                        >
                                                            ╳
                                                        </button>
                                                    </div>
                                                ))}
                                            </>
                                        )}
                                        
                                        <div style={{ borderTop: `1px solid ${theme.border}`, margin: '4px 0' }} />
                                        <button
                                            className="dropdown-item"
                                            onClick={() => {
                                                updateState({ showLospecImport: true, showThemeDropdown: false });
                                            }}
                                            style={{ color: theme.prompt, fontStyle: 'italic' }}
                                        >
                                            <span>Import from Lospec...</span>
                                        </button>
                                    </div>
                                </div>
                            )}
                        </div>
                    </div>
                    
                    {/* Breadcrumbs */}
                    {activeTree?.id !== 'main' && (
                        <div className="breadcrumbs" style={{ color: theme.text }}>
                            <button
                                className="breadcrumb-btn"
                                onClick={() => setActiveTree('main')}
                                style={{ color: theme.text + '99' }}
                            >
                                Main Tree
                            </button>
                            
                            {activeTree?.breadcrumb?.map((crumb, index) => (
                                <React.Fragment key={index}>
                                    <span className="breadcrumb-sep"> > </span>
                                    <span style={{ color: theme.text + '99' }}>{crumb}</span>
                                </React.Fragment>
                            ))}
                            
                            <span className="breadcrumb-sep"> > </span>
                            <span className="breadcrumb-current" style={{ color: theme.text }}>
                                {activeTree?.title}
                            </span>
                            
                            <button
                                className="close-btn"
                                onClick={treeOperations.close}
                                title="Close tree and merge changes back"
                            >
                                ✓ Close
                            </button>
                        </div>
                    )}
                </div>

                {/* Main Content */}
                {appState.showMarkdownView ? (
                    <div className="markdown-view">
                        <div className="markdown-header" style={{ borderColor: theme.border }}>
                            <button
                                className="download-btn"
                                onClick={exportMarkdown}
                                style={{
                                    background: theme.text,
                                    color: theme.background
                                }}
                            >
                                ↓ Download MD
                            </button>
                        </div>
                        <div className="markdown-content" style={{ color: theme.text }}>
                            {generateMarkdown() || 'No content to display'}
                        </div>
                    </div>
                ) : (
                    <div className="main-content">
                        <div 
                            ref={treeContainerRef}
                            className={`tree-container ${trees.length > 1 ? 'multi-tree' : ''}`} 
                            {...(trees.length > 1 ? enhancedSmartTreeSwipeHandlers : {})}
                        >
                            {/* Swipe hints */}
                            {trees.length > 1 && (
                                <>
                                    <div className={`swipe-hints swipe-hint-left ${appState.showSwipeHints ? 'visible' : ''}`} style={{ background: `linear-gradient(to right, ${theme.border}, transparent)` }} />
                                    <div className={`swipe-hints swipe-hint-right ${appState.showSwipeHints ? 'visible' : ''}`} style={{ background: `linear-gradient(to left, ${theme.border}, transparent)` }} />
                                </>
                            )}
                            
                            <div className="nodes-list">
                                {filteredNodes.length === 0 && currentNodes.length > 0 && appState.currentFilter !== 'all' ? (
                                    <div className="empty-state" {...enhancedSmartTreeSwipeHandlers}>
                                        <div className="empty-icon">{FILTER_OPTIONS.find(f => f.key === appState.currentFilter)?.icon}</div>
                                        <div className="empty-title">No {FILTER_OPTIONS.find(f => f.key === appState.currentFilter)?.label.toLowerCase()} found</div>
                                        <div className="empty-desc">
                                            Try a different filter or add some {appState.currentFilter === 'tasks' ? 'task nodes' : appState.currentFilter === 'notes' ? 'notes to your nodes' : 'branched nodes'}.
                                            {trees.length > 1 && <><br /><br />💡 Swipe here to navigate between trees</>}
                                        </div>
                                    </div>
                                ) : filteredNodes.length === 0 ? (
                                    <div className="empty-state" {...enhancedSmartTreeSwipeHandlers}>
                                        <div className="empty-icon">🌱</div>
                                        <div className="empty-title">Empty tree</div>
                                        <div className="empty-desc">
                                            {activeTree?.id === 'main' ? 'Start your Tree-e by adding your first thought below.' : 'This branch is ready for new ideas.'}
                                            {trees.length > 1 && <><br /><br />💡 Swipe here to navigate between trees</>}
                                        </div>
                                    </div>
                                ) : (
                                    <>
                                        {filteredNodes.map((node, index) => (
                                            <NodeComponent
                                                key={node.id}
                                                node={node}
                                                theme={theme}
                                                isSelected={appState.selectedNodeId === node.id}
                                                isEditing={appState.editingNodeId === node.id}
                                                editText={appState.editText}
                                                onEditTextChange={(text) => updateState({ editText: text })}
                                                trees={trees}
                                                currentTreeId={appState.activeTreeId}
                                                isDragging={appState.draggedNodeId === node.id}
                                                isDragOver={appState.dragOverNodeId === node.id}
                                                dragPosition={appState.dragPosition}
                                                onDragStart={dragOperations.start}
                                                onDragOver={dragOperations.over}
                                                onDragLeave={dragOperations.leave}
                                                onDrop={dragOperations.drop}
                                                onDragEnd={dragOperations.end}
                                                isFrozen={isNodeInBranchedSubtree(node.id, index)}
                                                onTap={(e) => {
                                                    e.stopPropagation();
                                                    selectNode(node.id);
                                                }}
                                                onIndent={() => nodeOperations.indent(node.id)}
                                                onOutdent={() => nodeOperations.outdent(node.id)}
                                                onDelete={() => nodeOperations.delete(node.id)}
                                                onFocus={() => nodeOperations.focus(node.id)}
                                                onToggleTask={() => nodeOperations.toggleTask(node.id)}
                                                onToggleComplete={() => nodeOperations.toggleComplete(node.id)}
                                                onBranchOut={() => treeOperations.branch(node.id)}
                                                onEdit={() => nodeOperations.edit(node.id)}
                                                onSaveEdit={nodeOperations.saveEdit}
                                                onCancelEdit={nodeOperations.cancelEdit}
                                                onJumpToBranch={() => treeOperations.jump(node.id)}
                                            />
                                        ))}
                                        
                                        {/* Empty space for tree navigation */}
                                        {trees.length > 1 && (
                                            <div 
                                                style={{ 
                                                    height: '100px', 
                                                    display: 'flex', 
                                                    alignItems: 'center', 
                                                    justifyContent: 'center',
                                                    opacity: 0.5,
                                                    fontSize: '0.875rem',
                                                    textAlign: 'center',
                                                    padding: '0 2rem'
                                                }}
                                                {...enhancedSmartTreeSwipeHandlers}
                                            >
                                                💡 Swipe here to navigate between trees
                                            </div>
                                        )}
                                    </>
                                )}
                            </div>
                        </div>
                    </div>
                )}

                {/* Input Area */}
                {!appState.showMarkdownView && (
                    <div className="input-area" style={{ backgroundColor: theme.background, borderColor: theme.border }}>
                        <div 
                            className="input-container"
                            style={{
                                borderColor: theme.border,
                                backgroundColor: theme.background
                            }}
                            onClick={(e) => {
                                e.stopPropagation();
                                inputRef.current?.focus();
                            }}
                            {...safeInputSwipeHandlers}
                        >
                            <div className="input-prompt" style={{ color: theme.prompt }}>
                                >
                            </div>
                            
                            {appState.indentLevel > 0 && (
                                <div className="indent-indicator" style={{ color: theme.prompt }}>
                                    {'  │'.repeat(appState.indentLevel)}
                                </div>
                            )}
                            
                            <input
                                ref={inputRef}
                                className="main-input"
                                type="text"
                                value={appState.currentInput}
                                onChange={(e) => updateState({ currentInput: e.target.value })}
                                onKeyDown={(e) => {
                                    if (e.key === 'Enter') {
                                        addNode();
                                    } else if (e.key === 'Tab') {
                                        e.preventDefault();
                                        if (e.shiftKey) {
                                            updateState({ indentLevel: Math.max(0, appState.indentLevel - 1) });
                                        } else {
                                            updateState({ indentLevel: appState.indentLevel + 1 });
                                        }
                                    }
                                }}
                                placeholder={
                                    activeTree 
                                        ? `${activeTree.id === 'main' ? 'Main Tree' : activeTree.title}${selectedNode ? `: ${selectedNode.content} (lvl ${selectedNode.level + 1})` : ''} / Swipe left or right here`
                                        : "Start your Tree-e / Swipe left or right here"
                                }
                                style={{ color: theme.text }}
                            />
                        </div>
                    </div>
                )}

                {/* Modals */}
                <Modal
                    isOpen={appState.showAbout}
                    onClose={() => updateState({ showAbout: false })}
                    title="About Tree-e"
                    theme={theme}
                >
                    <div style={{ display: 'flex', flexDirection: 'column', gap: '1rem' }}>
                        <div>
                            <h4 style={{ marginBottom: '0.5rem', fontSize: '1rem', fontWeight: '600' }}>The Philosophy</h4>
                            <p style={{ lineHeight: 1.6, opacity: 0.9, fontSize: '0.875rem' }}>
                                Tree-e embraces the power of simplicity and exploration. Like branches forming trees, individual thoughts combine to create complex ideas. Branch out to explore different paths and perspectives, creating a forest of interconnected knowledge.
                            </p>
                        </div>
                        
                        <div>
                            <h4 style={{ marginBottom: '0.5rem', fontSize: '1rem', fontWeight: '600' }}>Getting Started</h4>
                            <div style={{ fontFamily: 'JetBrains Mono, monospace', fontSize: '0.75rem', opacity: 0.9, lineHeight: 1.4 }}>
                                <div>• Start typing at the > prompt</div>
                                <div>• Tab to indent, Shift+Tab to outdent</div>
                                <div>• Swipe on input to adjust indent level</div>
                                <div>• Tap nodes to select and access actions</div>
                                <div>• Use Branch to explore thoughts in new trees</div>
                                <div>• Click breadcrumbs to navigate between trees</div>
                                <div>• Click "✓ Close" to merge changes back</div>
                                <div>• Use ⟲ button to sync trees and themes between devices</div>
                                <div>• Export button shares all trees as Markdown</div>
                            </div>
                        </div>
                    </div>
                </Modal>

                {/* Sync Export Modal */}
                <Modal
                    isOpen={appState.showSyncExport}
                    onClose={() => updateState({ showSyncExport: false, syncExportData: null })}
                    title="📤 Export to Another Device"
                    theme={theme}
                >
                    {appState.syncExportData && (
                        <div style={{ display: 'flex', flexDirection: 'column', gap: '1rem' }}>
                            <div style={{ 
                                padding: '1rem', 
                                backgroundColor: getColorForLevel(theme, 1),
                                borderRadius: '6px',
                                border: `1px solid ${theme.border}`
                            }}>
                                <p style={{ marginBottom: '1rem', fontWeight: '500' }}>
                                    📱 Copy this data to your other device:
                                </p>
                                <textarea
                                    readOnly
                                    value={appState.syncExportData}
                                    style={{
                                        width: '100%',
                                        height: '150px',
                                        padding: '0.5rem',
                                        fontFamily: 'monospace',
                                        fontSize: '0.75rem',
                                        backgroundColor: theme.background,
                                        color: theme.text,
                                        border: `1px solid ${theme.border}`,
                                        borderRadius: '4px',
                                        resize: 'vertical'
                                    }}
                                />
                            </div>
                            
                            <div style={{ display: 'flex', gap: '0.5rem', justifyContent: 'center', flexWrap: 'wrap' }}>
                                <button
                                    className="btn btn-primary"
                                    onClick={() => copyToClipboard(appState.syncExportData)}
                                >
                                    📋 Copy to Clipboard
                                </button>
                                {navigator.share && (
                                    <button
                                        className="btn btn-success"
                                        onClick={() => shareData(appState.syncExportData)}
                                    >
                                        📤 Share
                                    </button>
                                )}
                            </div>
                            
                            <div style={{ fontSize: '0.75rem', opacity: 0.7, textAlign: 'center' }}>
                                Open Tree-e on your other device → ⟲ → Import Data → Paste the data
                            </div>
                        </div>
                    )}
                </Modal>

                {/* Sync Import Modal */}
                <Modal
                    isOpen={appState.showSyncImport}
                    onClose={() => updateState({ showSyncImport: false, syncImportData: '', syncImportError: null })}
                    title="📥 Import from Another Device"
                    theme={theme}
                >
                    <div style={{ display: 'flex', flexDirection: 'column', gap: '1rem' }}>
                        {appState.syncImportError && (
                            <div style={{ 
                                padding: '0.75rem', 
                                background: '#fef2f2', 
                                color: '#dc2626', 
                                borderRadius: '6px',
                                fontSize: '0.875rem'
                            }}>
                                ❌ {appState.syncImportError}
                            </div>
                        )}

                        <div>
                            <label style={{ display: 'block', marginBottom: '0.5rem', fontWeight: '500' }}>
                                Paste the export data from your other device:
                            </label>
                            <textarea
                                value={appState.syncImportData}
                                onChange={(e) => updateState({ syncImportData: e.target.value, syncImportError: null })}
                                placeholder="Paste the JSON export data here..."
                                style={{
                                    width: '100%',
                                    height: '200px',
                                    padding: '0.5rem',
                                    fontFamily: 'monospace',
                                    fontSize: '0.75rem',
                                    backgroundColor: getColorForLevel(theme, 1),
                                    color: getTextColorForBackground(getColorForLevel(theme, 1)),
                                    border: `1px solid ${theme.border}`,
                                    borderRadius: '4px',
                                    resize: 'vertical'
                                }}
                            />
                            <div style={{ fontSize: '0.75rem', opacity: 0.7, marginTop: '0.5rem' }}>
                                Get export data from your other device: Tree-e → ⟲ → Export & Copy
                            </div>
                        </div>
                        
                        <div style={{ display: 'flex', gap: '0.5rem', justifyContent: 'flex-end' }}>
                            <button
                                className="btn btn-secondary"
                                onClick={() => updateState({ showSyncImport: false, syncImportData: '', syncImportError: null })}
                            >
                                Cancel
                            </button>
                            <button
                                className="btn btn-success"
                                onClick={processSyncImport}
                                disabled={!appState.syncImportData.trim()}
                            >
                                Import
                            </button>
                        </div>
                    </div>
                </Modal>

                <Modal
                    isOpen={!!appState.focusedNode}
                    onClose={() => updateState({ focusedNode: null })}
                    title={`Notes: ${appState.focusedNode?.content || ''}`}
                    theme={theme}
                >
                    <textarea
                        className="note-editor"
                        value={appState.focusedNode?.note || ''}
                        onChange={(e) => updateState({ 
                            focusedNode: { ...appState.focusedNode, note: e.target.value }
                        })}
                        placeholder="Add detailed notes for this node..."
                        style={{
                            backgroundColor: getColorForLevel(theme, 1),
                            borderColor: theme.border,
                            color: getTextColorForBackground(getColorForLevel(theme, 1))
                        }}
                    />
                    <div style={{ marginTop: '16px', display: 'flex', justifyContent: 'flex-end' }}>
                        <button
                            className="btn btn-primary"
                            onClick={() => nodeOperations.saveFocus(appState.focusedNode?.note || '')}
                        >
                            Save & Close
                        </button>
                    </div>
                </Modal>

                <Modal 
                    isOpen={appState.showClearConfirm} 
                    onClose={() => updateState({ showClearConfirm: false })} 
                    title={trees.length > 1 ? "Clear your entire forest?" : "Clear your garden?"} 
                    theme={theme}
                >
                    <div style={{ marginBottom: '16px' }}>
                        {trees.length > 1 ? 
                            "This will remove all your trees and every carefully cultivated thought. Your entire forest cannot be replanted once cleared." :
                            "This will remove all your carefully cultivated thoughts. They cannot be replanted once cleared."
                        }
                    </div>
                    <div style={{ display: 'flex', gap: '12px', justifyContent: 'flex-end' }}>
                        <button
                            className="btn btn-secondary"
                            onClick={() => updateState({ showClearConfirm: false })}
                        >
                            Cancel
                        </button>
                        <button
                            className="btn btn-danger"
                            onClick={clearAll}
                        >
                            Clear All
                        </button>
                    </div>
                </Modal>

                <Modal
                    isOpen={appState.showLospecImport}
                    onClose={() => updateState({ showLospecImport: false, lospecSlug: '', lospecPreview: null })}
                    title="Import Theme from Lospec"
                    theme={theme}
                >
                    <div style={{ display: 'flex', flexDirection: 'column', gap: '1rem' }}>
                        <div>
                            <label style={{ display: 'block', marginBottom: '0.5rem', fontSize: '0.875rem', fontWeight: '500' }}>
                                Palette Slug (from Lospec URL)
                            </label>
                            <div style={{ display: 'flex', gap: '0.5rem' }}>
                                <input
                                    type="text"
                                    value={appState.lospecSlug}
                                    onChange={(e) => updateState({ lospecSlug: e.target.value })}
                                    placeholder="e.g., nintendo-gameboy-bgb"
                                    style={{
                                        flex: 1,
                                        padding: '8px 12px',
                                        border: `1px solid ${theme.border}`,
                                        borderRadius: '6px',
                                        backgroundColor: theme.background,
                                        color: theme.text,
                                        fontSize: '0.875rem'
                                    }}
                                    onKeyDown={(e) => {
                                        if (e.key === 'Enter') {
                                            previewLospecPalette();
                                        }
                                    }}
                                />
                                <button
                                    className="btn btn-primary"
                                    onClick={previewLospecPalette}
                                    disabled={appState.lospecLoading || !appState.lospecSlug.trim()}
                                >
                                    {appState.lospecLoading ? 'Loading...' : 'Preview'}
                                </button>
                            </div>
                            <div style={{ fontSize: '0.75rem', opacity: 0.7, marginTop: '0.5rem' }}>
                                Find palettes at <a href="https://lospec.com/palette-list" target="_blank" rel="noopener noreferrer" style={{ color: theme.prompt }}>lospec.com/palette-list</a>
                            </div>
                        </div>

                        {appState.lospecPreview && (
                            <div>
                                <h4 style={{ marginBottom: '0.5rem', fontSize: '1rem', fontWeight: '600' }}>
                                    Preview: {appState.lospecPreview.name}
                                </h4>
                                <div 
                                    style={{ 
                                        padding: '1rem', 
                                        borderRadius: '6px', 
                                        backgroundColor: appState.lospecPreview.background,
                                        color: appState.lospecPreview.text,
                                        border: `1px solid ${appState.lospecPreview.border}`
                                    }}
                                >
                                    <div style={{ marginBottom: '0.5rem', color: appState.lospecPreview.prompt, fontSize: '0.875rem', fontWeight: '500' }}>
                                        Sample Tree-e Theme
                                    </div>
                                    <div style={{ display: 'flex', gap: '4px', marginBottom: '0.5rem' }}>
                                        {appState.lospecPreview.levelColors.map((color, index) => (
                                            <div
                                                key={index}
                                                style={{
                                                    width: '24px',
                                                    height: '24px',
                                                    backgroundColor: color,
                                                    borderRadius: '4px',
                                                    border: `1px solid ${appState.lospecPreview.border}`
                                                }}
                                            />
                                        ))}
                                    </div>
                                    <div style={{ fontSize: '0.75rem', opacity: 0.8 }}>
                                        Level colors for hierarchy
                                    </div>
                                </div>

                                <div style={{ marginTop: '1rem', display: 'flex', gap: '12px', justifyContent: 'flex-end' }}>
                                    <button
                                        className="btn btn-secondary"
                                        onClick={() => updateState({ lospecPreview: null })}
                                    >
                                        Back
                                    </button>
                                    <button
                                        className="btn btn-success"
                                        onClick={importLospecTheme}
                                    >
                                        Import Theme
                                    </button>
                                </div>
                            </div>
                        )}
                    </div>
                </Modal>
            </div>
        );
    };

    ReactDOM.render(<TreeApp />, document.getElementById('root'));

    // Service Worker
    if ('serviceWorker' in navigator) {
        const swCode = `
            const CACHE_NAME = 'tree-e-v3';
            const urlsToCache = ['/', '/index.html'];

            self.addEventListener('install', event => {
                event.waitUntil(
                    caches.open(CACHE_NAME)
                        .then(cache => cache.addAll(urlsToCache))
                );
                self.skipWaiting();
            });

            self.addEventListener('fetch', event => {
                event.respondWith(
                    caches.match(event.request)
                        .then(response => {
                            if (response) {
                                return response;
                            }
                            return fetch(event.request);
                        })
                );
            });

            self.addEventListener('activate', event => {
                event.waitUntil(
                    caches.keys().then(cacheNames => {
                        return Promise.all(
                            cacheNames.map(cacheName => {
                                if (cacheName !== CACHE_NAME) {
                                    return caches.delete(cacheName);
                                }
                            })
                        );
                    })
                );
            });
        `;
        
        const blob = new Blob([swCode], { type: 'application/javascript' });
        const swUrl = URL.createObjectURL(blob);
        
        navigator.serviceWorker.register(swUrl)
            .then(registration => {
                console.log('SW registered: ', registration);
            })
            .catch(registrationError => {
                console.log('SW registration failed: ', registrationError);
            });
    }
</script>

</body>
</html>
